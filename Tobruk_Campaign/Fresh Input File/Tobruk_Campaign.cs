//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-CoverMission.cs"
////$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-SkinCheckMission.cs" //this might be cause of launcher crashes?  disabling.  2020-09-07
//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-StatsMission.cs"
//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-SupplyMission.cs"
//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-AerialInterceptRadar.cs"
//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Tobruk_Campaign-Class-MakeLandingGround.cs"
//$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs"

/**********************************************************************************
 * 
        ******TOBRUK CAMPAIGN BATTLE SETUP INSTRUCTIONS*******
        *
        * Generally, Mission Objective information & values can be set up in three places:
        *  
        *  #1. Tobruk_Campaign.cs - generally speaking, only a few defaults values & info
        *  
        *  #2. Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs - all of the general objectives, mobile objectives, values and settings we anticipate using for the entire campaign, or that we anticipate using as DEFAULT values for the entire campaign, which can be overriden in individual battle files if we want
        *  
        *  #3. Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPos100.cs or similarly named file
        *      --> This file is named according to the score needed.  So Pos100.cs means a score of +100 (or probably a range +50 to +150), Pos200.cs is +200, Pos300.cs is +300, Neg100.cs is -100,
        *          Neg200.cs is -200, Zero.cs is 0 etc.  (Naming is just a convention we'll use to keep things straight.  The actual score used is set in the variables below.)
        *      --> The actual score values where this file will be activated are set below. Something like this for Pos100.cs:
        *             leastScore = 50;
        *             mostScore = 150;
        *             
        *             However...note that the last battle created, it would be smart to set the score to some huge value so that we are never left without a battle file to use.  
        *             So if our last file is say Pos500.cs then set the values something like
        *             
        *                leastScore = 450;
        *                mostScore = 10000000000;
        *                
        *            This will make Pos500.cs used for score 500 OR anything above it.    
        *            
        *  **********>>>>>>>>>>>> All that seems kind of complicated (and it is) but the purpose is so that file #1 sets up default values which can be superceded and added to 
        *  in file/class #2 and then further superceded and added to in file/class #3.  So you can have objectives and settings and code valid for any campaign we make, for this 
        *  whole campaign, or for one particular battle within the campaign
        *  
        *  How to set up a Battle:
        *            
        *   #1. In your Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPos100.cs  or similarly named file you set up a number of variables with your Battle's subdirectory, airport files, bumrush files, objective files, etc etc etc.
        *          Look below for  battle_subdirectory = "Battles/BattlePos100/";  and a number of lines below that
        *          
        *   #2. Set up your Pos100 (or whatever your new battle .cs file is called) in several places in ...\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs .  
        *       Try searching for "Pos100" to find all relevant places.
        *       
        *        * Add a line like //$include "$user\missions\Multi\Fatal\Tobruk_Campaign\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPos100.cs"  near the top of the file
        *        
        *        *  In method TWCTobrukCampaignMissionObjectives() add lines like these, being careful to make ALL needed adjustments:
        *   
        *                 TWCTCMO battle_pos200 = new BattlePos200(g, m, sc);
        *                 Console.WriteLine("Pos200 inited (return), {0} {1} {2} {3}", battle_pos200.score, battle_pos200.leastScore, battle_pos200.mostScore, battle_pos200.focus_airport_misfile_name);
        *                 register_subclass(battle_pos200);
        *   
        *   #3. On mission startup, method MissionObjectiveAirfieldFocusBumrushSetup() in file ...\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesBattles.cs  
        *       will go through & read all the airport & bumrush files you have have set up in these variables, and verify that they exist.  
        *       
        *       ***IMPORTANT!*** If they don't exist, have a different name, not in the subdirectory specified, etc, they mission will simply EXIT with an error message.
        *       If you can't get your mission to start at all, this is almost certainly the problem.
        *       
        *   #4. Additionally, on startup method MissionObjectiveAirfieldFocusBumrushSetup() sets up your specified bumrush airports as Objectives with primaryobjectiveweight 200 and objective points=30.  
        *   
        *        Our usual scheme for points:  60 points to start the bumrush phase.  That is 6 normal objectives set for 5 points each (30 points) and then the bumrush airport at 30 points.
        *        Then 120 points to turn the map - the first 60 points ot start Bumrush and then 60 more points for winning it.
        *        Note that all these point values are set in \Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs BumRushCampaignValuesSetup() and you can override them 
        *        in each individual battle if you like, but setting up BumRushCampaignValuesSetup() in your \Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPos100.cs 
        *        (or similarly named) file
        *        
        *   #5. Set up the primary objectives you want for the battle. To make items the primary objectives for this battle, you need to do three things below:
        *   
        *        #1 Add the objective here under MissionObjectiveTriggersSetup (OR add some code to change the values of an existing objective to make it into a primary objective)
        *        
        *        #2 Make the points value what you want it (usually 5 points): ... "1006_Chief", 2, 5, "RTobrukGasrResupplyConvoy", ...  (2 is owner army, 
        *           5 is points value, RTobrukGasrResupplyConvoy is objective ID
        *             
        *        #3 Set the primary target weight high enough.  This value varies 0-200, so if you want a target definitely or usually chosen set it to 200 or very close.  
        *           0=never chosen; 200=highest probability of being chosen.  (Even at 200 it won't necessarily ALWAYS be chosen because the selection process randomizes 
        *           the order of the list and then adds primary objectives until reaching the required total primary objective score. So if it needs 40 points and 
        *           you have 7 possible objectives each worth 10 points, it will keep choosing until it choses 4 of them and has 40 points, then stop--even if all are set 
        *           at 200 weight.)
        *           
        *            #3A. If you make more Primary Objectives than strictly necessary, that can be a good thing if the battle ends up being played repeatedly.  
        *            At minimum you need 6 objectives at 5pts each.  But say you make 10 objectives and make all of them 5 points & 200 weight.  
        *            Now every time the map is turned to this battle & new objectives selected, 6 of those 10 objectives will be randomly selected.
        *            
        *            #3B. Also I like to add a point or two to the objectives required score, which will ensure that one or two of the various airports, 
        *            mobile radar, desert radar, etc etc etc objectives around the  map are always included as primaries.
        *        
        *        #4 If you want to, go to file \Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPos100.cs 
        *        (or similarly named file for your battle, \Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesXXXYYY.cs ), 
        *        un-rem the values in BumRushCampaignValuesSetup()  and change them as desired.  Note that these are set in Tobruk_Campaign.cs and 
        *        then overriden in Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs and then you can override them again here if you want.
        *        
        *        #5. There are various other things you can personalize per campaign or per battle, such as flak files.
        *        
        *        
        ***************************************************************************************************************************************
        
        
        ******** HOW TO WRITE A BUMRUSH MISSION (TWC TOBRUK CAMPAIGN SERVER - 29 Sep 2020)************************
        *
        *
        *   So in the Gasr South/Sidi Azeiz Battle, the Reds had completed all of their mission objectives and so 
        *   started the Bumrush period on the Sidi Azeiz airport late last night.
        *   
        *   Overnight when no players at all were in the server, Blue forces successfully attacked and occupied the 
        *   Sidi Azeiz airport. So this repelled the Red attack and set their forces back to square one to re-do 
        *   all of their objectives before they could try another attack.\
        *   
        *   We don't want this to happen--where an airport is taken over via a complete AI attack with few (or even 
        *   just 1-2) players from either side in game.  
        *   
        *   The objective is to have actually winning/occupying an airport be a fairly difficult action that takes 
        *   AT MINIMUM a small team of (live) attacking pilots working together effectively in a coordinated way.

        *   So here are the changes I made to the "Tobruk_Campaign-Rush-Blue-Sidi Aziez Airfield-1.mis" file to 
        *   make this kind of "100% AI/no-live-player airport takeover" impossible.  (Also I had to make one 
        *   small change to the focus airport mission file, "FocusAirports-Gasr_el_abid SidiAzeiz.mis"--see below.) 

        *   This makes a pretty comprehensive How-To Guide for creating Bumrush missions. 
        *   
        *   There is a lot of text below, but it represents about 4 weeks of intensive testing with 
        *   the first Tobruk Battle Scenario, figuring out what worked and what didn't.
        *   
        *   
        *   ***BIG PICTURE**********
        *   
        *     * The Bumrush scenarios are set up so that whichever army is ATTACKING the airport will NEVER succeed 
        *     via AI alone or even with just a small or haphazard force of live pilots on their side.  They will need
        *     a solid, well-organized group of live pilots who are able ot focus on and succe3ssfully executive several 
        *     tasks simultaneously.  
        *     
        *     Short of this happening, by a group of live pilots (ideally, more than just 1 or 2), the campaign will remain
        *     locked in the Bumrush phase.
        *     
        *     The reason for this, is that the campaign should not advance--for EITHER side--by simple random action, by AI
        *     working alone, or by the work of a small, haphazard, or unorganized force of live pilots.  Whichever side wishes to advance
        *     the map should be required to have a significant, organized, capable force of live pilots online working
        *     together to win a significantly difficult objective.
        *     
        *     Also--if the opposing side is similar well organized, led, and focused, they should be able to make it very,
        *     very, very difficult for their enemy to take an airfield and move the front forward.
        *     
        *     But even in absence of a significant enemy force online at a given time, one side still should not be able to
        *     advance the front 'automatically'.
        *     
        *     These goals are accomplished by these means:
        *     
        *         #1. AI air force units from the defending army attack incoming ground units regularly and vigorously, 
        *         until there are enough live pilots in on that side to take over the job.
        *         
        *             - Thus live pilots from the attacking air force must fend off these attacks, or the ground attack will certainly fail.
        *             
        *             - HOWEVER AI air attacks alone are not 100% reliable in killing off the attacking ground forces.  
        *             Many times some ground forces will slip through despite vigorous and repeated AI attacks on it.  So we can't 
        *             rely on this alone as it is not reliable enough  (AI aircraft are highly variable in exactly 
        *             which/how many ground units they take out).
        *             
        *        #2. The defending army has a number of ground forces near the airport and within 3500m of the airport 
        *        center, which the attacking army MUST clear out in order to successfully occupy the airport.
        *        
        *             - These MUST be set up so that the attacking ground forces or other enemy AI units **DO NOT** do 
        *             the job of clearing these out.  Clearing out of these units **MUST** be left to players/live 
        *             pilots from the attacking army.
        *             
        *             - Many of these units are set in place for players from the defending army to use.  That 
        *             means they are AI set in place but set to "time out" for the entire Bumrush period.  That 
        *             means that if no, or only a few, defending army players are in the server these units are 
        *             SITTING DUCKS for enemy pilots to destroy.
        *             
        *             - For that reason, there must ALSO be sufficient active AI AA units placed near "sleeping" AA 
        *             units and "sleeping" tanks to keep them at least reasonably defended.
        *             
        *        #3. To allow players (of both sides) to jump into the "sleeping" tanks and AI units, you must place
        *        a "Tank Spawn" spawn point along with an accompanying airfield and airdrome points near the focus airport
        *        
        *             - The spawn point/airdrome points MUST be placed on friendly or neutral territory and 
        *             NEVER on enemy territory (meaning, friendly/neutral territory for whichever side the Tank Spawn is for)
        *
        *             - The Tank Spawn spawn point should be placed near the airport/airdrome points that you create to 
        *             accompany them (typically immediately adjacent or within 100m)
        *             
        *             - The airport/airdrome points that you create for this purpose must be placed within 10km of the tanks or AA units you 
        *             want the players to access.
        *             
        *               --> Fulfilling these two placement requirements for Spawn Points/Airdrome Points simultaneously 
        *               can be tricky.  Typically the AA/Tanks are placed on ENEMY territory yet the Tank Spawn/Airdrome 
        *               Points must be placed within 10km ofthis and on FRIENDLY or NEUTRAL territory.          
        *             
        *             - Players cannot spawn directly into AA or Tanks (as of TF 5.0).  So here is the workaround: 
        *             Usually we put just one aircraft in the Spawn Point, something unarmed (Tiger Moth for 
        *             Red, ME108 for Blue).  The pilot spawns into this aircraft, then returns to the Flag Screen 
        *             to transfer to either AA or Tank positions, which are nearby.  The Flag Screen shows all available tanks/AA 
        *             within 10km of the pilot's location. Thus the necessity of placing the Tank Spawn/Airdrome points 
        *             within 10km of  the AA/Tank positions.
        *             
        *             - If the pilot spawns out of an aircraft that is landed on enemy territory, this counts as
        *             capture/death/career end etc (-stats.cs).  Thus the necessity of placing the Tank Spawn/airdrome 
        *             points on friendly or neutral territory.  IF you place the Tank Spawn on ENEMY territory 
        *             every pilot who spawns in/out of tha tlocation will lose their career/life/rank.  They will
        *             not be very happy about this.
        *             
        *             - You may need to adjust the front lines (..focus-airports.mis) in order to make the placement possible.  
        *             Just adjust the front line so that there is some friendly or neutral territory within 10km of the Focus
        *             Airport and then place the Tank Spawn & associated airdrome points in that area.
        *             
        *         #4. End Result: Once in Bumrush Phase, we stay there unless some live pilots/players come in and 
        *             actively/effectively intervene in support of the ground attack/occupying force.
        *         
        *             - If no live players (or only a few not doing anything effective) are in the server, every Bumrush scenario MUST play out this way:
        *             
        *                - The Attacking force sends ground troops to occupy the airport
        *                - Enemy AI air force flies against the attaacking round forces & kills many or most of them.
        *                - Quite a number of defending forces are placed near the airport (within 3500m) and no automatic/AI 
        *                  action is taken to kill or remove them.
        *                - For both of those reasons (ground troops coming to airport attacked & killed by AI, defending forces 
        *                  around the perimeter NOT attacked or removed) the AI-only attack NEVER succeeds. The Bumrush period 
        *                  ends unsuccessfully and the other side gets a chance ot attack the airport.
        *                - For the same reasons (in reverse), that counterattack also (ALWAYS!) fails, unless a number of live pilots/players 
        *                  come in and take active/effective/coordinated action to support the ground attack.
        *                  
        *             - In short, the desired result is that the attack on the airport NEVER succeeds by accident or by AI 
        *             action alone.  It only succeeds if the attacking ground forces have some real, effective, coordinated,
        *             support from live players--and more than the amount of support that just 1 or 2 players will be able to provide.
        *             
        *             
        *   ***2. NECESSARY ELEMENTS OF A BUMRUSH MISSION*******************  

        *   In a Bumrush, we have an Attacking Army and a Defending Army.  To win, the 
        *   Attacking Army must:

        *     - PLACE more than 6 ground units within 500 meters of the airport center
  
        *     - CLEAR the area within 3500m of the airport center of ALL enemy ground and 
        *     AA/artillery unites
  
        *     - HOLD this situation (>6 friendly units at airport center, 3500m zone clear
        *      of all enemy ground units) for 5 minutes.
  
        *     - The Attacking Army has 90 minutes to accomplish this. However, if they 
        *     achieve the PLACE & CLEAR requirements before the 90 minute deadline, the 
        *     deadline is extended by up to 5 minutes to allow them to hold for required 5 
        *     minutes and declare victory.

        *   To defend, the defending Army must simply prevent the above three conditions from happening for 90 minutes.

        *   The 10 necessary elements of a Bumrush .mis file:  

        *   #1. Six Attacking Army ground groups coming towards the (exact!) center of the Focus Airfield.  They are 
        *   generally spaced in time to arrive starting at the 15-20 minute mark, and then arrive every 10-15 minutes through the 90 minute mark.

        *       - If you want to make the Bumrush more or less easy/hard for attackers/defenders you could add say 
        *       1 more or 1 fewer enemy attack grounds.
    
        *       - If your ground groups arrive too clumped together or too widely spaced in time, the mission 
        *       doesn't work well.  There are long pauses with no action or the AI defense forces are overwhelmed.  
        *       Generally don't make ground groups arrive at the airport more closely spaced than 10 minutes or much more widely spaced than 15 minutes.
    
        *   #2. 4-8 Attacking Army tanks/armoured units placed 3-5km away from the airport on the attacking army 
        *   side and set to "time out" for most or all of of the mission.  These are for Attacking Army players to hop into and operate.

        *   For example, Attacking Army players could jump into their tanks and drive them onto the airport.  
        *   They would become part of the >6 ground units needed by the Attacking Army on the Airfield to occupy it.

        *     - Blue, Pz.Kpfw.IV Ausf. D works for this role
        *     - Red, Matilda IIA Tank, Vickers Mk. VIC Tank work for this role
  
        *     --> Note that ****SOME**** other tanks & armor will work for these roles 
        *     but you absolutely MUST test them first to be sure players can operate them.
  
        *     --> For example, Matilda IIA Late Tank, Vickers Mk. VIB Tank, Pz.Kpfw.IV Ausf. 
        *     E. Pz.Kpfw.IV Ausf. F, and many others with VERY SIMILAR NAMES to the tanks 
        *     listed above DO NOT WORK as player-controlled ground units. 
  
        *     Crusader II DOES NOT WORK as a player-controlled tank.
  
        *     --> You can test whether a tank works as player-controlled by "play mission" 
        *     in FMB and then jump into that vehicle using your assigned keyboard command. 
  
        *   #3. An Attacking Army Spawn Point (Tank Spawn) and associated/nearby Airdrome and Airdrome Points.  
        *   This should be placed on friendly/neutral territory and within 10km of the Attacking Army tanks/armoured 
        *   units.  This is so that Attacking Army players can spawn into those tanks/armoured units & operate them.

        *   #4. Defending Army Ground Group #1.  DA Group #1 begins within 3500m of the Focus Airfield, 
        *   stays generally on the Defending Army side of the airfield, DOES NOT enter the airfield area 
        *   or get close to any Attacking Army ground group track. 

        *   #5. Defending Army Ground Group #2. DA Group #2 begins many km on the Defending Army side of 
        *   the airfield, travels towards the airfield, and arrives within the 3500m circumference of the 
        *   airfield about 45 minutes into the mission. From that point it acts similar to DA Group #1, 
        *   remaining constantly within the 3500m radius of the airport but staying off of the airfield itself and carefully avoiding any contact with enemy ground groups for the duration of the mission (90 minute Bumrush period).

        *    --> The Attacking Army must clear the area within 3500m of the airfield center.  So these 
        *    to GGs are elements that Attacking Pilots must destroy.  We don't want Attacking AI GGs to 
        *    destroy them (pointless); thus the careful avoidance of any contact between Attacking GG 
        *    and Defending GG paths.  These are like defensive units that don't have ammo/fuel/sufficient 
        *    numbers/clearance from HQ to actually engage the enemy, but that remain in the area in a defensive role.
 
        *   #6. 4-8 Defending Army tanks/armoured units placed 3500m or less from the airport on 
        *   the attacking army side (suggestion: 3000m or less, for a safety margine) and set to 
        *   "time out" for most or all of of the mission.  These are for Defending Army players to 
        *   hop into and operate.  Additionally, they act as a part of the DA ground units within 
        *   the 3500m perimeter that AA must clear.

        *     --> See note above about which tanks/armored vehicles work & don't
        *     work in this role. Most DO NOT work.  Test.

        *   #7. An Defending Army Spawn Point (Tank Spawn) and associated/nearby Airdrome and 
        *   Airdrome Points.  This should be placed on friendly/neutral territory and within 
        *   10km of the Defending Army tanks/armoured units and ALSO within 10km of the Defending 
        *   Army AA/artillery units on the Focus Airfield.  The purpose of this Spawn Point/Airdrome 
        *   Points is so that Defending Army players can spawn into those tanks/armoured units & 
        *   operate them. Players first spawn into an airplane using the Spawn Point/Airdrome Points; 
        *   they can transfer from there to tanks or AA/artillery units with 10km.

        *    --> You may need to adjust the Front Lines for this mission (which are set in the 
        *    Focus Airports .mis file), so that friendly or neutral territory is located within 
        *    10km of the Focus Airport and the AA/artillery units and tanks/armour you place 
        *    in the area for players to use.  Then be sure to place the Spawn Point and (most 
        *    important!) the airdrome points where the player will actually spawn into an airplane, 
        *    on that neutral or friendly territory.
 
        *    --> This becomes even more complicated because most Bumrush files will be used with 
        *    TWO Focus Airport .mis files! So you'll have to double-check that each Tank Spawn 
        *    Point/Airdrome point you place for EACH army will be placed appropriately on neutral 
        *    or friendly territory for WHICHEVER Focus Airport .mis file you're using.  When 
        *    designing the Front Lines in y our Focus Airport .mis files, keep the Front Lines 
        *    close enough to the both focus airports to allow for this.
 
        *    --> Penalty for players if they spawn into an aircraft in enemy territory and then 
        *    leave it, is end of life/career.  That is why it is important that spawn points/airdrome 
        *    points (even "Tank Spawn" points) be placed in friendly or neutral territory only. If 
        *    you get this wrong, many players will be unhappy.  

        *   #8. Defending Army AI AA/artillery units to protect DA tanks.  Suggest 2-4 units placed 
        *   near the tanks.  "Bofors - Standalone" for Red army & "Bofors" for Blue army. 
        *   Purpose: To make it a bit harder for Attacking Army players to clear the tanks from 
        *   the 3500m perimeter, even if no DA players are online; also form part of the DA ground 
        *   units AA players must clear from the 3500m perimeter.

        *     --> Note that many/most AA/artillery DO NOT WORK as player-controlled. Only a select 
        *     few do.  Bofors do, and work well--one reason I have used those exclusively.  Test. 
  
        *     Documentation/more info about player-usable AA/artillery: 
        *     https://theairtacticalassaultgroup.com/forum/showthread.php?t=34228&p=364260&viewfull=1#post364260

        *   #9. Defending Army AI AA/artillery units to protect the airports.  Suggest 2-4 units 
        *   placed around the perimeter of the Focus airport. "Bofors - Standalone" for Red army 
        *   & "Bofors" for Blue army. Purpose: To attack any Attacking Army ground units that 
        *   reach the Focus Airport, defend nearby "sleeping" AA/artillery units and the airport 
        *   itself.  Also they are a portion of the Defending Army ground units the Attacking 
        *   Army players must clear from the 3500m perimeter.

        *   #10. Defending Army player AA/artilley units.  Suggest 6-8 units placed around the 
        *   perimeter of the airport, or on it, or nearby. "Bofors - Standalone" for Red army & 
        *   "Bofors" for Blue army.  These are for Defending Army players to jump into and 
        *   operate. They should be set up on "timeout" the entire mission so that they do not 
        *   operate as AI units, but only if a live player jumps in an operates them.       


        * 
        *   ***3. DETAIL EXPLANATION OF EACH OF THE NECESSARY ELEMENTS**********

        *   Here is a list of problem found with a particular Bumrush .mis file, and the 
        *   adjustments made and reasons the adjustments were necessary.

        *   The mission file under development was the Blue attack bumrush mission for 
        *   Sidi Azeiz (Tobruk_Campaign-Rush-Blue-Sidi Aziez Airfield-1.mis).

        *   This example explains many of the particulars, potential problems, and reasons 
        *   for the guidelines above.

        *   #1. Red (defensive) column #1 starts within 3500m of the center of the airport 
        *   and moves around within that 3500m perimeter throughout the entire 90 minutes, 
        *   but NEVER circles the airport and NEVER comes within range of a blue column

        *     - I use a lot of short "timeouts" in the waypoints so the group isn't just 
        *     stationary for 90 minutes. Instead it makes a small move, then waits 2-10 
        *     minutes, then another move, etc.  So it hangs around the area where we need 
        *     it, moves sometimes but not continuously, and never moves into any area 
        *     where it might get into trouble (ie, onto the airfield, where it is bound
        *     to encounter enemy ground groups, or near the path of any enemy ground group).  
  
        *     - The defending ground groups are like a ground group that has taken a defensive 
        *     position on their side of the airport but doesn't have the ammo/support/numbers/something to go 
        *     on the offensive against the nearby enemy ground groups. So they are taking a 
        *     defensive position, waiting for reinforcements, and generally taking a 
        *     defensive stance but not actively attacking enemy ground groups in the area. 
        *     (In fact if anything they are actively AVOIDING the enemy ground units. This 
        *     is for server reasons (ground groups duking it out against each other destroys 
        *     the server CPU while not affording any realistic way for the pilots to 
        *     participate or adding anything particular to the live player's experience) but 
        *     also we can come up with plenty of real-world reasons why a group of ground 
        *     forces might act this way.)
  
        *     - If they leave the 3500m circumference of the airport then they are not 
        *     counted as enemy which the attacking airforce must clear out to clear the 
        *     area. So 100% of the time they must stay within the 3500m radius. The only way 
        *     for attacking forces to get them out of this radius is for players/pilots to 
        *     come and kill them.
  
        *       -> If you drive the group out of the 3500m radius, you have done defending 
        *       pilots' job for them, for free. -> If you drive them close to enemy ground 
        *       groups, the enemy ground group will kill them, again doing the job the live 
        *       pilots/players are supposed to do.
  
        *     - The fact that this force was circling the airport perimeter and coming into 
        *     contact with the enemy ground forces, which killed it, was one reason the Blue 
        *     (attacking) forces were able to take this airfield with zero effort or 
        *     intervention by Blue pilots last night.

        *   #2. Red (defensive) column #2 starts somewhat distant from the airport and 
        *   arrives within the 3500m perimeter about 45 minutes (halfway) into the bumrush 
        *   period. After arriving within the 3500m perimeter it circles around on the 
        *   "red" side of the airport, much like column #1. It avoids going onto the 
        *   airport or moving into any position which might get it into a firefight with 
        *   Blue ground forces. It just circles around on the red side and just outside 
        *   the airport perimeter.

        *     - This amounts to reinforcements for column #1's defensive position arrive 
        *     about halfway through the bumrush
  
        *     - This keeps pressure on the attacking air force pilots--even if they have 
        *     cleared out the 3500m perimeter in the early part of the bumrush battle, there 
        *     is this second column approaching and entering the perimeter around the 45 
        *     minutes mark, so they have to keep attacking/clearing the area & can't just 
        *     rest on their laurels.
  
        *     - To adjust the time of arrival at the 3500m perimeter, I just move Waypoint 
        *     #0 in or out a little until the desired arrival time (10:45 in this case) 
        *     shows on the waypoint nearest the 3500m perimeter point. This is the same 
        *     trick I use to adjust the arrival times for all the ground groups (see below).
  
        *     - Like Column #1, once the ground group is inside the 3500m perimeter I start 
        *     adding some timeouts to their waypoint, so they may move 500-1000-2000 meters, 
        *     then wait (timeout) 5-10 minutes, then move again, wait 2-10 minutes, etc. 
        *     This keeps them within the required 3500m perimeter and on the red side of the 
        *     airport for the required period of time, without keeping them entirely 
        *     stationary and predictable in their location (which make them a bit of sitting 
        *     ducks for enemy pilots).

        *   #3. Red (defensive) tanks placed within the 3500m airfield perimeter. If they 
        *   are placed too far away--say, 5000m--then they do not count as part of the 
        *   ground defenses that the attacking air force must clear from the area in order 
        *   to win.

        *     - The fact that this force was placed outside of the 3500m perimeter, and thus 
        *     did not count as part of the ground force that the attacking air force had to 
        *     clear, was one reason the Blue (attacking) forces were able to take this 
        *   airfield with zero effort or intervention by Blue pilots.

        *   #4. Red (defensive) Tank Spawn airfied/airdrome points moved to a point 
        *   outside of enemy territory, but still within 10 km of all tanks & AA that we 
        *   want the Red (defensive) players to be able to spawn into.

        *     - I had to adjust the front lines in the ..focus-airports.mis file in order to 
        *     be able to place this spawn point properly
  
        *     - I just adjusted the front markers to expand "no man's land" until there was 
        *     a piece of no-man's land within 10km of the airport/all of the Red AA/tanks
  
        *     - If the spawn point/airfield is more than 10km from the AA/tanks then players 
        *     can't move from the Tiger Moth they have spawned into, to the AA or tank they 
        *     want. (I believe 10km is the limit for showing available AA/tanks on the flag 
        *     screen.)
  
        *     - If the spawn point/airfield is on enemy territory then when players spawn 
        *     into an aircraft there and then move out of the aircraft to an AA or tank, 
        *     -stats.cs counts that as "landing on enemy territory" which will usually get 
        *     the player killed/imprisoned/career lost, etc. So we need the point where they 
        *     spawn into the aircraft to be either on friendly OR neutral a territory. (Yet 
        *     also, as explained above, within 10km any any tank/AA they might want to spawn 
        *     int.)

        *   #5. 3 or live AA (Red-defensive) placed on the airport or generally around the 
        *   perimeter. This could be may 2-4 live AA, or maybe even 5-6. But if it is less 
        *   than 2 or 3 it makes it FAR too easy for the attacking army's pilots to just 
        *   fly around the airport and surrounding area with no opposition whatsoever and 
        *   just pick off all the defenses off one by one.

        *     - These are part of the "safety net" that prevents the airport from being 
        *     overrun by enemy ground forces with no intervention at all from the attacking 
        *     air force players. If the AI AA are live on the airfield, they will shoot and 
        *     kill any enemy ground forces that come onto the field. So (minimally!) to 
        *     allow a successful ground invasion, the attacking players will have to attack 
        *     & kill these AI AA installations placed on/around the airfield.
  
        *     - Any individual AI AA unit often has a bad angle, small hill (or even crater) 
        *     interrupting its line of fire, etc, and so isn't able to singlehandedly take 
        *     care of any enemy ground units that arrive on the airfield. That is why it is 
        *     better to have 2-3-4 AI AA placed in the area; among them all usually at least 
        *     one has the needed line of fire.
  
        *       -> This is another reason to make sure invading ground forces have their final 
        *       waypoint very near the center of the airfield; this is more likely to place 
        *       them within a good line of fire of at least one of these AI AA units. If they 
        *       line up way off to the side they can easily be out of the line of fire.
    
        *       -> This function is another reason to stick with Bofors as the AA AI; they are 
        *       proven to be able to handle this function whereas other AA AI may be defeated 
        *       by the ground forces instead.
  
        *     - Most of the defensive army (Red, in this case) defenses are "timed out," in 
        *     place for live players to be able to jump into them & use them, and won't do 
        *     anything to defend themselves in cases where there are few/no defensive 
        *     players online. In that case they are just sitting ducks unless there are at 
        *     least some minimal level of AI defenses in place around the airport to defend 
        *     them.
  
        *     - I've followed the convention of using "Bofors - Standalone" for the Red army and regular "Bofors" (ie, the kind mounted on a little wheeled trailer) for Blue army. Thus both sides have an AA unit with similar capabilities & firepower, but the two are visually differentiated for pilots.
  
        *     --> Note that many/most AA/artillery DO NOT WORK as player-controlled. Only a select few do.  Bofors do, and work well--one reason I have used those exclusively.  Test. 
  
        *     Documentation/more info about player-usable AA/artillery: 
        *     https://theairtacticalassaultgroup.com/forum/showthread.php?t=34228&p=364260&viewfull=1#post364260

        *   #6. I placed 6-8 "Bofors Standalone" around the field that are "timed out" and 
        *   so inactive/won't be operated by AI. But they are available for live players 
        *   to jump into and use to defend the airport. ALSO (and IMPORTANT!!) they become 
        *   part of the group of enemy ground forces that the attacking air force players 
        *   must clear from the field in order to occupy it and take it over.

        *     - I just put these Bofors on "timeout" for 12 hours, which means they will 
        *     just sit inactive for our entire mission (90 minutes Bumrush) unless a player 
        *     jumps in to operate them.
  
        *     - Again for consistency/visual ID/known to work correctly I use "Bofors 
        *     Standalone" for Red & "Bofors" for Blue for this function.
  
        *     - The fact that airfield did not have any of these "timed out" Bofors placed 
        *     around it is one reason that the Blue ground troops were able to take over 
        *     this airfield even though zero live pilots from either side where in the 
        *     server at the time.
  
        *     - Coming in & clearing the airfield of both the live & "timed-out" AA units is 
        *     one of the first jobs the attacking air force pilots will need to do if they 
        *     want to have success in attacking & occupying the airfield.

        *   #7. I adjusted all Blue (offensive) ground columns to end their routes pretty 
        *   much exactly in the center of the airfield. Technically we are looking at, the 
        *   columns must be within the 500m radius of the center of the airfield to count 
        *   as "occupying" it. But if you put the end waypoint near 500m, some vehicles 
        *   may end up within the 500m radius, some just outside of it, etc. Best just to 
        *   keep that final waypoint within 100m of the airport center point for safety.

        *   #8. For PLAYER-OPERATED TANKS: Changed Matilda IIA Late tanks for Matilda IIA. Remove Crusader II tanks (replaced with Matilda IIA).  Changed Armor.Pz_IVE, Armor.Pz_IVF etc to Armor.Pz_IVD.

        *   These tanks DO NOT WORK as player-controlled vehicles (TF 5.0):

        *    Matilda IIA Late
        *    Crusader II
        *    Armor.Pz_IVE
        *    Armor.Pz_IVF
        *    Vickers VIB
        *    A bunch of others
 
        *   These DO WORK as player-controlled:

        *     Matilda IIA
        *     Vicker VIC
        *     Armor.Pz_IVD
        *     A VERY FEW select others
  
        *     Documentation about this (which vehicles/AA work/don't work as player-controlled):
        *     https://theairtacticalassaultgroup.com/forum/showthread.php?t=34228&p=364260&viewfull=1#post364260

        *   #9. I looked at the point of arrival of each attacking ground group (ie, the 
        *   time of the final waypoint near the airfield center point) and adjust them so 
        *   that they arrive generally 10-15 minutes apart, and spaced throught the entire 
        *   90 minute bumrush period.

        *     - If you clump the ground group arrivals too close together then there is a 
        *     short period of intense activity and then long periods--before and after--of 
        *     nothing.
  
        *     - Also the AI air defenses that are set to attack these groups are just 
        *     overwhelmed if a bunch of ground groups all arrive at once. So then some of 
        *     them get through and that is what allows the airfield to be overtaken with 
        *     zero activity by attacking air force players. Which is what we DON'T want.
  
        *     - If we want a bunch of ground groups to arrive at once then we'll have to 
        *     also calibrate AI air defenses (which kick in when there are few or no 
        *     breather pilots in-game on that side) to be able to handle a whole bunch of 
        *     ground groups attacking at once. The result of that won't be good--it will 
        *     just cause massive slowdowns to the server as AI battles AI in massive battles 
        *     while few or even NO live players are online. So, that is pointless.
  
        *     - Also I added one more Blue ground attack. That makes 6, which seems about 
        *     the right amount.
  
        *     - I generally set the arrival time of the first group somewhere around 15-20 
        *     minutes after the start of the Bumrush and then roughly spaced out 10-15 
        *     minutes, or maybe 20 minutes, apart thereafter.
  
        *     - The final group should be set to arrive in the final few minutes of the 
        *     bumrush period (the final 5-10 minutes or so?) - if you don't have something 
        *     set to arrive during that time frame there is nothing going on and so, little 
        *     point in having the bumrush extend that long.
  
        *     - On the other hand there is no point in having the groups come trailing in if 
        *     they don't arrive by the 90 minute mark. It will just make players made if 
        *     they have been fighting to clear the path for them to arrive safely, and then 
        *     time just runs out before they get on the field. Also I don't know that the 
        *     time estimates given in the Waypoint fields are 100% accurate, so I try not to 
        *     cut it *too* close to the 90 minute mark.
  
        *     - I check the time of arrival by simply looking at the time given for the 
        *     final waypoint (at the center of the airport). This seems to be accurate 
        *     enough.
  
        *     - I adjust the arrival time by just moving the first waypoint (Waypoint #0) in 
        *     or out a little until the desired time (final waypoint time) is achieved.
  
        *     - The course of these groups is set so as to avoid (pointless) firefights 
        *     between Red & Blue ground columns. I just make the courses of the two armies' 
        *     ground groups entirely avoid each other, and by a wide enough margin that they 
        *     won't "see" each other and start shooting.
  
        *     Here are the arrival times of the Blue groups as I set them up:
  
        *     (Mission starts at 10:00) 
  
        *       * Chief_23 - 10:21
        *       * Chief_4 - 10:37
        *       * Chief_2 - 10:53
        *       * Chief_3 - 11:04
        *       * Chief_5 - 11:13
        *       * Chief_1 - 11:24
  
        *     So you can see they start arriving at the airport around 10:21 (at the 
        *     center--they will be near the perimeter about 5 mins before that) and a new 
        *     group comes every 15 mins or so thereafter. Towards the end there they are 
        *     more like 10 mins apart, so there is a sort of accelerando as the bumrush 
        *     progresses (which is one way, but not the only way, to do it).


        *   
        *   
        *   ***MAKING A VARIANT BUMRUSH .MIS FILE*****************
        *   
        *   Once you have a bumrush .mis file that you KNOW works (suggestion: test), then it is easy to make a 
        *   variant second .mis file.  Two variant bumrushes for each side/each focus airport is usually enough 
        *   to make it interesting/unpredictable for players when the battle comes back around, but nothing 
        *   is stopping you from making 3 or 4.  Suggestion: Test your first .mis well before you do this; 
        *   otherwise you're changing problems/errors in 4 or 8 different files which isn't fun.
        *   
        *   #1. Bumsush file .mis name will have the same beginning & a different suffix at the end.  
        *   Check your PosXXX.cs file for the details of how you have set this up.  But for 
        *   example your initial .mis might be "Tobruk_Campaign-Rush-Red-Sidi Azeiz Airfield-1.mis"
        *   and "Tobruk_Campaign-Rush-Red-Sidi Azeiz Airfield-2.mis" is your variant.  
        *   
        *   #2. If your ...PosXXX.cs file is set up correctly, then when a bumrush starts, either one of these files will be selected randomly.
        *   
        *   #3. Start with the (known working) -1.mis file and save it with the different filename (...-2.mis)
        *   
        *   #4. Scramble around the AA locations on the airfield into a different logical setup.
        *         - Maybe you add or subtract 1 or 2 active and/or timed-out AA, just to keep things a bit unpredictable for players
        *   
        *   #5. Move the tanks for both sides into a different logical location.  (Be sure to keep the defending tanks WELL WITHIN 3500m of the airfield center.  Make sure tanks of both sides are still within 10km of the Tank Spawn location.)
        *         - Maybe you add or subtract 1 or 2 tanks for each side, for variety
        *   
        *   #6. You have already set up the ground group attacks for each side in a logical sequence. So all you do is:
        *       A. Look at each ground group, find out what time it arrives at the key location (for attacking ground groups--in the center of the airfield; for defending--within the 3500m "must-be-cleared" radius)
        *       B. Change the path of the ground so it is different (comes in from a different logical direction etc) but **still arrives at its key point within a few minutes of the previous time**)
        *          -> So for example you find an attack group that comes in from the SW and arrives at 11:09.  Just change it to come in from NW and arrive at 11:08.
        *          -> Repeat similarly for each of the 6 attacking & 2 defending groups (these are the normal amounts for each side.  For variety you could add/subtract and extra ground group of course).
        * 
        *   #7. Now you have a variant of the original Bumrush file that still has the same general dynamics--ground groups arriving from different directions throughout the entire mission, etc.
        *          -> Save the file
        *          -> Done
    
        *   ********************************************************************
 * 
 * ********************************************************************************************/



//TODO: Check what happens when map turned just before end of mission, or even after last 30 seconds.
#define DEBUG  
#define TRACE  
////$reference parts/core/GCVBackEnd.dll
////$reference parts/core/CLOD_Extensions.dll
////$reference parts/core/TWCStats.dll
//$reference parts/core/CloDMissionCommunicator.dll
//$reference parts/core/Strategy.dll
//$reference parts/core/gamePlay.dll
//$reference parts/core/gamePages.dll
//$reference System.Core.dll 
////$reference Microsoft.csharp.dll
//$reference WPF/PresentationFramework.dll
//$reference WPF/PresentationCore.dll
//$reference WPF/WindowsBase.dll
//$reference System.Xaml.dll
//$reference System.xml.dll
//$reference System.runtime.serialization.dll
///$reference System.Text.Json.dll
//The first two $references above + perhaps the [rts] scriptAppDomain=0 references on conf.ini & confs.ini are (perhaps!?) necessary for some of the code below to work, esp. intercepting chat messages etc.
// $reference System.Core.dll  is needed to make HashSet work.  For some reason.
///$reference parts/core/MySql.Data.dll  //THIS DOESN'T SEEM TO WORK
///$reference parts/core/System.Data.dll //THIS DOESN'T SEEM TO WORK

// v.1_19_07. script by oreva, zaltys, small_bee, bhugh, flug, fatal_error, several other contributors/online code snippets & examples

using System;
using System.Runtime;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

//using GCVBackEnd; //So, tried GCVBAckEnd 2020/03/30 and it just makes the server use 100% CPU etc.  Some kind of problem.

using System.Collections;
using System.Globalization;
using maddox.game;
using maddox.game.world;
using maddox.GP;
using maddox.game.page;
using part;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.IO;
using System.Text;
using System.Net;
using System.Security.Cryptography;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Dynamic;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Xml;
using System.Xml.Serialization;



//using System.Web.Script.Serialization;
//using System.Text.Json;
//using System.Text.Json.Serialization;
//using TF_Extensions;
//using GCVBackEnd;
using System.Timers;                 /// <= Needed for Rearm/Refuel
/*****************************************************************************
 * TODO  / Ideas
 * 
 * WEATHER: Loading as submissions doesn't seem to work.  Maybe best just to leave it due to effect on performance.  Update:  Maybe they do work? It is surprisingly hard to tell.
 * 
 * RESUPPLY: Keep track of last time resupplied & do resupply @ start of mission if it wasn't completed at the end.  OR just do it at the start every time.
 * 
 * COVER: Make a whole nother menu screen, linked to Tab-4-4-4-4-6, which gives commands like
 *   - Faster/Slower by 1-2% per notch
 *   - Hold/Follow (hold alt & speed vs follow the breather's lead)
 *   - Attack/follow (escort/attack nearby fighters vs follow the main ac
 *   - Wide/compact spread (double the inter-aircraft spread, or back to normal, or maybe 3 options, normal, wide, extra wide)  This could apply to vertical distance or perhaps lead/follow distance when on a bombing run
 * 
 * RECON PHOTOS: When player aircraft is damaged, crash landing, etc, the photos are spoiled depending on amount of damage.  Maybe some % is spoiled and more if more damage happens to player a/c.
 * 
 * RECON PHOTOS: Give the player a hint when interesting objectives are found/photo taken & suggest they try to find that objectives & take an actual recon photo to help bombers etc.  So maybe primary objectives, maybe all mobile objectives, etc.  Can just say something like "potentially interesting objective found at BA14.2.3 - please visually find the objective in that area & take a screen shot/photo of that area to help bomber pilots." type of thing.
 * 
 * KEEP TRACK of CLOSED or MOVED OBJECTIVES and then inform players when they have bombed or attacked on.  Also when an objective is bombed or attacked this could count as further scouting of that objective (at least to the point of updating its location or putting !!MOVED!! !!NOT THERE!! type messages in the scouting list. (partially implemented).
 * 
 * Scouting could ID location of nearby FLAK BATTERIES.  Maybe these could be IDed via distance/compass degrees from the nearby target.  So 500m/120degrees type of thing.  you could list several batteries like 500/62 220/175 740/321.
 * 
 * WHEN partially destroyed objectives are RESET when one side wins, then if PointArea it can put the other side in a situation hard or impossible to kill enough 'objects'.  Because most of them are already dead.
 * So could add more objects, or maybe don't reset the 'objects killed' portion.
 * 
 * ORRRR maybe make the PointArea kill a bit more flexible between objects & KG.  Especially, if you've got multipleX the kg then it can start to count a bit for object kill. 
 * 
 * Not sure if airport repair thing is really working.  Airports don't seem to be repaired after victory.
 * Give some list of targets partially damages, or at least primary targets.  Maybe just on primary target list, %
 * Renew all Winners damage on the next morning after a Victory.  Probably just save the winner(s) of the previous campaign in a file & then check on startup and repair all their damage if thye are there.  Much like the previous "turned the map".
 * Also maybe repair all the damage after a victory within the next X hours rather than over the entire day.  Maybe 6 hours or 4 hours. 
 * 
 * Set a certain max distance each mobile unit can move each day or each time it moves.  So 5km per day or 20km per day or maybe 200km per day, whatever.
 *  - also could implement fatal's idea that some types are a camp one day, then a traveling caravan the next, then a camp, etc.
 * Allow each objective to set how often it will be enabled or disabled.  So you have some that appear only 20% of days, some 50%, some 90%, some 100%, whatever.
 * Put in some Spitfire factory, 109 factory, bomber factory type of targets that reduce the output of those a/c for a while if taken out
 *   - This is mostly set up on MissionObjective but just needs to be implemented for some objectives AND the -supply.cs bits taken care of
 *   - It would be super-helpful to bring -supply.cs in as an $include file before doing this
 * For production/storage damaged & cuts, the fuel supply limits can be implemented by R&R command with say 50% fuel for fighters & maybe 12% for bombers.
 * Update Knickebein to show the 100meter dots starting at 5km out, to allow bombers to target drop point but also AI to target their point (the actual point)
 * Create a simple AI radar display like they had in the original Beaufighter.  Just display angle vertical, angle horizontal, and range.  Like this:
 * 
 *       -----   |||||||||||   ++++
 *              +++   ||   =
 *       
 *       Left +/=/- shows relative altitude angle of the target, right +/=/- shows left/right horizontal angle, and |||||| shows range.
 *       https://www.sas1946.com/images/imageshit/img204/4231/aimkiv2.jpg
 *       https://www.sas1946.com/images/imageshit/img163/3200/aimkiv1.jpg
 *       
 * Cover - available a/c listing, but a delay in so it doens't just flash up/cause stutter      
 *   
 * Listing of how much damage, % destroyed, and/or objects/KG destroyed for all your and/or enemy objectives.
 * Allow recon or some way for teams to find out where the enemy has been attacking **in their own territory**
 * "Go to Team Stats for *DATE*" on team stats page should list previous AND next dates, and also list them at top AND bottom of the page
 * 
 * XXX Allow fighters to call in a few bombers to escort (for testing)
 * XXX Turn off certain % of objectives @ start of each day.  Disabled.  If  possible make them disappear also.  Also make a new field for probability/chance of being chosen as disabled.
 *     - For now nothing disappears (todo)
 * XXX Make difficulty/tonnage required to take out airports somewhat harder.  Maybe 50%, 75%?  It is now easy to take out an airport with one formation of bombers, probably should take at least 2 formations
 *    - Remove/merge duplicate code for radar damage between -stats & -main
 * XXX Some way to make it harder to take out radar, such as including 2 radar towers positioned randomly or something and BOTH have to be taken out (For DE side, don't know what ot do about GB; but maybe they have a smaller lowered powered antenna or unit nearby that needs to be taken out also; it could be randomly placed)
 *    - For DE it would be easy to randomly move the radar by up to say 2km each day.
 *    - XXX Increase flak @ radar (done).  Could be increased more?
 *    TODO - could make the GB radar more like the DE - a PointArea target, add some spare 'auxiliary backup' radar units etc.
 **
 * XXX 2-3 naval objectives like Folkestone Harbor that basically appear/disappear pretty much daily.
 * Also could have a PointArea target that consists of ships sailing somewhere.  As long as the pointarea is large enough the ships are always staying in it, it will work
 *  - Could have 2-3 of these for each side, and again they appear/disappear pretty much daily.
 *  - Not sure how mission objectives could work with such regular appear/disappear, as right now they'll be chosen and primary but then un-chosen when they disappear.  Maybe just keep them as 'chosen' even though they are disabled and then when re-enabled, they will still be chosen & the primary obj. will just have to be rearranged to compensate each time.
 * XXX Randomly placed objectives that spawn in with a preset kind of configuration, a bit like the General's Staff
 * XXX Keep the mission going continuously, even when one side turns the map.  Just give a message and keep on going.
 * XXX  - Radar can be turned on again immediately  TODO: Check this is really working.  I think it is.
 * XXX  - Airports could have their craters removed and have a basic pre-set spawnpoint put in place
 *   
 * XXX Keep a list of all players who have contributed towards taking out a given objective, as part of MO_objectives, and then ALSO list those contributing players in the final session summary.  Similar to the scoutedplayers list.
 *   
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * ***************************************************************************/

//////////////////simply change the////////////////////////
//////////////////GamePlay.gpHUDLogCenter("Do 17's traveling towards Lympne");///////////////
/////////////////into/////////////////////////////
//////////////////sendScreenMessageTo(1, "Do 17's traveling towards Lympne", null);/////////////////////
///////////////////////so only the red pilots get the message./////////////////////////////////

/*
namespace GCV {
    public class GCVMission : BaseMission
    {
        public GCVMission()
        {
            // outPath = @"C:\Users\Brent Hugh.BRENT-DESKTOP\Documents\1C SoftClub\il-2 sturmovik cliffs of dover\missions\Multi\Fatal\GCV";
            outPath = @"C:\GCV\Tobruk_Campaign";
            Console.WriteLine("GCV initialized");
        }
    }
}
*/


namespace coord
{
    public class Communicate
    {
        int test = 14;
        AMission ms;
    }
    public sealed class Singleton
    {
        private static readonly Singleton instance = new Singleton();
        // Explicit static constructor to tell C# compiler  
        // not to mark type as beforefieldinit  
        static Singleton()
        {
        }
        private Singleton()
        {
        }
        public static Singleton Instance
        {
            get
            {
                return instance;
            }
        }
        public AMission Main { get; set; }
        public AMission Stats { get; set; }
    }
}

//so we have the problem that we have used type Player extensively to pass back & forth to various methods.  It's convenient and the Player type has lots of useful information.
//But . . . sometimes we only have the player's name & we still need to do things like record stats and such for that player.
//CloD doesn't let us create a new Player player for anyone who has not logged in to the game (in that case cloD makes the player automatically).
//So this little class built on the Player interface from maddox.game.Player allows us to do this trick:
// aPlayer p1 = new aPlayer("Fred Jones", 1);  //name Fred Jones, army=1
// Player p2 = p1 as Player;
//Then we can send p2 to any method that usually accepts Player
//And . . . mostly those methods only need the player's name & army, so it works.  Obviously if it needs more it will fail as most of the info returned below is fake/dummy.
//
//you can also initialize as 
//   aPlayer p1 = new aPlayer(player);  //if you already have a valid Player player from Maddox
//ALSO - aPlayer is serialiable & can be saved/restored.  So it can used used as part of arrays, dictionaries, etc that are saved/restored when session  stops/restarts.
//In that case, should use "new aPlayer(player)" as invocation for the aPlayer object, otherwise it will just be nil.

[DataContract]
public class aPlayer : Player
{
    [DataMember] public string name;
    [DataMember] public int army;
    private Player player;

    
    public string Name() { return name;  }
    public bool IsConnected() { return false; }    
    public int Channel() { return 0; }    
    public string ConnectAddress() { return ""; }    
    public int ConnectPort() { return 0; }    
    public int Army() { return army; }    
    public AiActor Place() { return null; }
    public int PlacePrimary() { return 0; }
    public int PlaceSecondary() { return 0; }
    public AiPerson PersonPrimary() { return null; }
    public AiPerson PersonSecondary() { return null; }
    public bool AutopilotPrimary() { return false; }
    public bool AutopilotSecondary() { return false; }
    public bool IsExpelArmy(int i) { return false; }
    public bool IsExpelUnit(AiActor a) { return false; }
    public void SelectArmy(int i) { return; }
    public void PlaceEnter(AiActor a, int i) { return; }
    public void PlaceLeave(int i) { return; }
    public int Ping() { return 0; }
    public string LanguageName() { return ""; }

    public aPlayer()
    {
        player = null;
        name = "";
        army = 0;

    }
    public aPlayer (aPlayer p )
    {
        player = p;
        name = player.Name();
        army = player.Army();
        
    }
    public aPlayer(Player p)
    {
        player = p;
        name = player.Name();
        army = player.Army();
        
    }

    public aPlayer(string n, int a)
    {
        name = n;
        army = a;        
    }

    /*
    public override bool Equals(Object obj)
    {
        if (obj == null || GetType() != obj.GetType())
            return false;

        else return this == (aPlayer)obj;
    }

    public override int GetHashCode()
    {
        return Tuple.Create(name, army).GetHashCode();
    }

    public static bool operator ==(aPlayer x, aPlayer y)
    {
        return x.name == y.name && x.army == y.army;
    }

    public static bool operator !=(aPlayer x, aPlayer y)
    {
        return !(x == y);
    }

    public override String ToString()
    {
        return String.Format("({0}, {1})", name, army);
    }
    */
}

//public class Mission : AMission, IMainMission
public class Mission : AMission, IMainMission
//public class Mission : BaseMission, IMainMission
{
    public Random random, stb_random;
    //Constants constants; 
    public int PERCENT_SUBMISSIONS_TO_LOAD = 100; //percentage of the aircraft sub-missions to load.  50 will load just half of the sub-missions etc.
    public string MISSION_ID { get; set; }
    public string CAMPAIGN_ID { get; set; }
    public string SERVER_ID { get; set; }
    public string SERVER_ID_SHORT { get; set; }
    public string CLOD_PATH { get; set; }
    public string FILE_PATH { get; set; }

    public bool DEBUG { get; set; }
    public bool DISABLE_TESTING_MODS { get; set; } //whether to disable certain testing mods and run close to exactly as the live server, even though running on the test server
    public bool LOG { get; set; } //Whether to log debug messages to  a log file.
                                  //public bool WARP_CHECK { get; set; }

    public ABattle gpBattle;
    public CoverMission covermission;
    public StatsMission statsmission;
    public SupplyMission supplymission;
    public AIRadarMission airadarmission;
    public LandingGroundMission landinggroundmission;
    //public SkinCheckMission skincheckmission;
    //public BaseMission gcvmission;

    public string MISSION_FOLDER_PATH;
    public string USER_DOC_PATH;
    public string stb_FullPath;
    public Dictionary<int, string> radarpasswords;
    public string BOMBERMISSIONS_FILE_PATH;
    public string MESSAGE_FILE_NAME;
    public string MESSAGE_FULL_PATH;
    public string STATS_FILE_NAME;
    public string STATS_FULL_PATH { get; set; }
    public string LOG_FILE_NAME;
    public string LOG_FULL_PATH;
    public string STATSCS_FULL_PATH { get; set; }
    public int RADAR_REALISM;
    public string RESULTS_OUT_FILE; //Added by Fatal 11/09/2018.  This allows us to have win/lose logic for next mission

    public Dictionary<string, MissionObjective> MissionObjectivesList { get; set; }
    //public Dictionary<string, IMissionObjective> SMissionObjectivesList { get; set; }

    static public List<string> ArmiesL = new List<string>() { "None", "Red", "Blue" };
    //public enum ArmiesE { None, Red, Blue };

    public bool MISSION_STARTED = false;
    public bool WAIT_FOR_PLAYERS_BEFORE_STARTING_MISSION_ENABLED = false;
    public double MAP_WIN_POINTS = 4500; //number of campaign points required to win the campaign.  This is used to draw the front line in the middle of the Channel at +MAP_WIN_POINTS it will be moved all the way in Red's favor; at -MAP_WIN_POINTS it will be moved all the way towards GB in blue's favor.
    public int MO_Objective_Percent_To_Disable = 20; //How many of the mission objectives on the list to randomly disable on a given day.
    //public int MO_Objective_Percent_To_Disable = 0; //for testing
    public int START_MISSION_TICK = -1;
    public double START_MISSION_TIME_HRS = 0;
    //So 20:15/8:15 pm is about the latest you can run a mission and still have any light.
    //5:00AM IS GOOD FOR START, 4:45AM IS GOOD ENOUGH & NICE LOOKING.  4:30AM IS REALLY NICe looking, esp once in air, but probably too dark to taxi reasonably.   The sun is just up at 4:30am.
    //public int MISSION_LENGTH_HRS = 720000; //6 HOURS
    //public int MISSION_LENGTH_HRS = 1440000; //12 Hours
    //public int MISSION_LENGTH_HRS = 1680000; //14 Hours
    //public int MISSION_LENGTH_HRS = 1980000; //16.5 Hours, starting at 4:45am and ending at 9:15pm.
    //public int MISSION_LENGTH_HRS = 720000; //14 Hours-ish
    public double MISSION_LENGTH_HRS = 6.5; //720000; //6.4 Hours-ish
    //public int MISSION_LENGTH_HRS = 350000; //3 Hours-ish
    //public int MISSION_LENGTH_HRS = 198600; //just over 90 minutes, mayber 100 minutes.  So just one bumrush period & a little more.

    public double END_MISSION_TIME_HRS = 20.5; //So this means, the server will never run past 20.15 hours (8:15pm) server time, regardless of then it starts.  Reason is, it gets too dark after that.  So the mission will run either to ENDMISSION_TIME **OR** MISSION_LENGTH_HRS, whichever happens first.  MISSION_LENGTH_HRS is really redundant now but maybe it is a good failsafe to prevent everlasting missions?  Also we could use it to set a runtime shorter than the absolute max possible, thus we could start at different times of day and run a certain amount of time designated by MISSION_LENGTH_HRS, but never start earlier than DESIRED_MISSION_START_TIME or run later than ENDMISSION_TIME
    //public double END_MISSION_TIME_HRS = 4.51; //TESTING
    public double EARLIEST_MISSION_START_TIME_HRS = 6.8; //The time we would like to/plan to start the mission.  0430 hours, 4:30am. This will be used as the start time unless the mission previously ended/stopped/crashed/was turned at some different time; in which case it will start again at the time it crashed unless it is too late in the day (see SHORTEST_MISSION_LENGTH_ALLOWED)
    //public double EARLIEST_MISSION_START_TIME_HRS = 7.5; //FOR TESTING
    public double SHORTEST_MISSION_LENGTH_ALLOWED_HRS = 3;  //if the mission restarts and there are less than this many hours remaining until END_MISSION_TIME_HRS , then it will just restart at the DESIRED_MISSION_START_TIME.  This has the effect of guarantteeing that missions will run at least this many hours, and also that missions won't start or run later than END_MISSION_TIME_HRS

    //TOBRUK sunrise is about 7am.  Whereas BLITZ it is more like 4:45am
    //TOBRUK 6:45 is tolerable as "pre-sunrise" and maybe even 6:30, but not earlier.

    //TOBRUK 20:30 is close to sunset, long shadows but still flyable. 20:40 is getting pretty dark, still just OK. 20:45 is after sunset/dark.

    public static readonly DateTime MODERN_CAMPAIGN_START_DATE = new DateTime(2020, 8, 21); //3 variables dealing with translating the current modern date to a relevant historical date: #1. Date on the current calendar that will count as day 0 of the campaign

    //Tobruk was 241 days, 31 Mar 1941-27 Nov 1941 per https://www.bbc.co.uk/history/ww2peopleswar/timeline/factfiles/nonflash/a1124777.shtml
    public static readonly DateTime HISTORIC_CAMPAIGN_START_DATE = new DateTime(1941, 3, 31); //#2. Date on the historic/1940s calendar that will register as day 0 of the campaign.
    public static int HISTORIC_CAMPAIGN_LENGTH_DAYS = 241; //#3. After this many days the historical dates will "roll over" and start again with HISTORIC_MISSION_START_DATE.

    public bool END_MISSION_IF_PLAYERS_INACTIVE = false;
    public bool COOP_START_MODE_ENABLED = false;
    public bool COOP_START_MODE = false;
    public double COOP_MODE_TIME_SEC = 45;
    public int START_COOP_TICK = -1;
    public double COOP_TIME_LEFT_MIN = 9999;
    public int ticksperminute = 1986;

    //TOBRUK this moves by 10s, so map state 0 is starting, -10 is one move towards blue, +10 is one move towards Red etc
    public double CampaignMapState = 0; //Determines which base map to load in & where the front is.  0 is the neutral map, - numbers tend more towards Blue, + numbers more towards Red
    public string CampaignMapSuffix = "-0"; //The initial initairports files will have suffix -0
    public string MapPrevWinner = ""; //Winner of the previous mission, if there was one
    public int CampaignMapMaxRedSuffixMax = 1; //This implies you have initairports files named with suffix ie -R001, -R002, -R003, -R004 through the max
    public int CampaignMapMaxBlueSuffixMax = 1; //This implies you have initairports files named ie -B001, -B002, -B003, -B004 through the max

    Stopwatch stopwatch;    
    ConcurrentDictionary<string, Tuple<long, SortedDictionary<string, string>>> radar_messages_store;
    public ConcurrentDictionary<AiAirGroup, SortedDictionary<string, IAiAirGroupRadarInfo>> ai_radar_info_store { get; set; }

    //full admin - must be exact character match (CASE SENSITIVE) to the name in admins_full
    //basic admin - player's name must INCLUDE the exact (CASE SENSITIVE) stub listed in admins_basic somewhere--beginning, end, middle, doesn't matter
    //used in method admins_privilege_level below
    public string[] admins_basic = new String[] { "TWC_" };
    public string[] admins_full = new String[] { "TWC_Flug", "EvilUg", "TWC_Fatal_Error", "Server" };
    public int[][,] GiantSectorOverview = new int[3][,];  //holds a simple count of how many enemy airgroups (index 0) & aircraft (index 1) in each giant sector (giant keypad covering entire map)
    public bool ON_TESTSERVER = false;


    public long Tick_Mission_Time { get; set; }// Sets the Mission Clock for Time Remaining in Mission.
    int allowedSpitIIas = 4;
    int currentSpitIIas = 0;
    int allowed109s = 4;
    int current109s = 0;
    double redMultAdmin = 0;
    double blueMultAdmin = 0;

    public int numBlueAircraft = 0;
    public int numRedAircraft = 0;
    public int numTotalAircraft = 0;

    public TWCTobrukCampaignMissionObjectives twc_tobruk_campaign_mission_objectives;


    //MissionObjectives mission_objectives;
    public MissionObjectives mission_objectives = null;

    //private RearmRefuelManager ManageRnr = new RearmRefuelManager();

    //Constructor
    public Mission()
    {
        try {
            //Console.WriteLine("#1");
            //INITIALIZE OTHER MAJOR MISSION OBJECTS             
            //if (TWCComms.Communicator.Instance.Stats != null && TWCStatsMission == null) TWCStatsMission = TWCComms.Communicator.Instance.Stats; 
            TWCComms.Communicator.Instance.Main = (IMainMission)this; //allows -stats.cs to access this instance of Mission
            TWCComms.Communicator.Instance.WARP_CHECK = false;

            covermission = new CoverMission(this); //must do this PLUS something like gpBattle.creatingMissionScript(covermission, missionNumber + 1); in inited
            
            statsmission = new StatsMission(this);
            airadarmission = new AIRadarMission();
            //gvcmission = new GCV.GCVMission();

            //Method defined in IMainMission interface in TWCCommunicator.dll are now access to other submissions
            //Also in other submission .cs like -stats.cs you can access the AMission methods of TWCMainMission by eg (TWCMainMission as AMission).OnBattleStopped();

            //TWCComms.Communicator.Instance.Ini = (AIniFile)Ini.IniFile; //allows -stats.cs etc to access this instance of IniFile
            //Console.Write("TYPEOF: " + typeof(string).Assembly.TWCStats);
            //TWCStats.interop statsMis = new TWCStats.interop();


            //Will be updated with value from -stats.ini OnMissionLoaded

            //DifficultySetting ds = GamePlay.gpDifficultyGet();
            //ds.No_Outside_Views = false;
            //ds.set(ds);
            //Console.WriteLine("Diff setting/outside views " + ds.No_Outside_Views.ToString());
            //GameWorld.DifficultySetting.No_Outside_Views = false;
            //outPath = "C:\\GoogleDrive\\GCVData";

            radarpasswords = new Dictionary<int, string>
            {
                { -1, "north"}, //Red army #1
                { -2, "gate"}, //Blue, army #2
                { -3, "twc2twc"}, //admin
                { -4, "twc2twc"}, //admingrouped
                              //note that passwords are CASEINSENSITIVE
             };

            MISSION_ID = @"Tobruk_Campaign";
            random = new Random();
            stb_random = random;
            //constants = new Constants();
            SERVER_ID = "Tobruk Campaign Server"; //Used by General Situation Map app
            SERVER_ID_SHORT = "Tobruk"; //Used by General Situation Map app for transfer filenames.  Should be the same for any files that run on the same server, but different for different servers       
            CAMPAIGN_ID = "Tobruk"; //Used to name the filename that saves state for this campaign that determines which map the campaign will use, ie -R001, -B003 etc.  So any missions that are part of the same overall campaign should use the same CAMPAIGN_ID while any missions that happen to run on the same server but are part of a different campaign should have a different CAMPAIGN_ID
            if (Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments).ToLower().Contains("brent"))
            {
                SERVER_ID_SHORT = "TobrukTEST"; //FOR TESTING, using a different radar. Used by General Situation Map app for transfer filenames.  Should be the same for any files that run on the same server, but different for different servers
                ON_TESTSERVER = true;
            }
            if (Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments).ToLower().Contains("twc_server2"))
            {
                SERVER_ID_SHORT = "TobrukMission"; //FOR PRACTICE/TESTING SERVER, using a different radar. Used by General Situation Map app for transfer filenames.  Should be the same for any files that run on the same server, but different for different servers
                ON_TESTSERVER = false;
                radarpasswords = new Dictionary<int, string>
                {
                    { -1, "twc"}, //Red army #1
                    { -2, "twc"}, //Blue, army #2
                    { -3, "twc2twc"}, //admin
                    { -4, "twc2twc"}, //admingrouped
                                  //note that passwords are CASEINSENSITIVE
                 };
            }

            DEBUG = false;
            DISABLE_TESTING_MODS = false; // if set to true, some things that run or are skipped on the testing server will run exactly as on the real server
            LOG = false;
            //WARP_CHECK = false;

            //SET MAIN PATH & FILENAMES (must be done after setting MISSION_ID etc because those are used for various paths & filenames)   
            USER_DOC_PATH = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);   // DO NOT CHANGE
            CLOD_PATH = USER_DOC_PATH + @"/1C SoftClub/il-2 sturmovik cliffs of dover/";  // DO NOT CHANGE
            FILE_PATH = @"missions/Multi/Fatal/" + MISSION_ID + "/Fresh input file";   // mission install directory (CHANGE AS NEEDED); where we save things relevant to THIS SPECIFIC MISSION
            stb_FullPath = CLOD_PATH + FILE_PATH;
            MESSAGE_FILE_NAME = MISSION_ID + @"_message_log.txt";
            MESSAGE_FULL_PATH = CLOD_PATH + FILE_PATH + @"/" + MESSAGE_FILE_NAME;
            STATS_FILE_NAME = MISSION_ID + @"_stats_log.txt";
            STATS_FULL_PATH = CLOD_PATH + FILE_PATH + @"/" + STATS_FILE_NAME;
            LOG_FILE_NAME = MISSION_ID + @"_log_log.txt";
            LOG_FULL_PATH = CLOD_PATH + FILE_PATH + @"/" + LOG_FILE_NAME;
            STATSCS_FULL_PATH = USER_DOC_PATH + @"/1C SoftClub/il-2 sturmovik cliffs of dover/missions/Multi/Fatal/";  // Where we save things RELEVANT TO THE ENTIRE CAMPAIGN AS A WHOLE 
                                                                                                                       //(Note that a campaign may have several missions, each in their own FILE_PATH folder; this is the main folder that holds stats files, team stats, player registration lists, etc that are all relevant to the Campaign as a whole
                                                                                                                      // Must match location -stats.cs is saving SessStats.txt to  


            stopwatch = Stopwatch.StartNew();
            RADAR_REALISM = (int)5;
            RESULTS_OUT_FILE = CLOD_PATH + FILE_PATH + @"/" + "MissionResult.txt";
            radar_messages_store = new ConcurrentDictionary<string, Tuple<long, SortedDictionary<string, string>>>() { };
            ai_radar_info_store = new ConcurrentDictionary<AiAirGroup, SortedDictionary<string, IAiAirGroupRadarInfo>>(){};
            MissionObjectivesList = new Dictionary<string, MissionObjective>();
            //SMissionObjectivesList = MissionObjectivesList as IMissionObjecit;

            //initialize giant sector overview, which gives a quick total of airgroups (ind=0) and aircraft (ind=1) for the entire map.
            //Which x,y position is which sector # is defined by a routein in Calcs.  It makes the 36000x36000 map grid into 3x3 with 0 and 10 acting as negative/positive overflows
            //If a player is off map this can be a problem
            GiantSectorOverview[0] = new int[10, 2]; //army = 0 is ie admins
            GiantSectorOverview[1] = new int[10, 2];
            GiantSectorOverview[2] = new int[10, 2];

            supplymission = new SupplyMission(this); //do this towards the end because  it needs all the STATS_FULL_PATH and other similar variables.
            landinggroundmission = new LandingGroundMission(this);
            //skincheckmission = new SkinCheckMission(this); //must do this PLUS something like gpBattle.creatingMissionScript(covermission, missionNumber + 1); in inited







        }
        catch (Exception ex) { Console.WriteLine("ERROR #!: " + ex.ToString()); }



    }


    public Dictionary<string, IMissionObjective> SMissionObjectivesList()
    {
        var ret = new Dictionary<string, IMissionObjective>();
        foreach (string key in MissionObjectivesList.Keys)
        {
            ret[key] = MissionObjectivesList[key] as IMissionObjective;
        }
        return ret;
    }

    /********************************************************
     * 
     * Save campaign state every 3 minutes or so, so that if
     * something messes up before end of mission, we
     * don't lose all the campaign developments this mission
     * 
     *******************************************************/
    private bool SaveCampaignStateIntermediate_firstRun = true;
    public void SaveCampaignStateIntermediate()
    {

        Timeout(182.78, () => { SaveCampaignStateIntermediate(); }); //every 3 minutes or so, save
        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MOSXX2 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        if (!MISSION_STARTED) return;
        if (SaveCampaignStateIntermediate_firstRun)
        {
            //StartupSave doesn't try to calculate supply adjustments etc        
            Task.Run(() => SaveMapState("", intermediateSave: true));
            //SaveMapState("", intermediateSave: true);
            //Task.Run(() => MO_WriteMissionObjects()); //no need to run this so early, there is nothing to save yet anyway
            SaveCampaignStateIntermediate_firstRun = false;
        } else
        {
            Task.Run(() => SaveMapState("", intermediateSave: true));
            Task.Run(() => MO_WriteMissionObjects());
        }

        //SaveMapState("", true);
    }

    public void CheckCoop()
    {
        /************************************************
         * 
         * Check to see if COOP mode is still on & if so,
         * make sure that no aircraft or ie tanks have moved 
         * too far, or have taken off OR are going too fast
         * 
         * If so they will just be destroyed
         * 
         * Recursive function called every X seconds
         ************************************************/
        if (!COOP_START_MODE) return;

        Timeout(5, () => { CheckCoop(); });

        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            foreach (Player p in GamePlay.gpRemotePlayers())
            {

                if (p.Place() != null)
                {
                    AiActor act = p.Place();

                    //remove players from aircraft/destroy it, if the aircraft has taken off
                    AiAircraft air = p.Place() as AiAircraft;
                    if (air != null && air.IsAirborne())
                    {
                        Stb_RemoveAllPlayersFromAircraftandDestroy(air, p, 0, 1.0);
                        twcLogServer(new Player[] { p }, "CO-OP START: You took off before Mission Start Time.", null);
                        twcLogServer(new Player[] { p }, "Your aircraft was destroyed.", null);
                    }

                    //If it is too far away from an airport, destroy (this takes care of tanks etc going rogue overland during the coop start period)
                    else if (Stb_distanceToNearestAirport(act) > 2500)
                    {
                        Stb_RemovePlayerFromCart(act as AiCart, p);
                        twcLogServer(new Player[] { p }, "CO-OP START: You left the airport or spawn point before Mission Start Time; " + Stb_distanceToNearestAirport(act).ToString("n0") + " meters to nearest airport or spawn point", null);
                        twcLogServer(new Player[] { p }, "You have been removed from your position.", null);
                    }
                }

            }
        }
    }

    bool EndMissionIfPlayersInactive_initialized = false;
    DateTime LastTimePlayerLoggedIn = DateTime.UtcNow;
    DateTime LastTimePlayerInPlace = DateTime.UtcNow;

    public void EndMissionIfPlayersInactive()
    {
        /************************************************
         * 
         *We check every minute or so to see if any players are logged on
         * and if so, if they are actually in a place.
         * 
         * If the mission is active &  no one has logged in for 7.5 minutes the mission will end.
         * 
         * If the mission is active &  no one been in a place (ie, in an aircraft, tank, etc0 for 15 minutes the mission will end
         * 
         * This is to prevent AI from marching forward & destroying all the mission targets, and thus moving the campaign maps around by huge amounts, when no one is even playing
         * 
         * Also it could potentially ward off some cheating type behaviors, if people realize that AI tends to score more points for one side or the other when no one is playing, then
         * they could  just start a mission & leave it, just to rack up points for their side.
         * 
         * Recursive function called every X seconds
         ************************************************/


        Timeout(63.25, () => { EndMissionIfPlayersInactive(); });

        if (!END_MISSION_IF_PLAYERS_INACTIVE) return;

        //Before the mission official starts, we still update the times as though players were in place - reason is, we could get in some weird situation where the mission
        //was paused because of one of these modes, put we somehow get a sample of the time, then wait 30 minutes, then someone jumps in to play & we restart, 
        //noticing there has a been a 30 minute delay & kill the game.  Which would not be good.  So, this is a bit belt & suspenders--really we dont' even start with this routine
        //until Mission is started & coop mode is over.
        if (!MISSION_STARTED || COOP_START_MODE)
        {
            LastTimePlayerLoggedIn = DateTime.UtcNow;
            LastTimePlayerInPlace = DateTime.UtcNow;
            //Console.WriteLine("Not miss started/coopstart");
            return;
        }
        if (!EndMissionIfPlayersInactive_initialized)
        {

            LastTimePlayerLoggedIn = DateTime.UtcNow;
            LastTimePlayerInPlace = DateTime.UtcNow;
            EndMissionIfPlayersInactive_initialized = true;
            //Console.WriteLine("EMIPI initialized");
            return;
        }


        if (GamePlay.gpPlayer() != null && GamePlay.gpPlayer().Place() != null)
        {
            LastTimePlayerLoggedIn = DateTime.UtcNow;
            LastTimePlayerInPlace = DateTime.UtcNow;
            //Console.WriteLine("EMIPI single player in place");
            return; //we only need one . .. 
        }

        //if (GamePlay.gpPlayer() != null || (GamePlay.gpRemotePlayers() != null && GamePlay.gpRemotePlayers().Length > 0))
        if ((GamePlay.gpRemotePlayers() != null && GamePlay.gpRemotePlayers().Length > 0)) //giving up on looking for the single player as GamePlay.gpPlayer() always seems to be != null
        {
            LastTimePlayerLoggedIn = DateTime.UtcNow;
            //Console.WriteLine("EMIPI a player is logged in " + (GamePlay.gpPlayer() != null).ToString() + " " + (GamePlay.gpRemotePlayers() != null).ToString() + " " + GamePlay.gpRemotePlayers().Length.ToString());


            if (GamePlay.gpRemotePlayers() != null && GamePlay.gpRemotePlayers().Length > 0)
            {
                foreach (Player p in GamePlay.gpRemotePlayers())
                {

                    if (p.Place() != null)
                    {
                        LastTimePlayerInPlace = DateTime.UtcNow;
                        //Console.WriteLine("EMIPI multi player in place");
                        return; //we only need one . .. 
                    }

                }
            }
        }

        //Console.WriteLine("EMIPI checking time since last player");
        //End the mission if it has been 7.5 minutes since someone logged in OR 15 minutes since they were actually in a place.
        //if (LastTimePlayerLoggedIn.AddMinutes(.5) < DateTime.UtcNow || LastTimePlayerInPlace.AddMinutes(15) < DateTime.UtcNow)  //testing
        if (LastTimePlayerLoggedIn.AddMinutes(7.5) < DateTime.UtcNow || LastTimePlayerInPlace.AddMinutes(15) < DateTime.UtcNow)
        {
            EndMission(0);
        }
    }

    /*****************************************************************************************
     * 
     * New Mission methods, TF 5.0!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     * 
     * ABattle has a new method AMission GetBaseMission()
     *
     * AMission has a new method object[] OnIntraMissionsMessage(string sMsg, object[] args = null), which allows missions to send arbitrary data to each other.          
     * 
     * **************/

    bool OnTick_End_Mission_Triggered = false;
    public override void OnTickGame()
    {
        base.OnTickGame();
        /* Tick_Mission_Time = 720000 - Time.tickCounter();
        var Mission_Time = Tick_Mission_Time / 2000;
        TimeSpan Convert_Ticks = TimeSpan.FromMinutes(Mission_Time);
        string Time_Remaining = string.Format("{0:D2}:{1:D2}:{2:D2}", Convert_Ticks.Hours, Convert_Ticks.Minutes, Convert_Ticks.Seconds);
        */
        //int tickSinceStarted = Time.tickCounter();        

        if (!MISSION_STARTED)
        {
            //if (Time.tickCounter() % 10600 == 0) {
            if (Time.tickCounter() % (2 * ticksperminute) == 0)
            {
                //DebugAndLog ("Debug: tickcounter: " + Time.tickCounter().ToString() + " tickoffset" + tickoffset.ToString());

                int timewaitingminutes = Convert.ToInt32(((double)Time.tickCounter() / (double)ticksperminute));
                DebugAndLog("Waiting for first player to join; waiting " + timewaitingminutes.ToString() + " minutes");
                if (timewaitingminutes > 60) EndMission(1); //If we wait too long before starting the mission we get darkness, other problems before it ends.  So just end it after waiting a while.

            }

            return;
        }

        if (START_COOP_TICK == -1) START_COOP_TICK = Time.tickCounter();

        if (COOP_START_MODE)
        {

            int tickSinceCoopStarted = Time.tickCounter() - START_COOP_TICK;

            if (tickSinceCoopStarted >= Convert.ToInt32((COOP_MODE_TIME_SEC * (double)ticksperminute) / 60.0))
            {
                COOP_START_MODE = false;

                Stb_Chat("CO-OP MISSION START NOW!", null);
                Stb_Chat("CO-OP START: Pilots, you may take off at will", null);

                GamePlay.gpHUDLogCenter("CO-OP MISSION START NOW!");
                Timeout(5, () => { GamePlay.gpHUDLogCenter("CO-OP MISSION START NOW!"); });
                Timeout(10, () => { GamePlay.gpHUDLogCenter("CO-OP MISSION START NOW!"); });

                return;
            }


            if (tickSinceCoopStarted % (ticksperminute / 4) == 0)
            {
                //DebugAndLog ("Debug: tickcounter: " + Time.tickCounter().ToString() + " tickoffset" + tickoffset.ToString());
                COOP_TIME_LEFT_MIN = (COOP_MODE_TIME_SEC / 60 - ((double)tickSinceCoopStarted / (double)ticksperminute));
                double timeleftseconds = (COOP_MODE_TIME_SEC - ((double)tickSinceCoopStarted) * 60.0 / (double)ticksperminute);
                string s = COOP_TIME_LEFT_MIN.ToString("n2") + " MINUTES";
                if (timeleftseconds < 120) s = timeleftseconds.ToString("n0") + " SECONDS";

                //let players who can control <coop know about the command, 1X per minute
                if (tickSinceCoopStarted % ticksperminute == 0)
                {
                    Timeout(7.5, () =>
                    {
                        foreach (Player p in GamePlay.gpRemotePlayers())
                        {
                            if (admin_privilege_level(p) >= 1) //about once a minute, a message to players who can issue coop commands
                            {
                                twcLogServer(new Player[] { p }, "CO-OP MODE CONTROL: Use chat command <coop to start immediately OR extend time", null);
                            }
                        }
                    });
                }

                //gpLogServerAndLog(null, "COOP START: You can spawn in and taxi but DO NOT TAKE OFF for " + s, null);

                Stb_Chat("CO-OP MISSION START IN " + s, null);
                Stb_Chat("CO-OP START: You can spawn on the ground and taxi near your spawn point but", null);
                Stb_Chat("DO NOT TAKE OFF OR AIR SPAWN until CO-OP mission start time", null);
                //Stb_Chat("CO-OP time: " + ( COOP_MODE_TIME_SEC / 60).ToString("n2"), null);


                string s2 = COOP_TIME_LEFT_MIN.ToString("n2") + " more minutes";
                if (timeleftseconds < 120) s = timeleftseconds.ToString("n0") + " more seconds";


                GamePlay.gpHUDLogCenter("CO-OP START: DO NOT TAKE OFF for " + s2);
                Timeout(5, () => { GamePlay.gpHUDLogCenter("CO-OP START: DO NOT TAKE OFF for " + s2); });
                Timeout(10, () => { GamePlay.gpHUDLogCenter("CO-OP START: DO NOT TAKE OFF for " + s2); });



            }


            return;
        }



        if (START_MISSION_TICK == -1)
        {
            START_MISSION_TICK = Time.tickCounter();
            START_MISSION_TIME_HRS = GamePlay.gpTimeofDay();
        }

        int tickSinceStarted = Time.tickCounter() - START_MISSION_TICK;

        //int respawntick = respawnminutes * ticksperminute; // How often to re-spawn new sub-missions & do other repetitive tasks/messages. 27000=15 min repeat. 1800 'ticks' per minute or  108000 per hour.  I believe that this is approximate, not exact.


        //periodically remove a/c that have gone off the map
        if ((tickSinceStarted) % 2100 == 0 && tickSinceStarted > 0)
        {

            Task.Run(() => RemoveOffMapAIAircraft());

        }


        if ((tickSinceStarted) % 10100 == 0)
        {
            //Write all a/c position to log
            if (LOG)
            {
                DebugAndLog(calcTimeLeft() + " left in mission " + MISSION_ID);
                //int saveRealism = RADAR_REALISM; //save the accurate radar contact lists
                //RADAR_REALISM = 0;

                //Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), 1, true, radar_realism: 0));
                //Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), 1, false, radar_realism: 0));
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, true, radar_realism: 0);
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, false, radar_realism: 0);
                //RADAR_REALISM = saveRealism;
            }

        }

        if ((tickSinceStarted) == 0)
        {
            twcLogServer(null, "Mission loaded.", new object[] { });

            //WriteResults_Out_File("3"); //1=red, 2= blue, 3=tie; we pre-set to tie in case the mission exits early etc.
            Task.Run(() => WriteResults_Out_File("3"));
            Timeout(188, () => { Task.Run(() => CheckStatsData()); }); //  Start the routine to transfer over stats, a/c killed, etc; Delay a while so sessStats.txt etc are already in place            
            //Timeout(188, () => { CheckStatsData(); }); //  Start the routine to transfer over stats, a/c killed, etc; Delay a while so sessStats.txt etc are already in place            
            Timeout(105, () => { groupAllAircraft_recurs(); });
            Timeout(115, () => { aiAirGroupRadarReturns_recurs(); });
            Timeout(201.3, () => { Task.Run(() => MO_ObjectiveUndestroy_recurs()); });

        }

        if (tickSinceStarted % 30000 == 1000)
        //if (tickSinceStarted % 1100 == 1000)  //for testing
        {

            twcLogServer(null, "Completed Red Objectives (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):", new object[] { });
            twcLogServer(null, MissionObjectivesCompletedString[ArmiesE.Red], new object[] { });
            Timeout(10, () =>
            twcLogServer(null, "Completed Blue Objectives (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):", new object[] { }));
            Timeout(11, () =>
            twcLogServer(null, MissionObjectivesCompletedString[ArmiesE.Blue], new object[] { }));
            Timeout(12, () =>
            twcLogServer(null, showTimeLeft().Item1, new object[] { }));

            //Console.WriteLine("Leaks: " + MO_IntelligenceLeakNearMissionEnd[ArmiesE.Blue] + " " + MO_IntelligenceLeakNearMissionEnd[ArmiesE.Red]);

            Timeout(stb_random.Next(56, 623), () =>
            //Timeout(stb_random.Next(5, 6), () => //for testing
            {
                if (MO_IntelligenceLeakNearMissionEnd[ArmiesE.Blue] != "") sendChatMessageTo((int)ArmiesE.Blue, MO_IntelligenceLeakNearMissionEnd[ArmiesE.Blue], null);
                if (MO_IntelligenceLeakNearMissionEnd[ArmiesE.Red] != "") sendChatMessageTo((int)ArmiesE.Red, MO_IntelligenceLeakNearMissionEnd[ArmiesE.Red], null);

            });

            //stopAI();//for testing
        }

        //So, this could be done every minute or whatever, instead of every tick . . . _recurs
        if ((GamePlay.gpTimeofDay() - START_MISSION_TIME_HRS >= MISSION_LENGTH_HRS || GamePlay.gpTimeofDay() >= END_MISSION_TIME_HRS) && !OnTick_End_Mission_Triggered)//End mission at EITHER: End_mission_tick OR if End_misison_time_hours is in the past.
                                                                                                                                      //if (Time.tickCounter() == 720)// Red battle Success.  //For testing/very short mission
        {

            Console.WriteLine("EndMissTick/Time: {0} {1} {2} {3} {4} ", tickSinceStarted, MISSION_LENGTH_HRS, GamePlay.gpTimeofDay(), END_MISSION_TIME_HRS, START_MISSION_TICK);
            //WriteResults_Out_File("3");
            Task.Run(() => WriteResults_Out_File("3"));
            /*
            Timeout(10, () =>
            {
                twcLogServer(null, "The match ends in a tie!  Objectives still left for both sides!!!", new object[] { });
                GamePlay.gpHUDLogCenter("The match ends in a tie! Objectives still left for both sides!!!");
            });
            */
            EndMission(70, "");
            OnTick_End_Mission_Triggered = true; //This can only be triggered once, for various reasons.  So stop it from triggering repeatedly.
        }

        if (Time.tickCounter() > 5000) //don't do radar returns for first couple of minutes of the mission, because things aren't initialized & so errors ensue
        {

            //Ticks below write out TOPHAT radar files for red, blue, & admin
            //We do each every ~minute but space them out a bit from each other
            //roughly every one minute
            //TOBRUK: Half as often (every 2000 ticks instead of 1000)
            //do this regardless of whether players are loaded, so it must be first here
            //NOTE if you launch these too early on, like tick 0, it will produce errors every time because certain things are not set up.  Delay them 1 minute or so for best results
            if ((Time.tickCounter()) % 2000 == 1000 || ( (Time.tickCounter()) % 2000 == 0 && MO_BRBumrushActive() )) //double radar speed during bumrush phase, only for army 1,2 (not admin)
            {
                ///////////////////////////////////////////    
                //int saveRealism = RADAR_REALISM; //save the accurate radar contact lists
                //Console.WriteLine("Writing current radar returns to file");

                //Timeout(188, () => { var t = Task.Run(() => CheckStatsData()); });
                //RADAR_REALISM = -1;
                //listPositionAllAircraft(GamePlay.gpPlayer(), -1, false, radar_realism: -1); //-1 & false will list ALL aircraft of either army        
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, false);
                if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX4  " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
                Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), -1, false, radar_realism: -1));
                //listPositionAllAircraft(GamePlay.gpPlayer(), -1, false, radar_realism: -1);
                //RADAR_REALISM = saveRealism;

            }
            if ((Time.tickCounter()) % 2000 == 1334 || ((Time.tickCounter()) % 2000 == 334 && MO_BRBumrushActive())) //double radar speed during bumrush phase, only for army 1,2 (not admin)
            {
                ///////////////////////////////////////////    
                //int saveRealism = RADAR_REALISM; //save the accurate radar contact lists
                //Console.WriteLine("Writing current radar returns to file");
                //RADAR_REALISM = -1;
                //listPositionAllAircraft(GamePlay.gpPlayer(), -2, false, radar_realism: -1); //-1 & false will list ALL aircraft of either army
                if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX3 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
                Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), -2, false, radar_realism: -1));
                //listPositionAllAircraft(GamePlay.gpPlayer(), -2, false, radar_realism: -1);
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, false);
                //RADAR_REALISM = saveRealism;

            }
            if ((Time.tickCounter()) % 1000 == 666)
            {
                ///////////////////////////////////////////    
                int saveRealism = RADAR_REALISM; //save the accurate radar contact lists
                                                 //Console.WriteLine("Writing current radar returns to file");
                                                 //RADAR_REALISM = -1;
                                                 //listPositionAllAircraft(GamePlay.gpPlayer(), -3, false, radar_realism: -1); //-1 & false will list ALL aircraft of either army
                if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX2 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
                Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), -3, false, radar_realism: -1));
                //listPositionAllAircraft(GamePlay.gpPlayer(), -3, false, radar_realism: -1);
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, false);
                //RADAR_REALISM = saveRealism;

            }
            if ((Time.tickCounter()) % 1000 == 813)
            {
                ///////////////////////////////////////////    
                int saveRealism = RADAR_REALISM; //save the accurate radar contact lists BUT GROUPED
                                                 //Console.WriteLine("Writing current radar returns to file");
                                                 //RADAR_REALISM = -1;
                                                 //listPositionAllAircraft(GamePlay.gpPlayer(), -3, false, radar_realism: -1); //-1 & false will list ALL aircraft of either army
                if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX1 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
                Task.Run(() => listPositionAllAircraft(GamePlay.gpPlayer(), -4, false, radar_realism: -1));
                //listPositionAllAircraft(GamePlay.gpPlayer(), -4, false, radar_realism: -1);
                //listPositionAllAircraft(GamePlay.gpPlayer(), 1, false);
                //RADAR_REALISM = saveRealism;

            }




        }
    }

    /************************************************************
    * 
    * handle airport bombing
    * most credit/script idea for airport bombing & destruction goes to reddog/Storm of War
    * 
    * We give credit (points) for any bomb that hits within the radius of an airfield.
    * Also, these bomb hits are marked with a plume of smoke and additionally a bomb crater is added that is dangerous/will kill aircraft taxiing on the ground
    *  
    * Craters are different sizes, depending on tonnage of bomb dropped.  Also, craters will be repaired, taking a shorter time for smaller craters & a longer time for bigger craters
    * Additionally, the more craters dropped on an airport the longer it will take to get to the next crater  & repair it.
    * Also, if a threshold of tonnage (counted as points, which are proportional to damage done) is reached, the airport is put out of commission by severely cratering it
    * 
    * //Version for -MAIN.cs//
    *************************************************************/

    //IN THE PAST AirfieldTargets was the way we tracked airport condition and damage.  Now that is done via MissionObjectives and the AirfieldTargets Dictionary is more of a handy way to keep a list of airports in-game.  If we wanted to have our list of airports different from the CloD list for any reason, we could use AirfieldTargets for that purpose.
    //2020-02-25

    public Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>> AirfieldTargets = new Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>>();
    //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, if it s knocked out, double   airfield radius, Point3d airfield center (position)
    //TODO: it would nice to have a struct or something to hold this instead of a tuple . . . 

    public void SetAirfieldTargets()
    {
        foreach (AiAirport ap in GamePlay.gpAirports()) //Loop through all airfields in the game
        {

            //We're just going to add ALL airfields as targets, but then make sure there are no duplicates (bec. built-in & .mis-added airports sometimes overlap).

            //It's going to take blue pilots more points/bombs to knock out an airfield, vs Red (Blenheims very limited as far as the # of bombs they can carry)

            ////Use this for TACTICAL SERVER (where Reds only have Blenheims)
            //UPDATE 2017/11/06: We don't need this adjustment bec. we have adjusted the points received
            //so that blenheims receive relatively more & the blue bombers relatively less.  So this 
            //should handle the discrepancy between the sides with no further adjustment necessary
            //int pointstoknockout = 30;
            //if (ap.Army() != null && ap.Army() == 1) pointstoknockout = 65;

            ////Use this for MISSION SERVER (where Reds have access to HE111 and JU88)
            ////Use this for MISSION SERVER  && TACTICAL SERVER 
            int pointstoknockout = 180;  //This is about two HE111 or JU88 loads (or 1 full load & just a little more) and about 4 Blennie loads, but it depends on how accurate the bombs are, and how large //2020-02 - this was 30 points, but with the new cover bomber system 60 points seems more reasonable.  Maybe needs to be even higher?.  //2020-02, OK so in -stats.cs it was 65 and here 30.  Thus . . . the discrepancy in airport scores. So now they are both 90 as it still seemed quite too easy.
            //UPDATE 2020/02 - now setting pointstoknockout via MO_MissionObjectiveAirfieldsSetup
            //this is still set but DOES NOTHING.  hopefully.


            double radius = ap.FieldR();
            Point3d center = ap.Pos();


            //GamePlay.gpAirports() includes both built-in airports and any new airports we have added in our .mis files. This results in duplication since
            //most .mis airports are placed on top of an existing built-in airport. We check whether this airport has already been added & skip adding it if so.
            Point3d pos = ap.Pos();
            bool add = true;
            foreach (AiAirport apk in AirfieldTargets.Keys)//Loop through the targets
            {
                if (apk != null & apk.Pos().distance(ref pos) <= apk.FieldR())
                {
                    //AirfieldTargets[apk].Item3
                    add = false; //
                    if (apk.FieldR() != null && apk.FieldR() > 1) radius = apk.FieldR(); //The field radius set in the .mis file becomes operative if it exists & is reasonable
                    center = apk.Pos();  //We use the position of the airport set i nthe .mis file for the center, if it exists - thus we can change/move the center position as we wish
                    break;
                }
            }

            //We'll get the NAME of the airport from the birthplace/spawn point declare in a .mis file, if it exists

            string apName = ap.Name();
            foreach (AiBirthPlace bp in GamePlay.gpBirthPlaces())
            {
                if (bp != null & bp.Pos().distance(ref pos) <= ap.FieldR())
                {
                    if (bp.Name() != null && !(bp.Name().ToUpper().Contains("BIRTHPLACE")))
                    {
                        //Console.WriteLine("SetAirfields: Using Birthplace name for {1} (was {0})", apName, bp.Name());
                        apName = bp.Name();  //We will use the spawn point/birthplace name UNLESS it is just "BirthPlace0" or whatever
                        

                    }
                    break;
                }
            }


            if (add) AirfieldTargets.Add(ap, new Tuple<bool, string, double, double, DateTime, double, Point3d>(false, apName, pointstoknockout, 0, DateTime.UtcNow, radius, center)); //Adds airfield to dictionary, requires approx 2 loads of 32 X 50lb bombs of bombs to knock out.
                                                                                                                                                                                       //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, double airfield radius
                                                                                                                                                                                       //if you want to add only some airfields as targets, use something like: if (ap.Name().Contains("Manston")) { }

        }
        //twcLogServer(null, "SetAirfieldTargets initialized.", null);
        Console.WriteLine("SetAirfieldTargets initialized (-main)", null);
    }

    //all = true lists all airports, damaged or not
    //display = whether or not to display in chat screen or just return the string
    //condensed leaves out "closed" and "last damaged time" to make the chat screen less cluttered
    public string ListAirfieldTargetDamage(Player player = null, int army = -1, bool all = false, bool display = true, bool condensed = true)
    {
        //Console.WriteLine("LATD starting");
        int count = 0;
        string returnmsg = "";
        double delay = 0.1;
        /*
        if (AirfieldTargets != null) foreach (AiAirport ap in AirfieldTargets.Keys)
            {

                double PointsTaken = AirfieldTargets[ap].Item4;
                bool disabled = AirfieldTargets[ap].Item1;

                if (!all && PointsTaken == 0 && !disabled) continue; //we'll list only airports damaged or disabled, skipping those with no damage at all, unless called with all=true
                if (army != -1 & army != ap.Army()) continue; //List only the army requested, skipping the others.  army = -1 means list both/all armies

                count++;
                double PointsToKnockOut = AirfieldTargets[ap].Item3;
                string Mission = AirfieldTargets[ap].Item2;
                DateTime lastBombHit = AirfieldTargets[ap].Item5;
                //DateTime disabledUntil_DT = AirfieldTargets[ap].Item6;

                double percent = 0;
                if (PointsToKnockOut > 0)
                {
                    percent = PointsTaken / PointsToKnockOut;
                }

                double timereduction = 0;
                if (percent > 0)
                {
                    timereduction = (DateTime.UtcNow.Subtract(lastBombHit)).TotalSeconds;
                }

                double timetofix = PointsTaken * 20 * 60 - timereduction; //50 lb bomb scores 0.5 so will take 10 minutes to repair.  Larger bombs will take longer; 250 lb about 1.4 points so 28 minutes to repeari
                                                                          //But . . . it is ADDITIVE. So the first 50 lb bomb takes 10 minutes, the 2nd another 10, the 3rd another 10, and so on on.  So if you drop 32 50 bl bombs it will take 320 minutes before the 32nd bomb crater is repaired.
                                                                          //Sources: "A crater from a 500lb bomb could be repaired and resurfaced in about 40 minutes" says one 2nd hand source. That seems about right, depending on methods & surface. https://www.airspacemag.com/multimedia/these-portable-runways-helped-win-war-pacific-180951234/
                                                                          //unfortunately we can repair only the bomb crater; the SMOKE will remain for the entire mission because clod internals don't allow its removal.
                                                                          //TODO: We could keep track of when the last bomb was dropped at each airport and deduct time here depending on how much repair had been done since the last bomb dropped

                string msg2 = "";
                if (PointsTaken >= PointsToKnockOut) //airport knocked out
                {
                    percent = 1;
                    //timetofix = 24 * 60 * 60; //24 hours to repair . . . if they achieve 100% knockout.  That is a little bonus beyond what the actual formula says, due ot total knockout
                    //timetofix = PointsTaken/PointsToKnockOut * 20.0 * 60.0; //Plus they achieve any additional knockout/repair time due to additional bombing beyond 100%, because those will have to be repaired, too.
                    //msg2 = "; estimated " + (Math.Round(timetofix/3600.0*2.0)/2.0).ToString("F1") + "hrs to re-open";
                    msg2 = " (" + (Math.Ceiling(timetofix / 3600.0 / 24 * 2.0) / 2.0).ToString("F1") + " days)";

                }

                //AirfieldTargets[ap].Item6 = DateTime.UtcNow.AddSeconds(timetofix); //just save that since we recalced it here; keep it consistent with what we are displaying.
                //forget this, instead we'll add it to the missionobjectiveslist



                string msg = Mission + " " + (percent * 100).ToString("n0") + "% destroyed; last hit " + (timereduction / 3600).ToString("n0") + "hr " + ((timereduction % 3600) / 60).ToString("n0") + "min ago" + msg2;
                returnmsg += msg + "\n";

                msg += " " + lastBombHit.ToString("yyyy-MM-dd-HHmmss") + " " + PointsTaken.ToString(); //for testing

                if (display)
                {
                    delay += 0.02;
                    Timeout(delay, () => { twcLogServer(new Player[] { player }, msg, new object[] { }); });
                }


            }
            */

        foreach (MissionObjective mo in MissionObjectivesList.Values)
        {

            //Console.WriteLine("LATD: " + mo.ID);
            if (mo.MOObjectiveType != MO_ObjectiveType.Airfield) continue; //We could include airfield complex & other such things at some future time???!?
            //Console.WriteLine("LATD2: " + mo.ID);
            double PointsTaken = mo.AirfieldDamagePoints;
            bool disabled = mo.Destroyed;

            if (!all && PointsTaken == 0 && !disabled) continue; //we'll list only airports damaged or disabled, skipping those with no damage at all, unless called with all=true
            //Console.WriteLine("LATD: {0} {1} " + mo.ID, PointsTaken, disabled);
            if (army != -1 & army != mo.OwnerArmy) continue; //List only the army requested, skipping the others.  army = -1 means list both/all armies
            //Console.WriteLine("LATD: {0} {1} " + mo.ID, army, mo.OwnerArmy);

            count++;
            double PointsToKnockOut = mo.AirfieldPointsRequired;

            TimeSpan lastbombhit_ts = new TimeSpan(0);
            if (mo.LastHitTime_UTC.HasValue) lastbombhit_ts = DateTime.UtcNow - mo.LastHitTime_UTC.Value;
            //DateTime disabledUntil_DT = AirfieldTargets[ap].Item6;

            double percent = 0;
            if (PointsToKnockOut > 0)
            {
                percent = PointsTaken / PointsToKnockOut;
            }
            DateTime timetofix_dt = DateTime.UtcNow;
            TimeSpan timetofix_ts = new TimeSpan(0);
            if (mo.TimeToUndestroy_UTC.HasValue) timetofix_ts = mo.TimeToUndestroy_UTC.Value - DateTime.UtcNow;

            string msg2 = "";

            if (timetofix_ts.TotalSeconds >= 0) msg2 = " (" + (Math.Ceiling(timetofix_ts.TotalDays * 4.0) / 4.0).ToString("F1") + " days)"; //don't display NEGATIVE time to fix days; it's been fixed.

            
            
            if (PointsTaken >= PointsToKnockOut && !condensed) //airport knocked out
            {
                percent = 1;
                //timetofix = 24 * 60 * 60; //24 hours to repair . . . if they achieve 100% knockout.  That is a little bonus beyond what the actual formula says, due ot total knockout
                //timetofix = PointsTaken/PointsToKnockOut * 20.0 * 60.0; //Plus they achieve any additional knockout/repair time due to additional bombing beyond 100%, because those will have to be repaired, too.
                //msg2 = "; estimated " + (Math.Round(timetofix/3600.0*2.0)/2.0).ToString("F1") + "hrs to re-open";
                msg2 = " (closed; " + (Math.Ceiling(timetofix_ts.TotalDays * 2.0) / 2.0).ToString("F1") + " days)";

            }

            //AirfieldTargets[ap].Item6 = DateTime.UtcNow.AddSeconds(timetofix); //just save that since we recalced it here; keep it consistent with what we are displaying.
            //forget this, instead we'll add it to the missionobjectiveslist



            string msg = mo.Name + " " + (percent * 100).ToString("n0") + "%";
            if (percent > 0 && !condensed) msg += "; last: " + lastbombhit_ts.ToString("h'hr'm'm'");
            if (percent > 0) msg += msg2;
            returnmsg += msg + "\n";

            //if (mo.LastHitTime_UTC.HasValue) msg += " " + mo.LastHitTime_UTC.Value.ToString("yyyy-MM-dd-HHmmss") + " " + PointsTaken.ToString(); //for testing //this doesn't work if 

            if (display)
            {
                delay += 0.08;
                Timeout(delay, () => { twcLogServer(new Player[] { player }, msg, new object[] { }); });
            }

        }
        if (count == 0)
        {
            string msg = "No airports damaged or destroyed yet";
            if (display) twcLogServer(new Player[] { player }, msg, new object[] { });
            returnmsg = ""; //In case of display == false we just don't return any message at all, allowing this bit to simply be omitted
        }

        return returnmsg;
    }

    //stamps a pattern of craters over an airfield to disable it, as though a few bomber formations had dropped on it
    public void AirfieldDisable(AiAirport ap, double percent = 1.0)

    {
        Task.Run(() =>
        {
            string apName = ap.Name();
            double radius = ap.FieldR();
            Point3d pos = ap.Pos();

            //Console.WriteLine("Disabling airport {0} {1:F0} {2:F0}", new Object[] {ap.Name(), ap.Pos().x, ap.Pos().y });

            if (AirfieldTargets.ContainsKey(ap))
            {
                apName = AirfieldTargets[ap].Item2;
                radius = AirfieldTargets[ap].Item6;
                pos = AirfieldTargets[ap].Item7;

            }

            if (percent >= 1)
            {
                //disable any associated birthplace - thus, no spawning here
                foreach (AiBirthPlace bp in GamePlay.gpBirthPlaces())
                {
                    Point3d bp_pos = bp.Pos();
                    Timeout(random.NextDouble() * 10, () =>
                     {
                         if (ap.Pos().distance(ref bp_pos) <= ap.FieldR()) bp.destroy();//Removes the spawnpoint associated with that airport (ie, if located within the field radius of the airport)
                    });
                }

                foreach (GroundStationary gg in GamePlay.gpGroundStationarys(pos.x, pos.y, radius)) //all stationaries w/i 10 or whatever meters of this object
                {
                    if (random.Next(3) < 1)
                    {
                        //Console.WriteLine("Airfield dest: Removing airfield item " + gg.Name);
                        Timeout(random.NextDouble() * 10, () =>
                        {
                            gg.Destroy();
                        });
                    }
                }
            }


            //GamePlay.gpHUDLogCenter(null, "Airfield " + apName + " has been disabled");

            ISectionFile f2 = GamePlay.gpCreateSectionFile();

            string sect = "Stationary";

            string val1 = "Stationary";
            string type = "BombCrater_firmSoil_largekg";
            int count = 0;
            string value = "";

            int rounds = Convert.ToInt32(Math.Ceiling(percent * 5));

            int stripesCount = 0;

            double craterSpacing_m = 41 + random.NextDouble() * 10;
            bool resetCount = true;
            int delay = 1;

            count = 1000; //Smoke starts at 0 so this gives room for those to be below 1000.

            for (int round = 0; round < rounds; round++)
            {

                double xpos = pos.x - 400 + 800 * stb_random.NextDouble();
                double ypos = pos.y - 400 + 800 * stb_random.NextDouble();
                double angle = random.NextDouble() * 2.0 * Math.PI;
                Point3d vec = new Point3d(Math.Cos(angle) * craterSpacing_m, Math.Sin(angle) * craterSpacing_m, 0);
                //Point3d vec90deg = new Point3d(-vec.y, vec.x, vec.z);

                int stripes = random.Next(4) + 1;
                for (int stripe = 0; stripe < stripes; stripe++)
                {
                    if (stripesCount > rounds) break; //we don't really need more than this many stripes altogether                

                    Point3d startPos = new Point3d(xpos + 150 - 300 * stb_random.NextDouble(), ypos + 150 - 300 * stb_random.NextDouble(), vec.z);
                    int craters = random.Next(10) + 12;



                    for (int crater = 0; crater < craters; crater++)
                    {
                        double randAdd = random.NextDouble() * 1.8 - 0.9;

                        //Console.WriteLine("Disabling airport {0:F0} {1:F0} {2:F0} {3:F0} {4:F0} {5:F0} {6:F0}", new Object[] { startPos.x.ToString("0.00"), startPos.y.ToString("0.00"), vec.x.ToString("0.00"), vec.y.ToString("0.00"), crater, randAdd, craterSpacing_m/10 });
                        Point3d craterPos = new Point3d(startPos.x + vec.x * (crater + randAdd), startPos.y + vec.y * (crater + randAdd) + random.NextDouble() * craterSpacing_m / 10, vec.z);
                        string key = "Static" + count.ToString();
                        value = val1 + ".Environment." + type + " nn " + craterPos.x.ToString("0.00") + " " + craterPos.y.ToString("0.00") + " " + stb_random.Next(0, 181).ToString("0.0") + " /height " + craterPos.z.ToString("0.00");
                        f2.add(sect, key, value);

                        //Console.WriteLine("Disabling airport {0:F0} {1:F0} {2} {3} {4}", new Object []  { craterPos.x.ToString("0.00"), craterPos.y.ToString("0.00"), round, stripe, crater });

                        if (random.Next(17) < 1)
                        {
                            string s = "BuildingFireSmall";
                            if (random.Next(35) == 0) s = "BuildingFireBig" ;
                            //if (random.Next(7)>3) s = "Smoke2";
                            f2 = Calcs.loadSmokeOrFire(GamePlay, this, craterPos.x, craterPos.y, craterPos.z, s, random.Next(5 * 3600) + 3600, f: f2, resetCount: resetCount);
                            resetCount = false;
                        }
                        count++;
                    }

                    stripesCount++;

                }
            }

            //Timeout(70 + random.Next(70, 150), () => GamePlay.gpPostMissionLoad(f2));
           Timeout(random.NextDouble() * 10 + 10, () =>
           {
               GamePlay.gpPostMissionLoad(f2);
           });

            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX7 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
            //f2.save(CLOD_PATH + FILE_PATH + "/sectionfiles/" + "airfielddisableMAIN-ISectionFile.txt"); //testing
        });

    }


    /*****************************************************************************
     * 
     * OnStationaryKilled - handling routines for when a stationary/static object is killed
     * 
     *****************************************************************************/

    public override void OnStationaryKilled(int missionNumber, maddox.game.world.GroundStationary stationary, maddox.game.world.AiDamageInitiator initiator, int eventArgInt)
    {
        #region stb
        base.OnStationaryKilled(missionNumber, stationary, initiator, eventArgInt);
        try
        {
            Console.WriteLine("Stationary");
            //Task.Run(() => //AHA  - task.running things has blown up the threads before

            double wait = stb_random.NextDouble() * 45;
            Timeout(wait, () =>
            {
                MO_HandlePointAreaObjectives(stationary, initiator);
                MO_makeAllObjectivesScoutedFromPos(stationary.pos, initiator.Player);
            }) ;
            //stb_KilledActors.Add(actor, damages); // save 
            //System.Console.WriteLine("Actor dead: Army " + actor.Army() );
            /* string msg = "Stationary " + stationary.Name + " " + stationary.country + " " + stationary.pos.x.ToString("F0") + " " + stationary.pos.y.ToString("F0") + " " + stationary.Title + " " + stationary.Type.ToString() + " " + "killed by ";

                Player player = null;
                if (initiator != null && initiator.Player != null) player = initiator.Player;
            */
        }
        catch (Exception ex) { Console.WriteLine("OnStationaryKilled -main: " + ex.ToString()); }
        #endregion
    }




    /*****************************************************************************
        * 
        * OnBombExplosion - handling routines for area bombing, bombing of civilian areas, and bombing of airports
        * 
        *****************************************************************************/

    //Do various things when a bomb is dropped/explodes.  For now we are assessing whether or not the bomb is dropped in a civilian area, and giving penalties if that happens.
    //TODO: X Give points/credit for bombs dropped on enemy airfields and/or possibly other targets of interest.
    //TODO: This is the sort of thing that could be pushed to the 2nd thread/multi-threaded
    public override void OnBombExplosion(string title, double mass_kg, Point3d pos, AiDamageInitiator initiator, int eventArgInt)
    {

        base.OnBombExplosion(title, mass_kg, pos, initiator, eventArgInt);

        //Task.Run(() => OnBombExplosion_DoWork(title, mass_kg, pos, initiator, eventArgInt)); //OK, don't do this as when many bombs explode it also explodes the CPU with way too many threads at once.

        //Spread them out a little over time
        //TODO: this could all be done in a worker thread (just not 1000 worker threads as we attempted above)
        //Console.WriteLine("Bomb");
        double wait = stb_random.NextDouble() * 45;
        Timeout(wait, () =>
            OnBombExplosion_DoWork(title, mass_kg, pos, initiator, eventArgInt)
        );
    }


    //TODO.  Bomb/exploded & airport bombing is unnecessarily complicated now we are meshing the OLD airport damage system & this new Mission Objectives system.
    //Airport destruction uses a complicated formula to figure out time to restore based on the last bomb hit time, time passed since then, what the level of destruction was at the point, how much repair would have happened since then, and then figures out what the current level of destruction is and how much time in the future it will take to repair that.
    //Soo . . . it works but has a lot of complicated steps to complete the calculation.   

    //So probably the way to solve it is:
    // - Just keep track of airport futuredate/time-to-undestroy.
    // - Every time a bomb drops, add the appropriate amount of time to this in proportion fo the size/type/number etc of bombs.  This part works well.
    // - Then as time progresses the time for full repair grows ever-nearer automatically because the future time-to-undestroy is set.
    // - Then you can figure out if it is DESTROYED by calculating the time left until undestroy and if it is above some value, then "destroyed" & spawn point removed.
    //  - You can also figure out the percent destroyed by looking at how long to repair vs how long this magic "100% destroyed" length of time is.  If that is 2 days then 1 day repair time needed is 50% destroyed.
    //  - You can restore the spawn point EITHER at the point destruction falls under 100%.  So it is open for operations but still has a bunch of craters etc any time destruction is less than 100%.  OR you can wait until it hits 0% to reopen.
    // Also we could probably just eliminate the airportslist thing and just use the MissionObjective class to hold airports, too--perhaps with one or two new fields such as ap.

    double lastBombMessageTime_sec = 0;

    public void OnBombExplosion_DoWork(string title, double mass_kg, Point3d pos, AiDamageInitiator initiator, int eventArgInt)
    {

        try
        {
            if (GamePlay == null) return;
            //Console.WriteLine("main_bombexp_DoWork");
            //twcLogServer(null, "bombe 1", null);
            //twcLogServer(null, string.Format("bombe {0:N0} {1:N0} {2:N0}", pos.x, pos.y, pos.z), null);
            bool ai = true;
            if (initiator != null && initiator.Player != null && initiator.Player.Name() != null) ai = false;

            //twcLogServer(null, "bombe 2", null);
            int isEnemy = 1; //0 friendly, 1 = enemy, 2 = neutral
            int terr = GamePlay.gpFrontArmy(pos.x, pos.y);

            //twcLogServer(null, "bombe 3", null);
            if (terr == 00) isEnemy = 2;
            if (!ai && initiator.Player.Army() == terr) isEnemy = 0;
            //twcLogServer(null, "bombe 4", null);
            
            MO_makeAllObjectivesScoutedFromPos(pos, initiator.Player);

            MO_HandlePointAreaObjectives(title, mass_kg, pos, initiator);

            //TF_GamePlay.gpIsLandTypeCity(maddox.game.IGamePlay, pos);       

            /********************
             * 
             * Handle airport bombing
             * 
             *******************/

            //twcLogServer(null, "bombe 5", null);

            var apkeys = new List<AiAirport>(AirfieldTargets.Keys.Count);
            apkeys = AirfieldTargets.Keys.ToList();

            maddox.game.LandTypes landType = GamePlay.gpLandType(pos.x, pos.y);

            //For now, all things we handle below are on land, so if the land type is water we just
            //get out of here immediately
            //if (landType == maddox.game.LandTypes.WATER) return;
            //TOBRUK!!!  Now some airports are on water

            //twcLogServer(null, "bombe 6", null);

            bool blenheim = false;
            string acType = "";
            if (initiator != null)
            {
                AiAircraft aircraft = initiator.Actor as AiAircraft;
                acType = Calcs.GetAircraftType(aircraft);

            }

            if (acType.Contains("Blenheim")) blenheim = true;

            //so these are all compared with a JU88 which carries 4X250kg + 28X50KG which is 2400kg or 5291 lb.
            //So these correction figures bring all these bombers up to par with the JU88 as far as kg-tonnage is concerned.
            //The JU88 will still be quite a lot more effective because it is actually dropping the 32 bombs & so hitting for more things over a wider area, more statationaries killed etc.
            //but this at least brings them to parity on the tonnage issue.  In real WWII British & German bombers were roughly on par.

            double aircraftCorrection = 1;

            if (acType.Contains("Blenheim") || acType.Contains("Hurricane")) aircraftCorrection = 4.4; //IV & IV late carry 4*250lb bombs plus 18x40lb bombs.  1200 poundds altogether
            if (acType.Equals("BlenheimMkI")) aircraftCorrection = 5.28;  //MkI carries just 4x250lb bombs, vs regular MkIV & IV_late care 1200lb bombs.  So 6/5* the regular Blenheim correction factor
            if (acType.Contains("Wellington")) aircraftCorrection = 2.6455; //Wellington carries 8X250lb bombs, so 2000lb altogether.            if (acType.Contains("He-111")) aircraftCorrection = 1.5;
            if (acType.Contains("BR-20")) aircraftCorrection = 2;

            DateTime currTime_dt = DateTime.UtcNow;
            double repairSpeedupFactor = 1;
            if (terr>0 && terr <3 && MissionObjectivesTimes[(ArmiesE)terr].ContainsKey("RepairCrewEndTime_dt") && MissionObjectivesTimes[(ArmiesE)terr]["RepairCrewEndTime_dt"] > currTime_dt) repairSpeedupFactor = 4;

            foreach (AiAirport ap in apkeys)//Loop through the targets; we do it on a separate copy of the keys list bec. we are changing AirfieldTargets mid-loop, below
            {
                /* if (!AirfieldTargets[ap].Item1)
                {//airfield has already been knocked out so do nothing
                }
                else
                { */

                //twcLogServer(null, "bombe 7", null);
                /*double radius = AirfieldTargets[ap].Item6;
                Point3d APPos = AirfieldTargets[ap].Item7;
                string apName = AirfieldTargets[ap].Item2;
                */
                string apName = AirfieldTargets[ap].Item2;

                string apKey = apName + "_spawn";

                MissionObjective mo = null;

                if (MissionObjectivesList.ContainsKey (apKey)) { mo = MissionObjectivesList[apKey]; }
                if (mo == null) continue;  //We could do something else here such as add the new ap to the list?  But it shouldn't happen.

                double radius = mo.radius;
                Point3d APPos = mo.Pos;

                double distFromCenter = 1000000000;
                if (ap != null) distFromCenter = APPos.distance(ref pos);
                //Check if bomb fell inside radius and if so increment up
                if (ap != null & distFromCenter <= radius)//has bomb landed inside airfield check
                {


                    //So, the Sadovsky formula is a way of estimating the effect of a blast wave from an explosion. https://www.metabunk.org/attachments/blast-effect-calculation-1-pdf.2578/
                    //Simplifying slightly, it turns out that the radius of at least partial destruction/partial collapse of buildings is:
                    // 50 lb - 30m; 100 lb - 40 m; 250 lb - 54 m; 500 lb - 67 m; 100 lb - 85 m; etc.
                    //Turning this radius to an 'area of destruction' (pi * r^2) gives us an "area of destruction factor" for that size bomb.  
                    //Since we are scoring the amount of destruction in e.g. an industrialized area, counting the destruction points as area (square footage, square meters, whatever) is reasonable.
                    //Scaling our points in proportion to this "area of destruction factor" so that a 50 lb pound bomb gives 0.5 points, then we see that destruction increases with size, but lower than linearly.
                    //So if a 50 lb bomb gives 0.5 points, a 100 lb bomb gives 0.72 points; 250 lb 1.41 points; 500 lb 2.33 points, 1000 lb 4.0 points, 2000 lb 6.48 points, etc
                    //The formula below is somewhat simplified from this but approximates it pretty closely and gives a reasonable value for any mass_kg
                    //This score is also closely related to the amount of ground churn the explosive will do, which is going to be our main effect on airport closure


                    //double scoreBase = 0.06303;
                    double scoreBase = 0.031515; //halving the score we were giving at first, since the Bomber pilot point totals seem to be coming up quite high in comparison with fighter kills

                    scoreBase *= aircraftCorrection;

                    //if (blenheim) scoreBase *= 8; //double score for Blenheims since their bomb load is pathetic (double the OLD score which is 4X the NEW score.  This makes 1 Blenheim (4 bombs X 4) about 50% as effective as on HE 11. (32 bombs)             

                    //Give more points for hitting more near the center of the airfield.  This will be the (colored) airfield marker that shows up IE on the map screen
                    //TODO: Could also give more if exactly on the the runway, or near it, or whatever
                    double multiplier = 0.5;
                    if (distFromCenter <= 4 * radius / 5) multiplier = 1;
                    if (distFromCenter <= radius / 3) multiplier = 1.5;

                    //If 'road' then this seems to mean it is a PAVED runway or taxiway, so we give extra credit                
                    if (landType == maddox.game.LandTypes.ROAD || landType == maddox.game.LandTypes.ROAD_MASK || landType == maddox.game.LandTypes.HIGHWAY)
                    {
                        multiplier = 1.6;
                    }

                    //It's harder to bomb a seaport/stuff in the water
                    //Also in seabase definition, the RADIUS should be made smaller.  But that is left up to mission designers.
                    if (landType == maddox.game.LandTypes.WATER) multiplier = multiplier / 1.2;

                        scoreBase *= multiplier;


                    if (mass_kg <= 0) mass_kg = 22;  //50 lb bomb; 22kg
                    double score = scoreBase * Math.Pow(mass_kg, 0.67);

                    /* Another way to reach the same end- probably quicker but less flexible & doesn't interpolate:
                     * 
                     * //Default is 0.5 points for ie 50 lb bomb
                     * if (mass_kg > 45) score = 0.722; //100 lb  (calcs assume radius of partial/serious building destruction per Sadovsky formula, dP > 0.10, explosion on surface of ground, and that 50% of bomb weight is TNT)
                    if (mass_kg > 110) score = 1.41; //250 
                    if (mass_kg > 220) score = 2.33; //500
                    if (mass_kg > 440) score = 3.70; //1000
                    if (mass_kg > 880) score = 5.92; //2000
                    if (mass_kg > 1760) score = 9.33 ; //4000

                    //UPDATE 5 Nov 2017: Bomber scores seem relatively too high so cutting this in half (though doubling it for Blennies since they are bomb-impaired)

                     */
                    double TimeNow_sec = Time.current(); // Calcs.TimeSince2016_sec();
                    double timeout = 0;
                    if (TimeNow_sec - lastBombMessageTime_sec < 0.3333) timeout = lastBombMessageTime_sec - TimeNow_sec + 0.333;
                    lastBombMessageTime_sec = TimeNow_sec + timeout + 0.333333; //Which should be the same as lastBombMessageTime_sec +1;
                                                                                //Console.WriteLine("Airportbombing: Delay airport bomb message by " + timeout.ToString("n1"));
                    if (timeout < 0) { timeout = 0; }

                    double individualscore = score;

                    //if (!ai && (isEnemy == 0 || isEnemy == 2))
                    //TOBRUK update, neutral territory is OK ( isEnemy ==2)


                    if (!ai && (isEnemy == 0))
                    {
 
                        if (initiator.Player != null)
                        {
                            bool nearbyTargs = Calcs.anyEnemyOrNeutralStationaries(GamePlay, pos.x, pos.y, 2000, initiator.Player.Army());

                            int matcharmy = initiator.Player.Army();

                            int numberNearbyEnemyGroundActors = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, pos, 2500, matcharmy: 3 - matcharmy, type: "");

                            if (!nearbyTargs && numberNearbyEnemyGroundActors == 0)
                            {
                                individualscore = -individualscore;  //Bombing on friendly/neutral territory earns you a NEGATIVE score
                                                                     //but, still helps destroy that base (for your enemies) as usual
                                Timeout(timeout * 12, () =>
                                {
                                    GamePlay.gpLogServer(null, initiator.Player.Name() + " has bombed a friendly or neutral airport. Serious repercussions for player AND team.", new object[] { });
                                });
                            }
                        }
                    }



                    //TF_Extensions.TF_GamePlay.Effect smoke = TF_Extensions.TF_GamePlay.Effect.SmokeSmall;
                    // TF_Extensions.TF_GamePlay.gpCreateEffect(GamePlay, smoke, pos.x, pos.y, pos.z, 1200);
                    string firetype = "BuildingFireSmall";
                    //if (mass_kg > 200) firetype = "BuildingFireBig"; //500lb bomb or larger
                    double smokeProb = .06;
                    if (mass_kg > 200) smokeProb = .06 + (mass_kg / 200 * 0.06); //probability of a smoke goes up with larger ordnance.  But for TOBRUK we're never using BuildingFireBig as it just seems TOO big.  Generally we're using LESS smoke in Tobruk due to server slowdowns/FPS issues

                    if (landType == maddox.game.LandTypes.WATER) smokeProb = smokeProb / 15; //very little smoke on water, but we'll say if it's in a seaport there could be some once in a while

                        if (stb_random.NextDouble() > smokeProb) firetype = ""; //smoking crater only sometimes.  Cut this lower in TOBRUK because smoke seems to slow down framerates a lot
                    //todo: finer grained bigger/smaller fire depending on bomb tonnage

                    //twcLogServer(null, "bombe 8", null);

                    //set placeholder variables
                    double PointsToKnockOut = mo.AirfieldPointsRequired;
                    double PointsTaken = mo.AirfieldDamagePoints + score;
                    mo.AirfieldDamagePoints = PointsTaken;
                    bool disabled = mo.Destroyed;
                    DateTime lastBombHit = DateTime.UtcNow;
                    if(mo.LastHitTime_UTC.HasValue) lastBombHit = mo.LastHitTime_UTC.Value;
                    mo.LastHitTime_UTC = DateTime.UtcNow;


                    string cratertype = "BombCrater_firmSoil_mediumkg";
                    if (mass_kg > 100) cratertype = "BombCrater_firmSoil_largekg"; //250lb bomb or larger
                    if (mass_kg > 200) cratertype = "BombCrater_firmSoil_EXlargekg"; //500lb bomb or larger.  EXLarge is actually 3 large craters slightly offset to make 1 bigger crater
                    if (landType == maddox.game.LandTypes.WATER) cratertype = "";// no craters in a seaport

                    double percent = 0;
                    double prev_percent = 0;
                    double points_reduction_factor = 1;
                    if (PointsToKnockOut > 0)
                    {
                        percent = PointsTaken / PointsToKnockOut;
                        prev_percent = (PointsTaken - score) / PointsToKnockOut;
                        if (prev_percent > 1) prev_percent = 1;
                        if ((prev_percent == 1) && (percent > 1)) points_reduction_factor = percent * 2; // So if they keep bombing after the airport is 100% knocked out, they keep getting points but not as many.  The more bombing the less the points per bomb.  So they can keep bombing for strategic reasons if they way (deny use of the AP) but they won't continue to accrue a whole bunch of points for it.
                        if (prev_percent > 1) firetype = "";  //Once airport is knocked out, no more smoking craters.  TOBRUK, too much smoke leads to many slowdowns; once knocked out it's already smoking plenty.
                    }

                    //twcLogServer(null, "bombe 8", null);

                    individualscore = individualscore / points_reduction_factor;  //reduce the individual/stats score if needed 
                    score = score / points_reduction_factor;  //also reduce the overall score = damage to the airport.  Once something is heavily bombed, additional bombing yields diminishing returns.

                    if (!ai) statsmission.stb_RecordStatsOnActorDead(initiator, 4, individualscore, 1, initiator.Tool.Type);  //So they have dropped a bomb on a target so they get some point score                   

                    //if (!ai) stb_RecordStatsOnActorDead(initiator, 4, individualscore, 1, initiator.Tool.Type);  //So they have dropped a bomb on a target so they get some point score


                    double timereduction = 0;
                    if (prev_percent > 0)
                    {
                        timereduction = (DateTime.UtcNow.Subtract(lastBombHit)).TotalSeconds;
                    }
                    double PointsTakenReduction = 0;
                    if (timereduction > 0)
                    {
                        PointsTakenReduction = timereduction / 60 / 20;  //Since the last bomb hit, this is how much repair has been done.
                    }

                    double timeToFixFromNow_sec = (PointsTaken - PointsTakenReduction) * 20 * 60 - timereduction; //50 lb bomb scores 0.5 so will take 10 minutes to repair.  Larger bombs will take longer; 250 lb about 1.4 points so 28 minutes to repeari
                                                                                                                  //But . . . it is ADDITIVE. So the first 50 lb bomb takes 10 minutes, the 2nd another 10, the 3rd another 10, and so on on.  So if you drop 32 50 bl bombs it will take 320 minutes before the 32nd bomb crater is repaired.
                                                                                                                  //Sources: "A crater from a 500lb bomb could be repaired and resurfaced in about 40 minutes" says one 2nd hand source. That seems about right, depending on methods & surface. https://www.airspacemag.com/multimedia/these-portable-runways-helped-win-war-pacific-180951234/
                                                                                                                  //unfortunately we can repair only the bomb crater; the SMOKE will remain for the entire mission because clod internals don't allow its removal.
                                                                                                                  //TODO: We could keep track of when the last bomb was dropped at each airport and deduct time here depending on how much repair had been done since the last bomb dropped
                                                                                                                  //TIMETOFIXFromNow_sec is the time ****FROM NOW**** that it will take the repair the airport

                    if (timeToFixFromNow_sec < score * 20 * 60) timeToFixFromNow_sec = score * 20 * 60; //timetofix is never less than the time needed to fix this one bomb crater, even if the airport has accrued some repair time                    

                    mo.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timeToFixFromNow_sec/repairSpeedupFactor); //This is the time all craters etc will be removed from the ap assuming no further damage

                    /*if (PointsTaken >= PointsToKnockOut) //airport knocked out
                    {
                        percent = 1;
                        //Just let timetofix ride, based on points as outlined above.
                        //timetofix = 24 * 60 * 60; //24 hours to repair . . . 
                        //timetofix += (PointsTaken - PointsToKnockOut) * 20 * 60; //Plus they achieve any additional knockout/repair time due to additional bombing beyond 100%, because those will have to be repaired, too.
                    }*/  //Ok, just let it be 250% or whatever knocked out.


                    //Advise player of hit/percent/points 
                    //(Note: USED to do this in .stats but with updated mission scoring, now we must do it here.)

                    MO_addInitiatorToListOfPlayersWhoContributed(initiator, apKey);
                    

                    if (!ai)
                        Timeout(timeout, () =>
                        {
                            twcLogServer(new Player[] { initiator.Player }, "Airport hit: " + (percent * 100).ToString("n0") + "% destroyed " + mass_kg.ToString("n0") + "kg " + individualscore.ToString("n1") + " pts " + (timeToFixFromNow_sec / 3600).ToString("n1") + " hr to repair ", new object[] { }); //+ (timereduction / 3600).ToString("n1") + " hr spent on repairs since last bomb drop"
                        });

                    //loadSmokeOrFire(pos.x, pos.y, pos.z, firetype, timetofix, stb_FullPath, cratertype);

                    //Sometimes, advise all players of percent destroyed, but only when crossing 25, 50, 75, 100% points
                    Timeout(timeout+0.15, () => { if (percent * 100 % 25 < prev_percent * 100 % 25) twcLogServer(null, mo.AirfieldName + " " + (percent * 100).ToString("n0") + "% destroyed ", new object[] { }); });

                    //twcLogServer(null, "bombe 8", null);

                    Timeout(timeout * 2, () =>
                      {
                          Calcs.loadCratersAndSmoke(GamePlay, this, pos.x, pos.y, pos.z, type: firetype, type2: cratertype, duration_s: timeToFixFromNow_sec);
                        //loadSmokeOrFire(pos.x, pos.y, pos.z, firetype, 180, stb_FullPath); //for testing, they are supposed to disappear after 180 seconds
                        //However the disappearing part doesn't work because CloD doesn't let you find the smoke object again to delete it.
                    });

                    if (PointsTaken >= PointsToKnockOut) //has points limit to knock out the airport been reached?
                    {

                        if (!disabled) //Only DESTROY the ap once, after that we can "add time" until undestroyed
                        {
                            //disabled = true; don't need to do this with mo as is is handled via MO_Destroy
                            //TODO: Sometimes this doesn't seem to add points to the correct army?  Maybe the army # is wrong or doesn't exist for some ap's ?
                            //Code below is supposed to fix this, but we'll see.
                            int arm = ap.Army();
                            if (arm != 1 && arm != 2)
                            {
                                arm = GamePlay.gpFrontArmy(APPos.x, APPos.y);  //This can be 1,2, or 0 for neutral territory.  
                            }

                            /*

                            if (arm == 1) CampaignMapBluePoints += 5; //5 campaign points for knocking out an airfield
                            else if (arm == 2) CampaignMapRedPoints += 5;
                            */
                            try
                            {  
                                MO_DestroyObjective(mo.ID, percentdestroyed: percent, timetofixFromNow_sec: timeToFixFromNow_sec, AirfieldDamagePoints: PointsTaken, AirfieldDamagePointsAdded: score, messageDelay_sec: timeout); //don't need to include last hit time because MO_Dest.. always includes the current UTC time
                            }
                            catch (Exception ex) { Console.WriteLine("OnExplosion_DoWork error1: " + ex.ToString()); };
                            /*
                             * The additional score & adding points for knocking out an airport have been moved to the MissionObjectives section with MO_DestroyObjective
                            //Question: Do we want to keep these objective points for knocking out any airfield?
                            if (arm == 1)
                            {
                                MissionObjectiveScore[ArmiesE.Blue]++; //1 campaign point for knocking out an airfield
                                MissionObjectivesCompletedString[ArmiesE.Blue] += " - " + apName;
                            }
                            else if (arm == 2)
                            {
                                MissionObjectiveScore[ArmiesE.Red]++;
                                MissionObjectivesCompletedString[ArmiesE.Red] += " - " + apName;
                            }

                            Console.WriteLine("Airport destroyed, awarding points to destroying army; airport owned by army: " + arm.ToString());
                            */

                            //LoadAirfieldSpawns(); //loads airfield spawns and removes inactive airfields. (on TWC this is not working/not doing anything for now)
                            //This airport has been destroyed, so remove the spawn point
                            if (ap != null)
                            {
                                foreach (AiBirthPlace bp in GamePlay.gpBirthPlaces())
                                {
                                    Point3d bp_pos = bp.Pos();
                                    if (ap.Pos().distance(ref bp_pos) <= ap.FieldR()) bp.destroy();//Removes the spawnpoint associated with that airport (ie, if located within the field radius of the airport)
                                }
                            }

                        }
                        else
                        {
                                MO_DestroyObjective_addTime(mo.ID, percentdestroyed: percent, timetofixFromNow_sec: timeToFixFromNow_sec, TimeLastHit_UTC: DateTime.UtcNow, AirfieldDamagePoints: PointsTaken, AirfieldDamagePointsAdded: score, messageDelay_sec: timeout);
                        }
                    }

                    //twcLogServer(null, "bombe 11", null);

                    /*AirfieldTargets.Remove(ap);
                    AirfieldTargets.Add(ap, new Tuple<bool, string, double, double, DateTime, double, Point3d>(disabled, Mission, PointsToKnockOut, PointsTaken, DateTime.UtcNow, radius, APPos));
                    */
                    mo.DestroyedPercent = percent;
                    break;
                    //sometimes airports are listed twice (for various reasons).  We award points only ONCE for each bomb & it goes to the airport FIRST ON THE LIST (dictionary) in which the bomb has landed.
                    //TODO!  The order of this list might very well change as we remove & add things.  ARggh!
                }
            }
        }
        catch (Exception ex) { Console.WriteLine("On Bomb Explosion do_work: " + ex.ToString()); }
    }

    bool final_SaveMapState_completed = false;
    bool final_MO_WriteMissionObjects_completed = false;
    int currentEndMission = 0;
    //END MISSION WITH WARNING MESSAGES ETC/////////////////////////////////
    //string winner should be "Red" or "Blue" exactly and only!!!
    public void EndMission(int endseconds = 0, string winner = "", bool BumrushRepelOnly = false)
    {
        currentEndMission++;
        int thisEndMission = currentEndMission; //Allows possibility to cancel/abort EndMission by incrementing currentEndMission, or, more importantly, if EndMission is called 2X (specifically if one side turns the map after EndMission has already started but before the mission has actually closed down) the 2nd time will supersede.

        if (winner == "")
        {
            twcLogServer(null, "Mission is restarting soon!!!", new object[] { });
            GamePlay.gpHUDLogCenter("Mission is restarting soon!!!");
        }
        else
        {
            if (endseconds > 60)
            {
                Timeout(endseconds + 40, () =>
                {
                    if (currentEndMission == thisEndMission)
                    {
                        twcLogServer(null, winner + " has turned the map!", new object[] { });
                        GamePlay.gpHUDLogCenter(winner + " has turned the map. Congratulations, " + winner + "!");
                    }
                });
            }
            Timeout(endseconds / 2, () =>
            {
                if (currentEndMission == thisEndMission)
                {
                    twcLogServer(null, winner + " has turned the map!", new object[] { });
                    GamePlay.gpHUDLogCenter(winner + " has turned the map. Congratulations, " + winner + "!");
                }
            });
            Timeout(endseconds + 15, () =>
            {
                if (currentEndMission == thisEndMission)
                {
                    twcLogServer(null, winner + " has turned the map!", new object[] { });
                    GamePlay.gpHUDLogCenter(winner + " has turned the map - mission ending soon!");
                }
            });
            Timeout(endseconds + 45, () =>
            {
                if (currentEndMission == thisEndMission)
                {
                    twcLogServer(null, winner + " has turned the map!", new object[] { });
                    GamePlay.gpHUDLogCenter(winner + " has turned the map - mission ending soon!");
                }
            });
            Timeout(endseconds + 61, () =>
            {
                if (currentEndMission == thisEndMission)
                {
                    twcLogServer(null, "Congratulations " + winner + " for turning the map!", new object[] { });
                }

            });
        }
        Timeout(endseconds, () =>
        {
            twcLogServer(null, "Mission is restarting in 1 minute!!!", new object[] { });
            GamePlay.gpHUDLogCenter("Mission is restarting in 1 minute!!!");
        });
        Timeout(endseconds + 30, () =>
        {
            if (currentEndMission == thisEndMission)
            {
                twcLogServer(null, "Server Restarting in 30 seconds!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Server Restarting in 30 seconds!!!");


                //All players who are lucky enough to still be in a plane at this point have saved their plane/it's returned to their team's supply


                //Save map state & data
                double misResult = SaveMapState(winner, BumrushRepelOnly: BumrushRepelOnly); //here is where we save progress/winners towards moving the map & front one way or the other; also saves the Supply State

                CheckStatsData(winner, BumrushRepelOnly: BumrushRepelOnly); //Save campaign/map state just before final exit.  This is important because when we do (GamePlay as GameDef).gameInterface.CmdExec("exit"); to exit, the -stats.cs will read the CampaignSummary.txt file we write here as the final status for the mission in the team stats.
                MO_WriteMissionObjects(wait: true);
                final_SaveMapState_completed = true;
                final_MO_WriteMissionObjects_completed = true;
            }

        });
        Timeout(endseconds + 50, () =>
        {
            if (currentEndMission == thisEndMission)
            {
                twcLogServer(null, "Server Restarting in 10 seconds!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Server Restarting in 10 seconds!!!");
            }


        });
        Timeout(endseconds + 60, () =>
        {
            if (currentEndMission == thisEndMission)
            {
                twcLogServer(null, "Mission ended. Please wait 2 minutes to reconnect!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Mission ended. Please wait 2 minutes to reconnect!!!");
                DebugAndLog("Mission ended.");

                //OK, trying this for smoother exit (save stats etc)
                //(TWCStatsMission as AMission).OnBattleStoped();//This really horchs things up, basically things won't run after this.  So save until v-e-r-y last.
                //OK, we don't need to do the OnBattleStoped because it is called when you do CmdExec("exit") below.  And, if you run it 2X it actually causes problems the 2nd time.
                if (GamePlay is GameDef)
                {
                    (GamePlay as GameDef).gameInterface.CmdExec("exit");
                }
                //GamePlay.gpBattleStop(); //It would be nice to do this but if you do, the script stops here.
            }
        });
        Timeout(endseconds + 90, () =>  //still doing this as a failsafe but allowing 20 secs to save etc
        {
            if (currentEndMission == thisEndMission)
            {
                //If the CmdExec("exit") didn't work for some reason, we can call OnBattleStoped manually to clean things up, then kill.  This is just a failsafe
                //(TWCStatsMission as AMission).OnBattleStoped();//This really horchs things up, basically things won't run after this.  So save until v-e-r-y last.
                //statsmission.OnBattleStoped();//This really horchs things up, basically things won't run after this.  So save until v-e-r-y last.
                System.Environment.Exit(1);
                Process.GetCurrentProcess().Kill();
            }
        });

    }


    /****************************************
     * LOADRANDOMSUBMISSION
     * 
     * Finds all files in the FILE_PATH whose filenames match the pattern (anything or nothing) + fileID + (anything or nothing) + .mis
     * and randomly selects ONE of them to load.
     * 
     * This can be used in mission to, e.g., have a fighter sweep that always launches 12 minutes into the mission.  Instead of 
     * running the same mission each time,  you can
     * have 5 different variants of the mission available, and one of them is selected randomly each time.
     * 
     * subdir is relative to the FILE_PATH and should not include a leading or trailing / or \
     * 
     * if check: true then it just checks whether any such submission files exist in the given directory or not.
     * 
     * Examples:
     * 
     *   LoadRandomSubmission(MISSION_ID + "-" + "randsubmissionBOMBERPATROLBLUE"); // load one of several available submissions
     *   
     *   LoadRandomSubmission(MISSION_ID + "-" + "randsubmissionFIGHTERPATROLRED", "patrols"); // keep sub-missions in subdirectory "patrols" of your main mission directory (FILE_PATH, above)
     * 
     * **************************************/

    public bool LoadRandomSubmission(string fileID = "randsubmission", string subdir = "", bool check = false)
    {
        //int endsessiontick = Convert.ToInt32(ticksperminute*60*HOURS_PER_SESSION); //When to end/restart server session
        //GamePlay.gpHUDLogCenter("Respawning AI air groups");
        //twcLogServer(null, "RESPAWNING AI AIR GROUPS. AI Aircraft groups re-spawn every " + RESPAWN_MINUTES + " minutes and have a lifetime of " + RESPAWN_MINUTES + "-" + 2*RESPAWN_MINUTES + " minutes. The map restarts every " + Convert.ToInt32((float)END_SESSION_TICK/60/TICKS_PER_MINUTE) + " hours.", new object[] { });

        bool ret = false;

        List<string> RandomMissions = GetFilenamesFromDirectory(CLOD_PATH + FILE_PATH + "/" + subdir, fileID); // Gets all files with with name fileID (like "M001-randsubmissionREDBOMBER") in the filename and ending with .mis
                                                                                                               //if (DEBUG) 
        if (check)
        {
            if (RandomMissions.Count > 0) return true;
            else return false;
        }

        //random.Next(100) > XX adjust what percentage of AI aicraft sub-missions are actually loaded
        //random.Next(100) > 85 loads 85% of missions, random.Next(100) > 50 loads 50% of missions, random.Next(100) > 100 loads 100% of missions etc.
        if (fileID.StartsWith(MISSION_ID + "-" + "randsubmission") && !fileID.StartsWith(MISSION_ID + "-" + "randsubmissionINITIALSHIPS") && random.Next(100) > PERCENT_SUBMISSIONS_TO_LOAD)
        {
            Console.WriteLine("Skipping load of " + fileID + " to reduce submission files loaded.");
            return ret;
        }
        DebugAndLog("Debug: Choosing from " + RandomMissions.Count + " missions to spawn. " + fileID + " " + CLOD_PATH + FILE_PATH);
        if (RandomMissions.Count > 0)
        {
            string RandomMission = RandomMissions[random.Next(RandomMissions.Count)];
            GamePlay.gpPostMissionLoad(RandomMission);
            ret = true;

            //if (DEBUG) 
            DebugAndLog("Loading mission " + RandomMission);
            Console.WriteLine("Loading mission " + Path.GetFileName(RandomMission));
            DebugAndLog("Current time: " + DateTime.UtcNow.ToString("O"));
        }

        return ret;
        /////////////////////////////////////ends submission calls ////////////////////// 0000000000000000000000000000000000000000000000000000000000000000000000000/////////////

        //GamePlay.gpPostMissionLoad("missions/Multi/Flug/Blue vs Red - Scimitar-Flug-2016-04-19-submis");



    }

    //LOADING OUR RANDOM SUB-MISSIONS//////////////////////////////
    public List<string> GetFilenamesFromDirectory(string dirPath, string mask = null)
    {
        List<string> list = new List<string>() { };
        string[] filenames = Directory.GetFiles(dirPath, "*" + mask + "*.mis");

        list = new List<string>(filenames);
        DebugAndLog("Num matching submissions found in directory: " + list.Count);
        return list;
    }

    private void DoDamageToAirplane(AiAircraft aircraft)
    {
        Timeout(10, () =>
         {
             if (aircraft != null)
             {

                 //if (!aircraft.IsAirborne())
                 //{get

                 aircraft.cutLimb(part.LimbNames.AileronL0);
                 aircraft.cutLimb(part.LimbNames.AileronR0);

                 aircraft.cutLimb(part.LimbNames.ElevatorL0);
                 aircraft.cutLimb(part.LimbNames.ElevatorR0);

                 aircraft.cutLimb(part.LimbNames.Rudder0);


                 //aircraft.cutLimb(part.LimbNames.WingL0); 
                 //aircraft.cutLimb(part.LimbNames.WingR0);
                 //aircraft.cutLimb(part.LimbNames.WingL2); // Spit2a 
                 //aircraft.cutLimb(part.LimbNames.WingR2);

                 //aircraft.cutLimb(part.LimbNames.AileronL0);
                 //aircraft.cutLimb(part.LimbNames.AileronR1);

                 //aircraft.cutLimb(part.LimbNames.ElevatorL0);
                 //aircraft.cutLimb(part.LimbNames.ElevatorR1);

                 //aircraft.cutLimb(part.LimbNames.Engine0);
                 //aircraft.cutLimb(part.LimbNames.Engine7);


                 //part.LimbNames.ElevatorL0
                 //part.LimbNames.ElevatorL1
                 //part.LimbNames.ElevatorR0
                 //part.LimbNames.ElevatorR1

                 //part.LimbNames.Engine0 - 7


                 //part.LimbNames.AileronL0
                 //part.LimbNames.AileronL1
                 //part.LimbNames.AileronR0
                 //part.LimbNames.AileronR1


                 //aircraft.cutLimb(part.LimbNames.WingL1);
                 //aircraft.cutLimb(part.LimbNames.WingL3);
                 //aircraft.cutLimb(part.LimbNames.WingL4);
                 //aircraft.cutLimb(part.LimbNames.WingL5);
                 //aircraft.cutLimb(part.LimbNames.WingL6);
                 //aircraft.cutLimb(part.LimbNames.WingL7);

                 //aircraft.cutLimb(part.LimbNames.WingR1);

                 //aircraft.cutLimb(part.LimbNames.WingR3);
                 //aircraft.cutLimb(part.LimbNames.WingR4); // 109
                 //aircraft.cutLimb(part.LimbNames.WingR5);
                 //aircraft.cutLimb(part.LimbNames.WingR6);
                 //aircraft.cutLimb(part.LimbNames.WingR7);
                 ////}
                 ////else
                 ////{
                 ////    // plane in Air Tail cut off
                 //aircraft.cutLimb(part.LimbNames.Tail0);
                 //aircraft.cutLimb(part.LimbNames.Tail1);
                 //aircraft.cutLimb(part.LimbNames.Tail2);
                 //aircraft.cutLimb(part.LimbNames.Tail3);
                 //aircraft.cutLimb(part.LimbNames.Tail4);
                 //aircraft.cutLimb(part.LimbNames.Tail5);
                 //aircraft.cutLimb(part.LimbNames.Tail6);
                 //aircraft.cutLimb(part.LimbNames.Tail7);
                 ////}
             }
         });
    }
    private void destroyPlayerPlane(AiAircraft aircraft)
    {
        if (aircraft != null)
            aircraft.Destroy();
    }
    private void damagePlayerGroup(AiActor actorMain)
    {
        foreach (AiActor actor in actorMain.Group().GetItems())
        {
            if (actor == null)
                return;

            AiAircraft aircraft = (actor as AiAircraft);

            if (aircraft != null)
            {
                DoDamageToAirplane(aircraft);
            }
        }
    }

    private void sendScreenMessageTo(int army, string msg, object[] parms)
    {
        List<Player> Players = new List<Player>();

        //Singleplayer or Dedi Server
        if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army || army == -1)
                Players.Add(GamePlay.gpPlayer());
        } // Multiplayer
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            foreach (Player p in GamePlay.gpRemotePlayers())
            {
                if (p.Army() == army || army == -1)
                    Players.Add(p);
            }
        }
        if (Players != null && Players.Count > 0)
            GamePlay.gpHUDLogCenter(Players.ToArray(), msg, parms);
    }


    private void sendChatMessageTo(int army, string msg, object[] parms)
    {
        List<Player> Players = new List<Player>();

        //Singleplayer or Dedi Server
        if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army || army == -1)
                Players.Add(GamePlay.gpPlayer());
        } // Multiplayer
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            foreach (Player p in GamePlay.gpRemotePlayers())
            {
                if (p.Army() == army || army == -1)
                    Players.Add(p);
            }
        }
        if (Players != null && Players.Count > 0)
            twcLogServer(Players.ToArray(), msg, parms);
    }

    /************************************************************
     * ONPLACELEAVE
     * *********************************************************/

    public override void OnPlaceLeave(Player player, AiActor actor, int placeIndex)
    {
        base.OnPlaceLeave(player, actor, placeIndex);

        /// REARM/REFUEL: cancel possibly pending request of player
        //  ManageRnr.cancelOfPlayer(GamePlay, player);

        if (actor != null && actor is AiAircraft)
        {
            //OK, we have to wait a bit here bec. some ppl use ALT-F11 (ALT-F2) for 'external view' which allows to leave two positions
            //inhabited by bomber pilot & just return to the one position.  But how it actually works is the pilot leaves the aircraft momentarily.
            Timeout(0.5f, () =>
            {
                //Save the reconnaissance photos, if the player is on friendly territory, stopped, & alive
                //If crashlanded etc then the photos will be erased, so this applies only to a pretty good landing on friendly territory, maybe at/near an airport
                if (player != null)
                {
                    if ((actor as AiAircraft) != null &&
                        GamePlay.gpFrontArmy(actor.Pos().x, actor.Pos().y) == actor.Army() &&
                        //Stb_distanceToNearestAirport(actor) < 3100 &&
                        Calcs.CalculatePointDistance((actor as AiAircraft).AirGroup().Vwld()) < 2 &&
                        actor.IsAlive()
                        )
                        MO_RecordPlayerScoutPhotos(player);

                }
                string pName = "";
                if (player != null) pName = player.Name();
                if (actor is AiAircraft)
                {

                    if (isAiControlledPlane2(actor as AiAircraft))
                    {
                        //Changing from .5 to 1.5 so that we can allow 1.4 secs in -stats.cs on <rr, for AI warmup of aircraft for 1 second longer
                        Timeout(1.5f, () => //5 sec seems too long, the ai vigorously takes control sometimes, and immediately.  Perhaps even 1 second or .5 better than 2.
                        {
                            if (isAiControlledPlane2(actor as AiAircraft))
                            {
                                damageAiControlledPlane(actor);
                                Console.WriteLine("Player has left plane; damaged aircraft so that AI cannot assume control " + pName + " " + (actor as AiAircraft).Type());
                                //check limited aircraft

                                /* this is now handled by -supply.cs system
                                    switch ((actor as AiAircraft).InternalTypeName())
                                {

                                    case "bob:Aircraft.SpitfireMkIIa":
                                        currentSpitIIas--;
                                        break;
                                    case "bob:Aircraft.Bf-109E-4N":
                                        current109s--;
                                        break;

                                }
                                */

                            }
                        }
                        );
                    }
                }
                DateTime utcDate = DateTime.UtcNow;
                //logStats(utcDate.ToString("u") + " " + player.Name() + " " + WritePlayerStat(player));
            }
            );

        }

    }

    /************************************************************
    * ONPLACEENTER
    * *********************************************************/

    public override void OnPlaceEnter(Player player, AiActor actor, int placeIndex)
    {
        base.OnPlaceEnter(player, actor, placeIndex);

        if (player != null)
        {
            setMainMenu(player);
            //if (placeIndex == 0) placeIndex++;

            //string PlayerPlace = Enum.GetName(typeof(CrewFunction), (actor as AiCart).CrewFunctionPlace(placeIndex));
            //tells the name of the position their in - Pilot, Bombardier, Nose Gunner, etc.

            //GamePlay.gpHUDLogCenter(PlayerPlace + " " + placeIndex.ToString("F0"));

            /*
             * TESTING STUFF FOR aPlayer Player extension
            aPlayer p = new aPlayer();

            Player p1 = p as Player;

            Console.WriteLine("Player bugablug" + p1.Name());
            Console.WriteLine("Player bugablug" + p1.Name() + p1.Army().ToString());

            gpLogServerAndLog(null, "Player bugablug" + p1.Name(), null);

            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddSessStat(p1, 798, 5321);
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_IncrementSessStat(player, 848);  //848 recon photos taken, 849 # of objectives photographed
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, 848, 1);
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_IncrementSessStat(player, 849);  //848 recon photos taken, 849 # of objectives photographed
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, 849, 1);

            MO_AddPlayerStatsScoresForObjectiveDestruction(p1, MissionObjectivesList["RTarget28R"], 10);
            */

        }

        /* handling this via -supply.cs now
        if (actor != null && actor is AiAircraft)
        {
            //check limited aircraft
            switch ((actor as AiAircraft).InternalTypeName())
            {
                case "bob:Aircraft.SpitfireMkIIa":
                    {
                        currentSpitIIas++;
                        if (currentSpitIIas > allowedSpitIIas)
                        {
                            damagePlayerGroup(actor);
                            GamePlay.gpHUDLogCenter(new Player[] { player }, "SpitIIa aircraft limit reached. Choose a different plane! Plane disabled in 10 seconds!");
                        }
                        break;
                    }
                case "bob:Aircraft.Bf-109E-4N":
                    {
                        current109s++;
                        if (current109s > allowed109s)
                        {
                            damagePlayerGroup(actor);
                            GamePlay.gpHUDLogCenter(new Player[] { player }, "109 E-4N aircraft limit reached. Choose a different plane! Plane disabled in 10 seconds!");
                        }
                        break;
                    }

            } 
        }
        */
    }


    /*************************************************************
     * CHECKSTATSDATA
     * ***********************************************************/


    //Red & blue point totals transferred from -stats.cs
    //REMEMBER that these are ints and they are percentage X100 (so that we have decimal percentageand so you must DIVIDE BY 100 to get decimal percentage points)
    //So we are going to do that here & keep them as doubles
    double RedTotalF = 0;
    double BlueTotalF = 0;
    double RedAirF = 0;
    double RedAAF = 0;
    double RedNavalF = 0;
    double RedGroundF = 0;
    double RedPlanesWrittenOffI = 0;
    double RedScoutPhotosI = 0;
    double RedScoutedObjectivesI = 0;
    double BlueAirF = 0;
    double BlueAAF = 0;
    double BlueNavalF = 0;
    double BlueGroundF = 0;
    double BluePlanesWrittenOffI = 0;
    double BlueScoutPhotosI = 0;
    double BlueScoutedObjectivesI = 0;

    public void CheckStatsData(string winner = "", bool BumrushRepelOnly = false)
    {
        /************************************************
         * 
         * Check/download/transfer stats data
         * Recursive function called every X seconds
         ************************************************/
        Timeout(188, () => { CheckStatsData(); });

        //Timeout(188, () => { Task.Run(() => CheckStatsData()); });

        /*
         * THIS is the old method were we wrote values to a file from -stats.cs and read them from the file for -main.cs
         * Now that we can easily communicate between the two classes there is no reason to do this.
        // Read the stats file where we tally red & blue victories for the session
        //This allows us to make red/blue victories part of our mission objectives &
        //use the victory tallying mechanism in -stats.cs to do the work of keeping track of that
        try
        {
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX1"); //Testing for potential causes of warping
            using (StreamReader sr = new StreamReader(STATSCS_FULL_PATH + "SessStats.txt"))
            {
                string RedTotalS = sr.ReadLine();
                string BlueTotalS = sr.ReadLine();
                string TimeS = sr.ReadLine();
                string RedAirS = sr.ReadLine();
                string RedAAS = sr.ReadLine();
                string RedNavalS = sr.ReadLine();
                string RedGroundS = sr.ReadLine();
                string RedPlanesWrittenOffS = sr.ReadLine();
                string BlueAirS = sr.ReadLine();
                string BlueAAS = sr.ReadLine();
                string BlueNavalS = sr.ReadLine();
                string BlueGroundS = sr.ReadLine();
                string BluePlanesWrittenOffS = sr.ReadLine();

                //Only if they are recent (less than 125 seconds old) do we accept the numbers.
                //-stats.cs generally writes this data every 2 minutes, so older than that is an old mission or something
                DateTime Time = Convert.ToDateTime(TimeS);

                if (Time.AddSeconds(125).ToUniversalTime() > DateTime.UtcNow)
                {
                    RedTotalF = Convert.ToDouble(RedTotalS) / 100;
                    BlueTotalF = Convert.ToDouble(BlueTotalS) / 100;
                    //twcLogServer(null, "Read SessStats.txt: Times MATCH", null);
                    RedAirF = Convert.ToDouble(RedAirS) / 100;
                    RedAAF = Convert.ToDouble(RedAAS) / 100;
                    RedNavalF = Convert.ToDouble(RedNavalS) / 100;
                    RedGroundF = Convert.ToDouble(RedGroundS) / 100;
                    RedPlanesWrittenOffI = Convert.ToInt32(RedPlanesWrittenOffS);
                    BlueAirF = Convert.ToDouble(BlueAirS) / 100;
                    BlueAAF = Convert.ToDouble(BlueAAS) / 100;
                    BlueNavalF = Convert.ToDouble(BlueNavalS) / 100;
                    BlueGroundF = Convert.ToDouble(BlueGroundS) / 100;
                    BluePlanesWrittenOffI = Convert.ToInt32(BluePlanesWrittenOffS);
                }

                //twcLogServer(null, string.Format("RED session total: {0:0.0} BLUE session total: {1:0.0} Time1: {2:R} Time2 {3:R}",
                //      (double)(RedTotalF) / 100, (double)(BlueTotalF) / 100, Time.ToUniversalTime(), DateTime.Now.ToUniversalTime()), null);
                //twcLogServer(null, string.Format("RED session total: {0:0.0} BLUE session total: {1:0.0} ",
                //      (double)(RedTotalF) / 100, (double)(BlueTotalF) / 100), null);

            }

        }
        catch (Exception ex) { System.Console.WriteLine("Main mission - read sessstats.txt - Exception: " + ex.ToString()); }
        */

        StatsMission.Stb_PlayerSessStat BS = statsmission.stb_SaveIPlayerStat.BlueSessStats;
        StatsMission.Stb_PlayerSessStat RS = statsmission.stb_SaveIPlayerStat.RedSessStats;

        RedTotalF = RS.getSessStat(798) / 100;
        BlueTotalF = BS.getSessStat(798) / 100;
        //twcLogServer(null, "Read SessStats.txt: Times MATCH", null);
        RedAirF = RS.getSessStat(802) / 100;
        RedAAF = RS.getSessStat(806) / 100;
        RedNavalF = RS.getSessStat(810) / 100;
        RedGroundF = RS.getSessStat(814) / 100;
        RedPlanesWrittenOffI = RS.getSessStat(845);
        BlueAirF = BS.getSessStat(802) / 100;
        BlueAAF = BS.getSessStat(806) / 100;
        BlueNavalF = BS.getSessStat(810) / 100;
        BlueGroundF = BS.getSessStat(814) / 100;
        BluePlanesWrittenOffI = BS.getSessStat(845);


        //twcLogServer(null, string.Format("RED session total: {0:0.0} BLUE session total: {1:0.0} Time1: {2:R} Time2 {3:R}",
        //      (double)(RedTotalF) / 100, (double)(BlueTotalF) / 100, Time.ToUniversalTime(), DateTime.Now.ToUniversalTime()), null);
        //twcLogServer(null, string.Format("RED session total: {0:0.0} BLUE session total: {1:0.0} ",
        //      (double)(RedTotalF) / 100, (double)(BlueTotalF) / 100), null);



        //Get the current campaign state
        Tuple<double, string> res;
        if (BumrushRepelOnly) res = CalcMapMove("", false, false, null, BumrushRepelOnly: BumrushRepelOnly);  //Bumrushrepel isn't a "real" victory/ they don't get the Map Turn special points
        else res = CalcMapMove(winner, false, false, null);

        //sw.Write(res.Item2); //Item2 is a detail breakout of current campaign score.  Could be included in final stats for the mission, perhaps
        double newMapState = CampaignMapState + res.Item1 + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0;
        if (winner != "") newMapState = CampaignMapState; //if a winner/map turn we have already re-calced the new map state
        string campaign_summary = summarizeCurrentMapstate(newMapState, false, null);

        //Write the campaign summary text with current score etc.; this will go on the TEAM STATS page of the stats page
        try
        {
            string outputmsg = "";
            if (RedPlanesWrittenOffI >= 2)
            {
                string msg = "Red has lost " + RedPlanesWrittenOffI.ToString() + " aircraft in battle.";
                outputmsg += msg + "<br>" + Environment.NewLine;
            }
            if (BluePlanesWrittenOffI >= 2)
            {
                string msg = "Blue has lost " + BluePlanesWrittenOffI.ToString() + " aircraft in battle.";
                outputmsg += msg + "<br>" + Environment.NewLine;
            }
            if (BluePlanesWrittenOffI >= 2 || RedPlanesWrittenOffI >= 2) outputmsg += "<br>" + Environment.NewLine;

            if (RedScoutPhotosI >= 1 || RedScoutedObjectivesI >= 0)
            {
                string msg = "Red has taken " + RedScoutPhotosI.ToString() + " reconnaissance photos of " + RedScoutedObjectivesI.ToString() + " mission objectives.";
                outputmsg += msg + "<br>" + Environment.NewLine;
            }
            if (BlueScoutPhotosI >= 1 || BlueScoutedObjectivesI >= 0)
            {
                string msg = "Blue has taken " + BlueScoutPhotosI.ToString() + " reconnaissance photos of " + BlueScoutedObjectivesI.ToString() + " mission objectives.";
                outputmsg += msg + "<br>" + Environment.NewLine;
            }
            if (BlueScoutPhotosI >= 1 || BlueScoutedObjectivesI >= 0 || RedScoutPhotosI >= 1 || RedScoutedObjectivesI >= 0) outputmsg += "<br>" + Environment.NewLine;

            outputmsg = "Blue Objectives complete (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Blue]) + "<br>" + Environment.NewLine + "<br>" + Environment.NewLine; 
            outputmsg += "Red Objectives complete (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Red]) + "<br>" + Environment.NewLine;

            if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus > 0 || MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0)
            {
                outputmsg += "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
                outputmsg += MO_ListRemainingPrimaryObjectives(null, 1, 24, 0, display: false, html: true, leak: false);
                outputmsg += "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
                outputmsg += MO_BRBumrushSituationReport(null, delay:0, display: false, html: true, silentIfInactive: true);
                outputmsg += "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;

            }

            outputmsg += "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
            outputmsg += campaign_summary; //note: this include .NewLine but not <br>
            if (winner != "")
            {
                outputmsg += "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
                if (BumrushRepelOnly) outputmsg += winner.ToUpper() + " HAS REPELLED THE ATTACK AND RETAKEN THE AIRPORT! Congratulations, " + winner + "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
                else outputmsg += winner.ToUpper() + " HAS WON THE BATTLE, COMPLETED ALL OBJECTIVES, AND TAKEN THE AIRPORT! Congratulations, " + winner + "<br>" + Environment.NewLine + "<br>" + Environment.NewLine;
                outputmsg += winner.ToUpper() + " players who contributed to this historic victory by scouting high priority areas identified by HQ: <br>" + Environment.NewLine;
                outputmsg += MO_PlayersWhoScoutedObjectivesList(winner) + "<br>" + Environment.NewLine;
                outputmsg += winner.ToUpper() + " players who contributed to this historic victory by assisting in the destruction of the objectives identified by HQ: <br>" + Environment.NewLine;
                outputmsg += MO_PlayersWhoContributedToObjectivesList(winner) + "<br>" + Environment.NewLine;

            }


            //File.WriteAllText(STATSCS_FULL_PATH + "CampaignSummary.txt", outputmsg);
            Calcs.WriteAllTextAsync(STATSCS_FULL_PATH + "CampaignSummary.txt", outputmsg);
        }
        catch (Exception ex) { Console.WriteLine("CampaignSummary Write: " + ex.ToString()); }


        //Skipping all the points & map-turning related to stats for now.  Just transferring the data for possible use.
        /*
        //Check whether the 50-kill objective is reached.  
        if (!osk_Red50Kills && RedTotalF >= 50)
        {
            osk_RedObjCompleted += "50 total Team Kills - ";
            osk_Red50Kills = true;
            twcLogServer(null, "RED reached 50 Team Kills. Well done Team Red!", new object[] { });
            GamePlay.gpHUDLogCenter("RED reached 50 Team Kills. Well done Red!");

        }
        if (!osk_Blue50Kills && BlueTotalF >= 50)
        {
            osk_BlueObjCompleted += "50 total Team Kills - ";
            osk_Blue50Kills = true;
            twcLogServer(null, "BLUE reached 50 Team Kills. Well done Team Blue!", new object[] { });
            GamePlay.gpHUDLogCenter("BLUE reached 50 Team Kills. Well done Blue!");
        }

        //Check whether the 50-kill objective is reached.  
        if (!osk_Red10AirKills && RedAirF >= 10)
        {
            osk_RedObjCompleted += "10 total Air Kills - ";
            osk_Red10AirKills = true;
            twcLogServer(null, "Red reached 10 total Air Kills. Well done Team Red!", new object[] { });
            GamePlay.gpHUDLogCenter("Red reached 10  total Air Kills. Well done Red!");
        }
        if (!osk_Blue10AirKills && BlueAirF >= 10)
        {
            osk_BlueObjCompleted += "10 total Air Kills - ";
            osk_Blue10AirKills = true;
            twcLogServer(null, "BLUE reached 10 total Air Kills. Well done Team Blue!", new object[] { });
            GamePlay.gpHUDLogCenter("BLUE reached 10  total Air Kills. Well done Blue!");
        }
        if (!osk_Red10GroundKills && (RedAAF + RedNavalF + RedGroundF) >= 10)
        {
            osk_RedObjCompleted += "10 total AA/Naval/Ground Kills - ";
            osk_Red10GroundKills = true;
            twcLogServer(null, "Red reached 10 total AA/Naval/Ground Kills. Well done Team Red!", new object[] { });
            GamePlay.gpHUDLogCenter("Red reached 10  total AA/Naval/Ground Kills. Well done Red!");
        }
        if (!osk_Blue10GroundKills && (BlueAAF + BlueNavalF + BlueGroundF) >= 10)
        {
            osk_BlueObjCompleted += "10 total AA/Naval/Ground Kills - ";
            osk_Blue10GroundKills = true;
            twcLogServer(null, "BLUE reached 10 total AA/Naval/Ground Kills. Well done Team Blue!", new object[] { });
            GamePlay.gpHUDLogCenter("BLUE reached 10  total AA/Naval/Ground Kills. Well done Blue!");
        }


        //RED has turned the map
        if (!osk_MapTurned && osk_LeHavreDam_destroyed && osk_OuistrehamDam_destroyed && osk_LeHavreFuelStorage_destroyed && osk_Red10AirKills && osk_Red10GroundKills && RedTotalF >= 50 && RedTotalF > BlueTotalF + 10)//We use RedTotalF >= 50 here, rather than osk_Red50Kills == true, because the team may get 50 kills but then LOSE SOME due to penalty points.
        {
            osk_RedObjCompleted += "10 more Team Kills than Blue - ";
            osk_MapTurned = true;
            EndMission(300, "RED");

        }


        //BLUE has turned the map
        if (!osk_MapTurned && osk_HambleDam_destroyed && osk_CowesDam_destroyed && osk_PortsmouthFuelStorage_destroyed && osk_Blue10AirKills && osk_Blue10GroundKills && BlueTotalF >= 50 && BlueTotalF > RedTotalF + 10)
        {
            osk_BlueObjCompleted += "10 more Team Kills than Red - ";
            osk_MapTurned = true;
            EndMission(300, "BLUE");

        }

        */


    }





    public string GetRedObjectivesString()
    {
        string StringToReturn = "";
        StringToReturn = "Red Objectives complete (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):\n";
        StringToReturn = StringToReturn + MissionObjectivesCompletedString[ArmiesE.Red];
        return StringToReturn;
    }

    public string GetBlueObjectivesString()
    {
        string StringToReturn = "";
        StringToReturn = "Blue Objectives complete (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):\n";
        StringToReturn = StringToReturn + MissionObjectivesCompletedString[ArmiesE.Blue];
        return StringToReturn;
    }

    /*************************************************************
    * END - CHECKSTATSDATA
    * ***********************************************************/

    /******************************************************************************
     * 
     * LONG-TERM CAMPAIGN METHODS 
     * 
     * Routines dealing with the LONG TERM CAMPAIGN and calculating the points
     * for each team that determine the current campaign status
     * and which map will be used next mission
     *      
     ******************************************************************************/

    private double firstMapMove = 0; //save the first  mapmove calculation of the session so we can say what happened **THIS SESSION**
    private bool firstMapMove_saved = false;

    //CalcMapMove - returns a double with DOUBLE the current mission score and STRING the text message detailing the score
    //This figures the score at intermediate points during the session, but also the final score at end of session or when
    //one team or the other turns the map
    public Tuple<double, string> CalcMapMove(string winner, bool final = true, bool output = true, Player player = null, bool BumrushRepelOnly = false)
    {
        double MapMove = 0;
        string msg = "";
        string outputmsg = "";
        Player[] recipients = null;
        if (player != null) recipients = new Player[] { player };

        double delay_s = 0;

    

        //Update scoring, 2020/02/15 - now we are ADDING 100 points (/100 = 1) to that side's current Map Mover score, and also adding the (miniscule) amount
        //of points they get from air victories etc.  Before it was just a flat 100 points for turning the map, but now it's whatever objective points you've accumulated PLUS 100 points more.
        //
        //UPDATE TOBRUK: We now have intermediate scoring which looks like a couple points to make a few hundred; but upon turning the map by winning the
        //airport they are awarded a flat 100 map points (=100X100 points as shown) and so we calculate map moves on 0, 100, 200, -100, -200 etc
        if (winner == "Red")
        {
            msg = "Red moved the campaign forward by achieving all primary objectives, assaulting and occupying the new airport, and moving the front forward!";
            if (BumrushRepelOnly) msg = "Red successfully repelled the attack on the airport and now has a chance to move the front forward!";
            outputmsg += msg + Environment.NewLine;
            if (output) gpLogServerAndLog(recipients, msg, null);
            //return new Tuple<double, string>(1.2 + MissionObjectiveScore[ArmiesE.Red] / 100.0 + RedTotalF / 1000.0, outputmsg); //1 is the 100 point bonus, plus we're adding in the objective points at this time, plus we're adding in the individual victory bonus 2X

            //TOBRUK we're just advancing the map by increments  of 1000.  (ie 10 (X100 = 1000) for RED)
            return new Tuple<double, string>(100, outputmsg); //1 is the 100 point bonus, plus we're adding in the objective points at 
        }
        if (winner == "Blue")
        {
            msg = "Blue moved the campaign forward by achieving all primary objectives, assaulting and occupying the new airport, and moving the front forward!";
            if (BumrushRepelOnly) msg = "Blue successfully repelled the attack on the airport and now has a chance to move the front forward!";
            outputmsg += msg + Environment.NewLine;
            if (output) gpLogServerAndLog(recipients, msg, null);
            //return new Tuple<double, string>(-1.2 - MissionObjectiveScore[ArmiesE.Blue] / 100.0 - BlueTotalF / 1000.0, outputmsg); //-1 is the 100 point BLUE bonus, plus we're adding (or rather SUBTRACTING since this is the blue side) in the objective points at this time, plus we're adding in the individual victory bonus 2X

            //TOBRUK we're just advancing the map by increments  of 1000.  (ie -10 (X100 = 1000) for BLUE)
            return new Tuple<double, string>(-100, outputmsg); //-1 is the 100 point BLUE bonus, plus we're adding (or rather 
        }

        if (RedTotalF > 3)
        {
            string msg1 = "Red has moved the campaign forward through its " + RedTotalF.ToString("n1") + " total air/ground/naval victories!";
            outputmsg += msg1 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg1, null); });
            delay_s += 0.04;
            MapMove += RedTotalF / 1000.0;
        }
        if (BlueTotalF > 3)
        {
            string msg2 = "Blue has moved the campaign forward through its " + BlueTotalF.ToString("n1") + " total air/ground/naval victories!";
            outputmsg += msg2 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg2, null); });
            delay_s += 0.04;
            MapMove -= BlueTotalF / 1000.0;
        }

        

        /*
        double difference = RedTotalF - BlueTotalF;
        if (Math.Abs(difference) >= 5)
        {
            if (difference > 0)
            {
                msg = "Red has moved the campaign forward by getting " + difference.ToString("n1") + " more total victories than Blue!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            if (difference < 0)
            {
                msg = "Blue has moved the campaign forward by getting " + (-difference).ToString("n1") + " more total victories than Red!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            MapMove += difference / 400;
        }

        double air_difference = RedAirF - BlueAirF;

        if (Math.Abs(air_difference) >= 5)
        {
            if (air_difference > 0)
            {
                msg = "Red has moved the campaign forward by getting " + air_difference.ToString("n1") + " more air victories than Blue!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            if (air_difference < 0)
            {
                msg = "Blue has moved the campaign forward by getting " + (-air_difference).ToString("n1") + " more air victories than Red!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            MapMove += air_difference / 400;
        }
        double ground_difference = RedAAF + RedNavalF + RedGroundF - BlueAAF - BlueNavalF - BlueGroundF;
        if (Math.Abs(ground_difference) >= 5)
        {
            if (ground_difference > 0)
            {
                msg = "Red has moved the campaign forward by getting " + ground_difference.ToString("n1") + " more ground victories than Blue!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            if (ground_difference < 0)
            {
                msg = "Blue has moved the campaign forward by getting " + (-ground_difference).ToString("n1") + " more ground victories than Red!";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            MapMove += ground_difference / 400;
        }
        */

        if (MissionObjectiveScore[ArmiesE.Red] > 0)
        {
            string msg3 = "Red: " + MissionObjectiveScore[ArmiesE.Red].ToString("n0") + " points destroying Mission Objectives!";
            outputmsg += msg3 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg3, null); });
            delay_s += 0.04;
            //MapMove += MissionObjectiveScore[ArmiesE.Red] / 100; //2020-02 - with the persistent campaign, we don't add this at the end of each session any more.  It is saved from session to session and only added in when the map is turned by this team (their full objective score + 100 points)
        }

        if (MissionObjectiveScore[ArmiesE.Blue] > 0)
        {
            string msg4 = "Blue: " + MissionObjectiveScore[ArmiesE.Blue].ToString("n0") + " points destroying Mission Objectives!";
            outputmsg += msg4 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg4, null); });
            delay_s += 0.04;
            //MapMove -= MissionObjectiveScore[ArmiesE.Blue] / 100; //2020-02 - with the persistent campaign, we don't add this at the end of each session any more.  It is saved from session to session and only added in when the map is turned by this team (their full objective score + 100 points)
        }
        if (RedPlanesWrittenOffI >= 3 && winner != "Red") //subtract for planes written off, but only if they didn't turn the map this sssion
        {
            string msg5 = "Red: " + RedPlanesWrittenOffI.ToString() + " aircraft lost";
            outputmsg += msg5 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg5, null); });
            delay_s += 0.04;
            MapMove -= (double)RedPlanesWrittenOffI / 300;  //These are LOSSES, so - points for red & + points for blue
        }
        if (BluePlanesWrittenOffI >= 3 && winner != "Blue") //subtract for planes written off, but only if they didn't turn the map this sssion
        {
            string msg6 = "Blue: " + BluePlanesWrittenOffI.ToString() + " aircraft lost";
            outputmsg += msg6 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg6, null); });
            delay_s += 0.04;
            MapMove += (double)BluePlanesWrittenOffI / 300; //These are LOSSES, so - points for red & + points for blue
        }

        /*
        if (final)
        {

            double portionComplete = calcProportionTimeComplete(); //0= just start, 1 = complete
            double outside = (random.NextDouble() - 0.5) * portionComplete;  //if a full mission we can get up to +/- 0.5 added by 'outside factors'.  But if we have done only a half mission it would be half that, 1/4 mission = 1/4 that, etc.


            if (outside > 0.05)
            {
                string reason = "Help from Allies";
                if (random.Next(2) == 1) reason = "A naval victory";
                msg = reason + " has strengthened Red's position";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            if (outside < -0.05)
            {
                string reason = "Help from Allies has";
                if (random.Next(3) == 1) reason = "A naval victory has";
                else if (random.Next(1) == 1) reason = "Positive developments on the Eastern Front have";
                msg = reason + " strengthened Blue's position";
                outputmsg += msg + Environment.NewLine;
                if (output) gpLogServerAndLog(recipients, msg, null);
            }
            MapMove += outside;
        }

        */

        //We can move AT MOST one notch (one map) in either direction, per mission
        //UPDATE 2020/02 - with persistent missions we are removing this restriction.  The objective points + bonus a team gets is
        //typically accumulated over many days/sessions.
        //if (MapMove > 1) MapMove = 1;
        //if (MapMove < -1) MapMove = -1;

        string word = "Currently, ";
        if (final) word = "Altogether, ";

        if (MapMove > 0)
        {
            string msg7 = word + "Red's campaign position is up " + (MapMove * 100).ToString("n0") + " points since the map last turned.";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;
        }
        if (MapMove < 0)
        {
            string msg7 = word + "Blue's campaign position is up " + (-MapMove * 100).ToString("n0") + " points since the map last turned.";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;
        }
        if (MapMove == 0)
        {
            /*
            string msg7 = word + "the campaign is at a COMPLETE STALEMATE since the map last turned!";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;  
            */
        }

        if (!firstMapMove_saved) firstMapMove = MapMove;

        double thisSessionMapMove = MapMove - firstMapMove;

        if (thisSessionMapMove > 0)
        {
            string msg7 = word + "Red's campaign position is up " + (thisSessionMapMove * 100).ToString("n0") + " points this session.";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;
        }
        if (thisSessionMapMove < 0)
        {
            string msg7 = word + "Blue's campaign position is up " + (-thisSessionMapMove * 100).ToString("n0") + " points this session.";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;
        }
        if (thisSessionMapMove == 0)
        {
            /*
            string msg7 = word + "the campaign is at a COMPLETE STALEMATE this session!";
            outputmsg += msg7 + Environment.NewLine;
            if (output) Timeout(delay_s, () => { gpLogServerAndLog(recipients, msg7, null); });
            delay_s += 0.04;
            */
        }



        return new Tuple<double, string>(MapMove, outputmsg);

    }

    public string summarizeCurrentMapstate(double ms, bool output = true, Player player = null)
    {
        string outputmsg = "";
        string msg = "";
        Player[] recipients = null;
        if (player != null) recipients = new Player[] { player };

        if (ms > 0)
        {
            msg = "Red stands at +" + (ms * 100).ToString("n0") + " for the entire " + CAMPAIGN_ID + " campaign.";
            outputmsg += msg + Environment.NewLine;
            if (output) gpLogServerAndLog(recipients, msg, null);
        }
        else if (ms < 0)
        {
            msg = "Blue stands at +" + (-ms * 100).ToString("n0") + " for the entire " + CAMPAIGN_ID + " campaign.";
            outputmsg += msg + Environment.NewLine;
            if (output) gpLogServerAndLog(recipients, msg, null);
        }
        else
        {
            msg = "The entire " + CAMPAIGN_ID + " campaign is exactly balanced. Blue stands at +0, Red +0.";
            outputmsg += msg + Environment.NewLine;
            if (output) gpLogServerAndLog(recipients, msg, null);
        }
        return outputmsg;
    }

    //saves the current map state to a text file as the first line.  Previous mapstates are in reverse order from the top down, each on one line.
    //Also, saves the previous version of the _MapState file as *_MapState_old.txt
    public bool MapStateSaved = false;
    public bool MapStateBackedUp = false;
    public double SaveMapState(string winner, bool intermediateSave = false, bool startupSave = false, bool intermediateWin = false, bool BumrushRepelOnly = false)
    {
        //Console.WriteLine("Map Save #0");
        Tuple<double, string> res = CalcMapMove(winner, true, true, null, BumrushRepelOnly: BumrushRepelOnly);
        if (!intermediateSave && MapStateSaved) return res.Item1; //Due to the way it works (adding a certain value to the value in the file), we can only save map state ONCE per session.  So we can call it a few times near the end to be safe, but it only will save once at most
        try
        {

            //Console.WriteLine("Map Save #1");
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX8 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping

            //Take care of updating Aircraft Supply here, based on Mission results
            //Also we can use the various failsafes in place to ensure mapsave happens, but no "double mapsave"
            //Same problem with Supply--we MUST save it once but can't save MORE THAN ONCE
            double misResult = res.Item1;
            double newMapState = CampaignMapState + misResult;
            string outputmsg = res.Item2;
            string msg = "";
            string turnString = "(none)";
            if (winner.Equals("Red") || winner.Equals("Blue")) turnString = winner;
            DateTime dt = DateTime.UtcNow;
            string date = dt.ToString("u");


            //Console.WriteLine("Map Save #2");

            bool writeOutput = true;
            //for testing
            if (intermediateSave && !intermediateWin) writeOutput = false;

            //In the case there is a winner NewMapState already includes the MissionObjectiveScore from CalcMapMove.  That is the ONLY time it is included
            //to prevent double-counting the objective points.
            if (winner != "Red" && winner != "Blue") outputmsg += summarizeCurrentMapstate(newMapState + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0, writeOutput);
            else outputmsg += summarizeCurrentMapstate(newMapState, writeOutput);


            //TODO: We could write outputmsg to a file or send it to the -stats.cs or something
            //This saves the summary text to a file with CR/LF replaced with <br> so it can be used in HTML page

            /*  (removing this save here since we have it in CheckStatsData();
            try
            {
                File.WriteAllText(STATSCS_FULL_PATH + "CampaignSummary.txt", Regex.Replace(outputmsg, @"\r\n?|\n", "<br>" + Environment.NewLine));
            }
            catch (Exception ex) { Console.WriteLine("CampaignSummary Write: " + ex.ToString()); }
            */
            string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapState.txt";
            string filepath_old = STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapState_old.txt";
            string currentContent = String.Empty;

            //Save most recent copy of Campaign Map Score with suffix _old
            try
            {
                if (File.Exists(filepath_old)) { File.Delete(filepath_old); }
                File.Copy(filepath, filepath_old);
            }
            catch (Exception ex) { Console.WriteLine("MapState Write Inner: " + ex.ToString()); }


            //Console.WriteLine("Map Save #3");

            //if (File.Exists(filepath)) { File.Delete(filepath); }
            /*fi = new System.IO.FileInfo(filepath); //file to write to
            sw = fi.CreateText();
            sw.WriteLine(newMapState.ToString());
            sw.Close(); */

            if (File.Exists(filepath))
            {
                currentContent = File.ReadAllText(filepath);
            }
            //TODO: We could trim currentContent to some certain length or whatever
            //currentContent = currentContent.Split(Environment.NewLine.ToCharArray()).FirstOrDefault(); //cut down prev content to max of 20 lines
            //currentContent = String.Join(Environment.NewLine, currentContent.Split(Environment.NewLine.ToCharArray(), 21).Take(20)); //cut down prev content to max of 20 lines

            //Console.WriteLine("Map Save #4");

            currentContent = String.Join(Environment.NewLine, currentContent.Split(Environment.NewLine.ToCharArray(), StringSplitOptions.RemoveEmptyEntries).Where(x => !string.IsNullOrWhiteSpace(x))
                .Select(s => s.Trim()).Take(150)); //cut down prev content to max of $X lines & omit blank lines
            //File.WriteAllText(filepath, newMapState.ToString() + Environment.NewLine + turnString + Environment.NewLine + date + Environment.NewLine + currentContent);
            Calcs.WriteAllTextAsync(filepath, newMapState.ToString() + Environment.NewLine + turnString + Environment.NewLine + date + Environment.NewLine + currentContent);
            if (!intermediateSave) MapStateSaved = true;

            //So in the case of an intermediate win, we update the currently running CampaignMapState with the NewMapState reflecting the win.
            //This is the ONLY time we ever do this.
            //It may need refinement as it is also adding in winnings for the losing time (a little) and they will be double counted.
            //Some winnings for the winning team might be double counted, too, but that might be OK ?
            if (intermediateWin) CampaignMapState = newMapState;

            //Update supplies/resupply, but only at the very end OR when there is an intermediate win (we add supply to the winner; don't do anything to the other team for intermediate win)
            if (!intermediateSave || intermediateWin)
            {

                try
                {
                    double pcDone = calcProportionTimeComplete();

                    //This adds supply in based on how many players participated and how long the mission ran (15.5 hrs generally) as a basis
                    //then adjusting based on score & whether anyone has turned the map
                    int netRedCount = 15;
                    int netBlueCount = 15;

                    //if (TWCStatsMission != null)
                    //{
                    //Counting lines in <netstats summary from -stats.cs to get an approximation of how many active pilots there were in-game
                    //string netRed = TWCStatsMission.Display_SessionStatsAll(null, 1, false, true); //last true = NEED html version bec we're counting <br>s
                    string netRed = statsmission.Display_SessionStatsAll(null, 1, false, true); //last true = NEED html version bec we're counting <br>s
                    //string netBlue = TWCStatsMission.Display_SessionStatsAll(null, 2, false, true);
                    string netBlue = statsmission.Display_SessionStatsAll(null, 2, false, true);
                    netRed = netRed.Replace(@"***No Netstats to report***<br>", "");
                    //netRed.Replace()
                    netBlue = netBlue.Replace(@"***No Netstats to report***<br>", "");
                    //netBlue = netBlue.Replace(@"No Nets", "");
                    string target = "<br>";//Q&D way to count how many pilots active during the mission
                    Console.WriteLine("NR " + netRed);
                    Console.WriteLine("NR " + netBlue);
                    netRedCount = netRed.Select((c, i) => netRed.Substring(i)).Count(sub => sub.StartsWith(target)) - 1;
                    netBlueCount = netBlue.Select((c, i) => netBlue.Substring(i)).Count(sub => sub.StartsWith(target)) - 1;
                    //}

                    Console.WriteLine("Main-ReSupply: " + netRedCount.ToString() + " " + netBlueCount.ToString());
                    if (netRedCount < 0) netRedCount = 0;
                    if (netBlueCount < 0) netBlueCount = 0;
                    if (netRedCount > 120) netRedCount = 120;
                    if (netBlueCount > 120) netBlueCount = 120;
                    //Take care of changes to supply
                    double redMult = pcDone / 8.0 + 7.0 / 8.0 * pcDone * netRedCount / 20.0 + RedScoutedObjectivesI / 400.0;  //must cast to double first . . .
                    double blueMult = pcDone / 8.0 + 7.0 / 8.0 * pcDone * netBlueCount / 20.0 + BlueScoutedObjectivesI / 400.0; //Now also add some 'plane points' for reconnaissance, just a little bit

                    Console.WriteLine("Main-ReSupply: " + netRedCount.ToString() + " " + netBlueCount.ToString() + " " + redMult.ToString() + " " + blueMult.ToString() + " "
                        + redMultAdmin.ToString() + " " + blueMultAdmin.ToString() + " ");

                    //if one side turns the map they get a large increase in aircraft supply while the other side gets little or nothing
                    //if they don't turn the map there is still a slight tweak give the side with more overall victories a few more aircraft 
                    if (winner == "Red") { redMult += 4.0; blueMult = 0.01; } //2020/02 - now ADDING the bonus 4.0 points instead of just replacing the normal value
                    else if (winner == "Blue") { blueMult += 4.0; redMult = 0.01; }
                    else if (misResult > 0) redMult += misResult / 100.0;
                    else if (misResult < 0) blueMult += (-misResult) / 100.0;
                    redMult += redMultAdmin;
                    blueMult += blueMultAdmin;

                    //this is a weird kludge so that we can handle intermediate wins & supply restocks.
                    //The army set to the magic number has no change to their stock
                    //Also if this is set for either, the regular "end of mission" things won't happen @ Supply
                    double magicNumber = -1000000;
                    if (winner == "Red") blueMult = magicNumber;
                    if (winner == "Blue") redMult = magicNumber;

                    if (TWCSupplyMission != null) TWCSupplyMission.SupplyEndMission(redMult, blueMult);

                    Console.WriteLine("Main-ReSupply: " + netRedCount.ToString() + " " + netBlueCount.ToString() + " " + redMult.ToString() + " " + blueMult.ToString() + " "
                        + redMultAdmin.ToString() + " " + blueMultAdmin.ToString() + " ");

                } catch (Exception ex) { Console.WriteLine("MapState Supply Save ERROR: " + ex.ToString()); }
            }

            //Save mapstate to special directory once @ beginning of mission & again at very end, or if there is an intermediate/rolling win
            if (!MapStateBackedUp || !intermediateSave || intermediateWin)
            {

                var backPath = STATSCS_FULL_PATH + CAMPAIGN_ID + @" campaign backups\";
                string filepath_date = backPath + CAMPAIGN_ID + "_MapState-" + dt.ToString("yyyy-MM-dd") + ".txt";

                //Create the directory for the MapState.txt backup files, if it doesn't exist
                if (!System.IO.File.Exists(backPath))
                {

                    try
                    {
                        //System.IO.File.Create(backPath);
                        System.IO.Directory.CreateDirectory(backPath);
                    }
                    catch (Exception ex) { Console.WriteLine("MapState Dir Create Date ERROR: " + ex.ToString()); }

                }

                //Save most recent copy of Campaign Map Score with suffix like  -2018-05-13.txt
                try
                {
                    if (File.Exists(filepath_date)) { File.Delete(filepath_date); }
                    File.Copy(filepath, filepath_date);
                    MapStateBackedUp = true;
                }
                catch (Exception ex) { Console.WriteLine("MapState Write Date: " + ex.ToString()); }

            }


            if (intermediateSave && intermediateWin)
            {
                CheckStatsData(winner);

                //saves file async, best to wait a bit before calling the stats routine to add all that info to the team stats page
                //Cleverer solution might be better
                Timeout(1, () =>
                {
                    statsmission.Stb_SaveAllStatsMapTurnOrFinal(immediate_save: true, intermediate_win: true); // not sure if this needs to be here or elsewhere????
                });
            }


        }
        catch (Exception ex) { Console.WriteLine("MapState Write: " + ex.ToString()); }

        return res.Item1; //mapmove score for *this mission*

    }

    public string GetMapSuffix()
    {
        double MapState = GetMapState();
        int MapState_int = Convert.ToInt32(MapState);
        if (MapState_int > CampaignMapMaxRedSuffixMax) MapState_int = CampaignMapMaxRedSuffixMax;
        if (-MapState_int > CampaignMapMaxBlueSuffixMax) MapState_int = -CampaignMapMaxBlueSuffixMax;

        if (MapState_int == 0) return "-0";
        if (MapState_int > 0) return "-R" + MapState_int.ToString("D3");  //3 digits so that our files will be named ie TWC M001-initairports-R002.mis - 002 is 3 digits
        else return "-B" + (-MapState_int).ToString("D3");
    }

    public double GetMapState()
    {

        double MapState = 0;
        string res = "";

        try
        {
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX2 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
            using (StreamReader sr = new StreamReader(STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapState.txt"))
            {
                res = sr.ReadLine();
                MapState = Convert.ToDouble(res); //Total overall score; 0=tied, + = Red winning, - = Blue winning
                string prevWinner = sr.ReadLine();
                if (prevWinner == "Red" || prevWinner == "Blue") MapPrevWinner = prevWinner.Trim(); //Winner of previous mission, if there was one.

            }
        }
        catch (Exception ex)
        {
            System.Console.WriteLine("Main mission - read mapstate - Exception: " + ex.ToString());
            MapState = 0;
        }

        Console.WriteLine("Main mission - read mapstate: " + MapState.ToString() + " " + res + " : " + STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapState.txt");

        if (MapState > 100000 || MapState < -100000) MapState = 0;
        CampaignMapState = MapState;
        return MapState;


    }
    /*  SAMPLE front markers

            FrontMarker0 122130.41 99692.54 1
          FrontMarker1 184923.58 199248.64 1
          FrontMarker2 151050.02 106909.01 1
          FrontMarker3 273615.78 251329.87 1
          FrontMarker4 318170.97 309361.61 1
          FrontMarker5 355340.23 298205.35 2
          FrontMarker6 284329.09 226250.35 2
          FrontMarker7 195643.43 103278.12 2
          FrontMarker8 88262.03 60001.96 2
          FrontMarker9 113282.01 85097.34 2
          FrontMarker10 341348.18 266004.67 2
          FrontMarker11 225658.13 150675.90 1
          FrontMarker12 253901.90 109419.35 2
          FrontMarker13 163783.69 109004.79 1
          FrontMarker14 189714.23 113052.10 1
          FrontMarker15 249954.27 141364.45 2
          FrontMarker16 171903.52 90341.35 2
          FrontMarker17 102887.45 94353.53 1
          FrontMarker18 94502.66 92980.57 1
          FrontMarker19 259759.88 188769.38 2
  FrontMarker20 230005.07 198916.29 1

        */
    public void DrawFrontLinesPerMapState(double minMapState = -25, double maxMapState = 25, double? currMapState = null, string saveName = null)
    {
        
        return; //skipping this entire FOR NOW 2020/08

        Task.Run(() =>
        {
            //so because of CloD weirdness, the lines need to go pretty much perpendicular to the dividing line between france & england.
            //To make the points, go into FMB, choose points WIDE apart, as wide as possible, opposite each other at the furthest
            //extremes of where the front lines will range--one furthest to the blue side, the other furthest to the red side
            //Choose the points in pairs (red side/blue side), and make them so that the resulting front line in the middle is
            //nice and smooth.
            //Then export those points from FMB, arrange them in order (left to right or whatever along the front line; FMB will likely scramble
            //them up) and then put them into the format below.


            List<List<Point2d>> frontPoints = new List<List<Point2d>>() {




            new List<Point2d>() {
                new Point2d (12535.86,80190.73), //furthest extreme point blue side (south side) of the channel
                new Point2d (10618.86,166919.06), //furthest extreme point red side (north side) of the channel - starting at the west end of the map
            
                    },

            new List<Point2d>() {
                new Point2d (45083.75,77280.85), //blue side
                new Point2d (43448.8,175135.64), //next points moving east, red side
            
            },

            new List<Point2d>() {
                new Point2d (61680.21,74914.15),
                new Point2d (63424.7,167040.97), //etc
            
            },

            new List<Point2d>() {
                new Point2d (78249.54,58702.71),
                new Point2d (83910.49,175416.5),
            
            },

            new List<Point2d>() {
                new Point2d (100949.88,42579.64),
                new Point2d (99733.32,184877.35),            
            },

            new List<Point2d>() {
                new Point2d (126336,42672),
                new Point2d (110400,190272),
            },

            new List<Point2d>() {
            
                new Point2d (154214.29,61859.85),
                new Point2d (118688.29,190680.54),
            },

            new List<Point2d>() {
            
                new Point2d (159814.69,76825.13),
                new Point2d (131659.66,192833.41),
            },

            new List<Point2d>() {
            
                new Point2d (180864,89088),
                new Point2d (153984,192960),
            },

            new List<Point2d>() {
            
                new Point2d (190864,93588),
                new Point2d (163984,189460),
            },

            new List<Point2d>() {
            
                new Point2d (205056,97152),
                new Point2d (172992,185856),
            },

            new List<Point2d>() {
            
                new Point2d (231006.05,105485.13),
                new Point2d (179601.02,194613.41),
            },

            new List<Point2d>() {
                new Point2d (248621.26,119111.73),
                new Point2d (188597.32,199130.55),
            
            },

            new List<Point2d>() {
                new Point2d (258624,136320),
                new Point2d (202752,202944),
            
            },

            new List<Point2d>() {
            
                new Point2d (262080,165696),
                new Point2d (209664,209280),
            },

            new List<Point2d>() {
            
                new Point2d (262848,180672),
                new Point2d (216576,209088),
            },

            new List<Point2d>() {
            
                new Point2d (262894.58,192305.62),
                new Point2d (223385.59,208849.89),
            },

            new List<Point2d>() {
            
                new Point2d (264038.59,205787.15),
                new Point2d (227862.38,225744.41),
            },

            new List<Point2d>() {
            
                new Point2d (272136.04,212438.45),
                new Point2d (247504.44,234638.61),
            },

            new List<Point2d>() {
            
                new Point2d (281884.35,218378.42),
                new Point2d (251813.55,243841.49),
            },

            new List<Point2d>() {
            
                new Point2d (291874.9,221379.32),
                new Point2d (258959.67,254735.81),
            },

            new List<Point2d>() {
            
                new Point2d (302380.94,224076.27),
                new Point2d (255327.62,266250.02),
            },

            new List<Point2d>() {
            
                new Point2d (313365.97,227043.45),
                new Point2d (246498.73,285932.92),
            },

            new List<Point2d>() {
            
                new Point2d (325633.59,229383.98),
                new Point2d (250024.27,298217.73),
            },

            new List<Point2d>() {
            
                new Point2d (337857.27,235244.12),
                new Point2d (269866.47,310981.62),
            },

            new List<Point2d>() {
            
                new Point2d (347077.23,240365.27),
                new Point2d (302280.98,312446.52),
            },

            new List<Point2d>() {
            
                new Point2d (352757.32,244599.01),
                new Point2d (329328.93,313006.78),
            },

            new List<Point2d>() {
            
                new Point2d (358080,247296),
                new Point2d (352896,313536),
            },
            

        };

            ISectionFile f = GamePlay.gpCreateSectionFile();
            string sect;
            string key;
            string value;
            int count = 0;

            double mapState = CampaignMapState;
            if (currMapState.HasValue) mapState = currMapState.Value;
            double neutral = (maxMapState - minMapState) / 120;

            double mult = (mapState - neutral - minMapState) / (maxMapState - minMapState);  //mult is for red frontline (most northerly)
            double mult2 = (mapState + neutral - minMapState) / (maxMapState - minMapState);  //mult2 for blue, most southerly 
            if (mult > 1) mult = 1; //We COULD go beyond 0-1 but that might get weird.  So the Frontlines are drawn using a weird thing where the front goes halfway between p1 and p2 and PERPENDICULAR to the line from p1 to p2.  So we have to pay attention to make sure p1 & p2 form the right sort of line going the right direction.
            if (mult < 0) mult = 0;
            if (mult2 > 1) mult2 = 1; //We COULD go beyond 0-1 but that might get weird
            if (mult2 < 0) mult2 = 0;
            if (mult2 == mult) mult2 = mult + 0.05; //They can't be equal or HELP!!! So it's better to be a bit above 1 than equal.

            List<Point2d> lastPoints = null;

            foreach (List<Point2d> initpoints in frontPoints)
            {
                List<List<Point2d>> newPoints = new List<List<Point2d>>();


                //complicated little business to linearly interpolate one or perhaps several new points in between each existing point.
                //This helps smooth out the boundary A LOT.
                if (lastPoints != null)
                {
                    double numPointsToInterpolate = 3;

                    for (int i = 1; i < numPointsToInterpolate; i++)
                    {
                        //Console.WriteLine("PTI: {0} {1}", i, numPointsToInterpolate);
                        double id = (double)i;
                        List<Point2d> newPoint = new List<Point2d>();
                        newPoint.Add(new Point2d(id * (initpoints[0].x - lastPoints[0].x) / numPointsToInterpolate + lastPoints[0].x, id * (initpoints[0].y - lastPoints[0].y) / numPointsToInterpolate + lastPoints[0].y));
                        newPoint.Add(new Point2d(id * (initpoints[1].x - lastPoints[1].x) / numPointsToInterpolate + lastPoints[1].x, id * (initpoints[1].y - lastPoints[1].y) / numPointsToInterpolate + lastPoints[1].y));
                        newPoints.Add(newPoint);
                    }
                }

                newPoints.Add(initpoints);

                foreach (List<Point2d> points in newPoints)
                {

                    double dist = Calcs.CalculatePointDistance(points[0], points[1]);

                    double x = mult * points[1].x + (1 - mult) * points[0].x;  //linear interpolation between the two given points, based on how far we currently are between the min & max map state
                    double y = mult * points[1].y + (1 - mult) * points[0].y;
                    double x2 = mult2 * points[1].x + (1 - mult2) * points[0].x;  //linear interpolation between the two given points, based on how far we currently are between the min & max map state
                    double y2 = mult2 * points[1].y + (1 - mult2) * points[0].y;

                    sect = "FrontMarker";
                    key = "FrontMarker" + count.ToString();
                    value = x.ToString("F2") + " " + y.ToString("F2") + " 1"; //1 = army 1
                    f.add(sect, key, value);

                    //Console.WriteLine("({0:F0}, {1:F0}) - ({2:F0}, {3:F0})", x, y, x2, y2);
                    count++;
                    y += 1000;
                    key = "FrontMarker" + count.ToString();
                    value = x2.ToString("F2") + " " + y2.ToString("F2") + " 2";
                    f.add(sect, key, value);
                    count++;
                }

                lastPoints = initpoints;

            }
            saveName = "frontfile.txt";
            Timeout(random.NextDouble() * 10, () =>
            {
                GamePlay.gpPostMissionLoad(f);
            });
            if (saveName != null) f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/" + saveName); //testing
            Console.WriteLine("Drew current frontline");
        });


    }

    /******************************************************************************
     * 
     * END - LONG-TERM CAMPAIGN METHODS 
     *    
     ******************************************************************************/

    /*************************
     * ONACTORDEAD
     * **********************/

    public override void OnActorDead(int missionNumber, string shortName, AiActor actor, List<DamagerScore> damages)
    {
        base.OnActorDead(missionNumber, shortName, actor, damages);
        try
        {

            if (actor as Player != null)
            {
                MO_SpoilPlayerScoutPhotos(actor as Player);
            }

            try
            {
                MO_HandlePointAreaObjectives(actor, damages); //remembered, don't overdo it with creating many new threads @ once, as can happen with onXkilled
                MO_makeAllObjectivesScoutedFromPos(actor.Pos(), null);
            }
            catch (Exception ex) { Console.WriteLine("OnActorDead - HandlePAO: " + ex.ToString()); }

        if (actor != null && actor is AiAircraft)
            {
                //if dead, then destroy it within a reasonable time
                AiAircraft aircraft = actor as AiAircraft;

                MO_SpoilPlayerScoutPhotos(playersInPlane(aircraft));

                string pName = actor.Name();
                if (aircraft != null)
                {
                    //Timeout(300, () =>
                    Timeout(20, () => //testing
                    {
                        //Force a player into a certain place:
                        //Player.Place() = (Actor as AiAircraft).Place(placeIndex);
                        if (aircraft.Places() > 0) for (int i = 0; i < aircraft.Places(); i++)
                            {
                                //aircraft.Player(i).Place() = null;
                                //aircraft.Player(i).PlaceEnter(null,0);
                                if (aircraft.Player(i) != null) aircraft.Player(i).PlaceLeave(i);
                            }

                        //Wait 0.5 second for player(s) to leave, then destroy
                        Timeout(0.5, () =>
                        {
                            Console.WriteLine("Destroyed dead aircraft " + pName + " " + aircraft.Type());
                            destroyPlane(aircraft);  //Destroy completely when dead, after a reasonable time period.

                        });

                    });
                }

            }

            if (actor != null && actor is AiGroundActor)
            {
                //If we destroy dead ground objs too soon then eg big oil refinery fires will go out after just a few minutes
                //Ideally we'd have a filter of some time here to destroy smaller items pretty soon but other bigger ones after a longer time
                Timeout(90 * 60, () =>
                {
                    (actor as AiGroundActor).Destroy();
                    Console.WriteLine("Destroyed dead ground object " + actor.Name());

                });

                Console.WriteLine("Ground object has died. Name: " + actor.Name());

            }



        }
        catch (Exception ex) { Console.WriteLine("OPD: " + ex.ToString()); }
    }

    /*************************
     * ONPERSONHEALTH
     * **********************/
    public override void OnPersonHealth(maddox.game.world.AiPerson person, maddox.game.world.AiDamageInitiator initiator, float deltaHealth)
    {
        #region stats
        base.OnPersonHealth(person, initiator, deltaHealth);
        try
        {
            //twcLogServer(null, "Health Changed for " + person.Player().Name(), new object[] { });
            if (person != null)
            {
                Player player = person.Player();
                //if (deltaHealth>0 && player != null && player.Name() != null) {
                if (player != null && player.Name() != null)
                {
                    if (DEBUG) twcLogServer(null, "Main: OnPersonHealth for " + player.Name() + " health " + player.PersonPrimary().Health.ToString("F2"), new object[] { });
                    //if the person is completely dead we are going to force them to leave their place
                    //This prevents zombie dead players from just sitting in their planes interminably, 
                    //which clogs up the airports etc & prevents the planes from dying & de-spawning
                    //Not really sure the code below is working.
                    if (player.PersonPrimary() != null && player.PersonPrimary().Health == 0
                        && (player.PersonSecondary() == null
                            || (player.PersonSecondary() != null && player.PersonSecondary().Health == 0)))
                    {
                        //Timeout(300, () =>
                        if (DEBUG) twcLogServer(null, "Main: 2 OnPersonHealth for " + player.Name(), new object[] { });
                        Timeout(20, () => //testing
                        {
                            if (DEBUG) twcLogServer(null, "Main: 3 OnPersonHealth for " + player.Name(), new object[] { });
                            //Checking health a second time gives them a while to switch to a different position if
                            //it is available
                            if (player.PersonPrimary() != null && player.PersonPrimary().Health == 0
                                && (player.PersonSecondary() == null
                                    || (player.PersonSecondary() != null && player.PersonSecondary().Health == 0)))
                            {
                                if (DEBUG) twcLogServer(null, "Main: 4 OnPersonHealth for " + player.Name(), new object[] { });

                                //Not really sure how this works, but this is a good guess.  
                                //if (player.PersonPrimary() != null )player.PlaceLeave(0);
                                //if (player.PersonSecondary() != null) player.PlaceLeave(1);
                                if (player.PersonPrimary() != null) player.PlaceLeave(player.PersonPrimary().Place());
                                if (player.PersonSecondary() != null) player.PlaceLeave(player.PersonSecondary().Place());
                            }
                            if (DEBUG) twcLogServer(null, player.Name() + " died and was forced to leave player's current place.", new object[] { });

                            if (DEBUG) twcLogServer(null, "Main: OnPersonHealth for " + player.Name() + " health1 " + player.PersonPrimary().Health.ToString("F2")
                                    + " health2 " + player.PersonSecondary().Health.ToString("F2"), new object[] { });

                        });

                    }

                }
            }
        }
        catch (Exception ex)
        {
            System.Console.WriteLine("Main.OnPersonHealth - Exception: " + ex.ToString());
        }
        #endregion

    }


    public override void OnAircraftCrashLanded(int missionNumber, string shortName, AiAircraft aircraft)
    {
        base.OnAircraftCrashLanded(missionNumber, shortName, aircraft);

        MO_SpoilPlayerScoutPhotos(playersInPlane(aircraft));

        Timeout(300, () =>
        //{ destroyPlane(aircraft); } //Not sure why to destory all planes just bec. crash landed?  Best to check if a pilot is still in it & just destroy aicontrolled planes, like this:

        { destroyAiControlledPlane(aircraft); }
            );
    }
    public override void OnAircraftLanded(int missionNumber, string shortName, AiAircraft aircraft)
    {
        base.OnAircraftLanded(missionNumber, shortName, aircraft);



        Timeout(300, () =>
        //{ destroyPlane(aircraft); } //Not sure why to destory **ALL** planes just bec. landed?  Best to check if a pilot is still in it & just destroy aicontrolled planes, like this:

        { destroyAiControlledPlane(aircraft); }
            );

        try
        {
            if (GamePlay == null) return;
            if (GamePlay.gpFrontArmy((aircraft as AiActor).Pos().x, (aircraft as AiActor).Pos().y) == (aircraft as AiActor).Army())

                MO_RecordPlayerScoutPhotos(playersInPlane(aircraft));
        }
        catch (Exception ex) { System.Console.WriteLine("Main mission OnAircraftLanded recon record - Exception: " + ex.ToString()); }

    }

    public override void OnPersonParachuteFailed(maddox.game.world.AiPerson person)
    {
        base.OnPersonParachuteFailed(person);
        if (person.Player() != null) MO_SpoilPlayerScoutPhotos(person.Player());
    }

    public override void OnPersonParachuteLanded(maddox.game.world.AiPerson person)
    {
        base.OnPersonParachuteLanded(person);
        if (person.Player() != null) MO_SpoilPlayerScoutPhotos(person.Player());
    }

    public override void OnAircraftTookOff(int missionNumber, string shortName, AiAircraft aircraft)
    {
        base.OnAircraftTookOff(missionNumber, shortName, aircraft);
        MO_SpoilPlayerScoutPhotos(playersInPlane(aircraft));
    }

    //this will destroy ALL ai controlled aircraft on the server
    public void destroyAIAircraft(Player player)
    {

        //Task.Run(() =>
        {

            //List<Tuple<AiAircraft, int>> aircraftPlaces = new List<Tuple<AiAircraft, int>>();
            if (GamePlay != null && GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
            {
                foreach (int army in GamePlay.gpArmies())
                {
                    if (GamePlay.gpAirGroups(army) != null && GamePlay.gpAirGroups(army).Length > 0)
                    {
                        foreach (AiAirGroup airGroup in GamePlay.gpAirGroups(army))
                        {
                            if (airGroup != null && airGroup.GetItems() != null && airGroup.GetItems().Length > 0)
                            {
                                foreach (AiActor actor in airGroup.GetItems())
                                {
                                    if (actor is AiAircraft)
                                    {
                                        AiAircraft a = actor as AiAircraft;
                                        if (a != null && isAiControlledPlane2(a))
                                        {


                                           twcLogServer(new Player[] { player }, "DEBUG: Destroying: Airgroup: " + a.AirGroup() + " "                                          
                                             + a.Type() + " " 
                                             + a.TypedName() + " " 
                                             +  a.AirGroup().ID(), new object[] { });
                                            
                                            Timeout(random.NextDouble() * 10, () =>
                                            {
                                                a.Destroy();
                                            });

                                        }


                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #region onbuildingkilled

    //OnBuildingKilled only works on offline servers
    //UPDATE. It is supposed to work in TF 4.57.  Only for individually/.mis-placed buildings however, not for the built-in in-game buildings
    //A few (random?) buildings also report to this routine in the multiplayer/online servers

    /*
     * 
     * SUMMARY OF ONBUILDINGKILLED AND TRIGGER (VIA BUILDINGS, DIFFERENT SUBMISSIONS) SITUATION AS OF 2020/02 - TF4.57
     * 
     TWC_Flug: #1. OnBuildingKilled only works with AI aircraft.  Works perfectly with them.  Anything I killed--never reported.  I have it turned on in the server now (it would, for example, save stats for a player who took out a certain building) but it won't report anything except AI kills as near as I can see.
        [1:41 AM] TWC_Flug: It is exactly as reported here: https://theairtacticalassaultgroup.com/forum/showthread.php?t=31359
        OnBuildingKilled() Issues
        So with reference to the repaired OnBuildingKilled() script function and the usage of the following script: 

        public override void OnBuildingKilled(string title, Point3d pos, AiDamageInitiator initiator, int eventArgInt) { 

        string parts = title.Split(new string { SEP...
        [1:42 AM] TWC_Flug: #2. Building kills definitely do not count towards setting off a trigger.  Even when the AI hit it and it registers.  Still, no matter how hard you hit it, no trigger.
        [1:43 AM] TWC_Flug: #3. Also I tried putting stationary objects in an area, using a submission.  I tried putting the trigger in the submission and seeing if the -main.cs script would detect it.  No.
        [1:43 AM] TWC_Flug: (Presumably you could put a little trigger detector in -submission.cs, that would detect it, then you could pass it to -main.cs.  So, possibly but painful.)
        [1:45 AM] TWC_Flug: #3. Then I tried putting the stationary objects in the submission but the trigger in the main.mis file.  I was hoping the trigger would trigger off of ANY stationary or other object in its radius, no matter what submission it was loaded from.  But no dice.  It doesn't respond even if you have killed every last one of those objects, if they are loaded from a submission file rather than the main mission file.
        [1:45 AM] TWC_Flug: So all that is kind of disappointing.  Our -stats script works by detecting any and all stationaries from any and all missions, and it works just fine.  But the built-in triggers just don't do that.
        [1:47 AM] TWC_Flug: That's one reason I think it might be better to just roll our own "simulated trigger" using some special object to indicate where the trigger area is.  You could detect any and all stationaries, buildings, or just ground explosions that happen within X distance of that special object and then that works exactly like a trigger but we're in control of exactly how it works.
        [1:48 AM] TWC_Flug: We couldn't have to keep track of the object's ID# as we were doing before.  Instead, you just keep track of it's X/Y position.  Which you want/need to know anyway.

     */

    public override void OnBuildingKilled(string title, Point3d pos, AiDamageInitiator initiator, int eventArgInt)
    {
        base.OnBuildingKilled(title, pos, initiator, eventArgInt);

        //try
        {
            Console.WriteLine("BUILDING:" + title + " at " + pos.x.ToString("F0") + ", " + pos.y.ToString("F0"));

            //Task.Run(() => //AHA, DON'T task.run here as it blows up the threads massively

            double wait = stb_random.NextDouble() * 25;
            Timeout(wait, () => 
                MO_HandlePointAreaObjectives(null, initiator, title, pos) //handle building killed within PointArea area
            );
            string BuildingName = title;
            string BuildingArmy = "";
            string PlayerArmy = "Unknown/AI";
            string sectorTitle = "";
            string sectorName = GamePlay.gpSectorName(pos.x, pos.y);

            if (GamePlay.gpFrontArmy(pos.x, pos.y) == 1)
            {
                BuildingArmy = "England";
            }
            else if (GamePlay.gpFrontArmy(pos.x, pos.y) == 2)
            {
                BuildingArmy = "France";
            }
            else
            {
                BuildingArmy = "Neutral";
            }
            if (initiator != null && initiator.Player as Player != null)
            {
                if (initiator.Player.Army() == 1)
                {
                    PlayerArmy = "RAF";
                }
                else if (initiator.Player.Army() == 2)
                {
                    PlayerArmy = "Luftwaffe";
                }
                else
                {
                    PlayerArmy = "Unknown";
                }
            }
            else if (initiator != null && initiator.Actor as AiActor != null)
            {
                if (initiator.Actor.Army() == 1)
                {
                    PlayerArmy = "RAF";
                }
                else if (initiator.Actor.Army() == 2)
                {
                    PlayerArmy = "Luftwaffe";
                }
                else
                {
                    PlayerArmy = "Unknown (AI)";
                }
            }

            string killerName = "(AI)";
            if (initiator != null && initiator.Player != null) killerName = initiator.Player.Name();
            else if (initiator != null && initiator.Actor != null) killerName = initiator.Actor.Name();

            Console.WriteLine("BUILDING:" + BuildingName + " in " + BuildingArmy + " was destroyed in sector " + sectorName + " by " + killerName + " from the " + PlayerArmy + ".");
        }
        //catch (Exception ex) { Console.WriteLine("Main OnBuildingKilled ERROR: " + ex.ToString()); };

    }


    #endregion

    double nearAirGroupThreshhold_m = 7500;
    double nearAirGroupAltThreshhold_m = 2000;
    //public enum aiorhuman { AI, Mixed, Human };

    public class AirGroupInfo : IAirGroupInfo
    {
        public double time { get; set; } //Battle.time.current;
        public HashSet<AiAirGroup> nearbyAirGroups { get; set; }// = new HashSet<AiAirGroup>();  // { get; set; } //those groups that are nearby OR near any nearby aircraft of the same type (greedy)
        public HashSet<AiAirGroup> groupedAirGroups { get; set; } // = new HashSet<AiAirGroup>(); //{ get; set; } //groups that have been nearby for that past X iterations, thus counting as part of the same Group
        public Point3d pos { get; set; }
        public Point3d vel { get; set; }
        public bool belowRadar { get; set; }
        public double altAGL_ft { get; set; }
        public double altAGL_m { get; set; }
        public int count { get; set; }
        public string type { get; set; }
        public bool isHeavyBomber { get; set; }
        public bool isAI { get; set; }
        public string playerNames { get; set; }
        public AiActor actor { get; set; }
        public AiAirGroup airGroup { get; set; }
        public bool isLeader { get; set; }
        public AiAirGroup leader { get; set; }
        public string sector { get; set; }
        public string sectorKeyp { get; set; }
        public int giantKeypad { get; set; }




        //Above are individual airgroup/aircraft values - below are the composite values for the entire airgroup ("Air Group Grouping" - AGG) - in case this is the leader of the grouping.  Otherwise blank/default
        public Point3d AGGpos { get; set; }    //exact loc of the primary a/c
        public Point3d AGGavePos { get; set; } //average loc of all a/c      
        public string AGGsector { get; set; }
        public string AGGsectorKeyp { get; set; }
        public int AGGgiantKeypad { get; set; }
        public Point3d AGGvel { get; set; }
        public int AGGcount { get; set; } //total # in group, including all above & below radar
        public int AGGcountAboveRadar { get; set; } //if countAboveRadar is 0 this group won't show up at all.  This is the count that shows to ordinary players
        public int AGGcountBelowRadar { get; set; }
        public bool AGGradarDropout { get; set; }
        public double AGGminAlt_m { get; set; }
        public double AGGmaxAlt_m { get; set; }
        public double AGGaveAlt_m { get; set; }
        public double AGGavealtAGL_ft { get; set; }
        public string AGGtypeNames { get; set; }
        public string AGGplayerNames { get; set; }
        public string AGGids { get; set; }  //the actor.Name()s compiled into a string
        public aiorhuman AGGAIorHuman { get; set; }
        public string AGGtype { get; set; }    //the actual type: "F" or "B".
        public string AGGmixupType { get; set; } //the type that will actually display on user radar, which is sometimes/often "mixed up".  "F" "B" or "U" for unknown
        public bool AGGisHeavyBomber { get; set; }
        public AMission mission { get; set; }



        public AirGroupInfo()
        {

        }

        public AirGroupInfo(AiActor a, AiAirGroup aag, Point3d p, Point3d v, int c, string ty, bool i, HashSet<AiAirGroup> nag, Mission msn, double tm)
        {
            actor = a;
            pos = p;
            vel = v;
            count = c;
            type = ty;
            isHeavyBomber = i;
            nearbyAirGroups = nag;
            time = tm;
            nearbyAirGroups.Add(aag); //always add self

        }
        public AirGroupInfo(AiActor act, AiAirGroup ag, Mission msn, double tm)
        {
            //Console.WriteLine("AGI 1");
            if (ag == null || act == null || act as AiAircraft == null) return;
            try
            {

                nearbyAirGroups = new HashSet<AiAirGroup>();  // { get; set; } //those groups that are nearby OR near any nearby aircraft of the same type (greedy)
                groupedAirGroups = new HashSet<AiAirGroup>(); //{ get; set; } //groups that have been nearby for that past X iterations, thus 

                AiAircraft a = act as AiAircraft;
                actor = act;
                airGroup = ag;
                //Console.WriteLine("AGI 2");
                nearbyAirGroups.Add(ag); //always add self
                time = tm;
                //Console.WriteLine("AGI 3");
                isAI = msn.isAiControlledPlane2(a);
                if (isAI) AGGAIorHuman = aiorhuman.AI;
                else AGGAIorHuman = aiorhuman.Human;
                count = airGroup.NOfAirc;
                AGGcount = count;
                mission = msn;
                if (isAI)
                {
                    playerNames = actor.Name();
                    AGGplayerNames = actor.Name();
                }
                else
                {
                    bool first = true;
                    string aplayername = "";
                    /*
                    if (a.Player(0) != null && a.Player(0).Name() != null)
                    {
                        aplayername = a.Player(0).Name();
                    }
                    */
                    for (int i = 0; i < a.Places(); i++)
                    {
                        if (a.Player(i) != null && a.Player(i).Name() != null)
                        {
                            if (!first) aplayername += " - ";
                            aplayername += a.Player(i).Name();
                            first = false;

                        }
                    }
                    playerNames = aplayername;
                    AGGplayerNames = playerNames;
                }

                AGGtypeNames = Calcs.GetAircraftType(a);



                //if (!player_place_set &&  (a.Place () is AiAircraft)) {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"


                //bool isAI = isAiControlledPlane2(a);
                //Console.WriteLine("AGI 4");
                string acType = Calcs.GetAircraftType(a);
                isHeavyBomber = false;
                if (acType.Contains("Ju-88") || acType.Contains("He-111") || acType.Contains("BR-20") || acType.Contains("BlenheimMk") || acType.Contains("Wellington")) isHeavyBomber = true;
                AGGisHeavyBomber = isHeavyBomber;

                string t = a.Type().ToString().ToUpper();
                if (t.Contains("FIGHTER") || t.Contains("JABO") || t.Contains("SCOUT")) t = "F";
                else if (t.Contains("BOMBER") || t.Contains("AMPHIB") || t.Contains("BLENHEIM")) t = "B";
                else t = t.Substring(0, 1);  //Otherwise, the first letter - whatever it is
                AGGtype = t;

                /* if (DEBUG) twcLogServer(new Player[] { player }, "DEBUG: Destroying: Airgroup: " + a.AirGroup() + " " 

                 + a.Type() + " " 
                 + a.TypedName() + " " 
                 +  a.AirGroup().ID(), new object[] { });
                */
                pos = a.Pos();
                AGGpos = pos;
                sector = Calcs.correctedSectorName(mission as Mission, pos);
                AGGsector = sector;
                sectorKeyp = Calcs.correctedSectorNameKeypad(mission as Mission, pos);
                AGGsectorKeyp = sectorKeyp;
                giantKeypad = Calcs.giantkeypad(pos);
                AGGgiantKeypad = giantKeypad;
                AGGmaxAlt_m = pos.z;
                AGGminAlt_m = pos.z;
                AGGaveAlt_m = pos.z;
                altAGL_m = a.getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // Z_AltitudeAGL is in meters
                altAGL_ft = Calcs.meters2feet(altAGL_m);
                AGGavealtAGL_ft = altAGL_ft;

                //Thread.Sleep(100);
                //pos2=a.Pos();
                //bearing=Calcs.CalculateGradientAngle (pos1,pos2);
                Vector3d Vwld = ag.Vwld();
                /*
                vel_mps = Calcs.CalculatePointDistance(Vwld);
                vel_mph = Calcs.meterspsec2milesphour(vel_mps);
                vel_mph_10 = Calcs.RoundInterval(vel_mph, 10);
                heading = (Calcs.CalculateBearingDegree(Vwld));
                heading_10 = Calcs.GetDegreesIn10Step(heading);
                dis_m = Calcs.CalculatePointDistance(a.Pos(), p.Pos());
                dis_mi = Calcs.meters2miles(dis_m);
                dis_10 = (int)dis_mi;
                if (dis_mi > 20) dis_10 = Calcs.RoundInterval(dis_mi, 10);
                bearing = Calcs.CalculateGradientAngle(p.Pos(), a.Pos());
                bearing_10 = Calcs.GetDegreesIn10Step(bearing);

                longlat = Calcs.Il2Point3dToLongLat(a.Pos());
                */
                /* alt_km = a.Pos().z / 1000;
                alt_ft = Calcs.meters2feet(a.Pos().z);
                altAGL_m = (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?
                altAGL_ft = Calcs.meters2feet(altAGL_m);
                alt_angels = Calcs.Feet2Angels(alt_ft);
                sector = GamePlay.gpSectorName(a.Pos().x, a.Pos().y).ToString();
                sector = sector.Replace(",", ""); // remove the comma */
                //Console.WriteLine("AGI 5");
                vel = new Point3d(Vwld.x, Vwld.y, Vwld.z);
                AGGvel = vel;
                double vel_mps = Calcs.CalculatePointDistance(vel);
                belowRadar = (mission as Mission).belowRadar(altAGL_ft, vel_mps, airGroup, a);
                if (belowRadar) { AGGcountAboveRadar = 0; AGGcountBelowRadar = 1; }
                else { AGGcountAboveRadar = 1; AGGcountBelowRadar = 0; }
                AGGradarDropout = false;

            }
            catch (Exception ex)
            { Console.WriteLine("AirgroupInfo ERROR: {0}", ex); }
        }

        public void addAG(AiAirGroup ag)
        {
            nearbyAirGroups.Add(ag);
        }
        public void addAGs(HashSet<AiAirGroup> ags)
        {
            nearbyAirGroups.UnionWith(ags);
        }

        //Check if the two a/c are closer than the threshhold and meet other criteria, such as same type of fighter/bomber, within reasonable altitude range and if so add mutually to each other's nearby airgroups list
        public void checkIfNearbyAndAdd(AirGroupInfo agi2)
        {
            if (agi2 == null || airGroup == null) return;
            Point3d tempos = agi2.pos;
            if (agi2.type == type && pos.distance(ref tempos) <= (mission as Mission).nearAirGroupThreshhold_m && (Math.Abs(agi2.pos.z - pos.z) <= (mission as Mission).nearAirGroupAltThreshhold_m))
            {
                if (agi2.airGroup == null ) return;
                addAG(agi2.airGroup);
                agi2.addAG(airGroup);
                //Console.WriteLine("AGI: Adding {0} {1:N0} {2:N0}, 1st: {3}, 2nd: {4}, {5}", playerNames, pos.distance(ref tempos), Math.Abs(agi2.pos.z - pos.z), nearbyAirGroups.Count, agi2.nearbyAirGroups.Count, agi2.playerNames);
            } else { // Console.WriteLine("AGI: NOT Adding {0} {1} {2}", type, pos.distance(ref tempos), mission.nearAirGroupThreshhold_m); 
            }

        }
        public void mutuallyAddNearbyAirgroups(AirGroupInfo agi2)
        {

            addAGs(agi2.nearbyAirGroups);
            agi2.addAGs(nearbyAirGroups);
            //Console.WriteLine("AGI: Adding {0} {1} 2nd: {2} {3}", playerNames, nearbyAirGroups.Count, agi2.nearbyAirGroups.Count, agi2.playerNames);


        }
        public string ToString()
        { return string.Format("{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} {13} {14} {15} {16} {17} {18} {19} {20} {21} {22} {23} {24} {25} {26} {27} {28}",
                actor.Name(),
                pos,
                vel,
                belowRadar,
                altAGL_ft,
                altAGL_m,
                count,
                type,
                isHeavyBomber,
                isAI,
                airGroup,
                isLeader,
                leader,
                AGGpos,    //exact loc of the primary a/c
                AGGavePos, //average loc of all a/c        
                AGGvel,
                AGGcount, //total # in group, including all above & below radar
                AGGcountAboveRadar, //if countAboveRadar is 0 this group won't show up at all.  This is the count that shows to ordinary players
                AGGcountBelowRadar,
                AGGminAlt_m,
                AGGmaxAlt_m,
                AGGaveAlt_m,
                AGGavealtAGL_ft,
                AGGtypeNames,
                AGGplayerNames,
                AGGids,  //the actor.Name()s compiled into a string
                AGGAIorHuman,
                AGGtype,
                AGGisHeavyBomber);
        }

    }

    public CircularArray<Dictionary<AiAirGroup, AirGroupInfo>> airGroupInfoCircArr = new CircularArray<Dictionary<AiAirGroup, AirGroupInfo>>(6);

    HashSet<AiAirGroup>[] CurrentAG = new HashSet<AiAirGroup>[3]; //array with all current AirGroups, which Radar can easily loop through, for each army
    HashSet<AiAirGroup>[] CurrentAGGroupLeaders = new HashSet<AiAirGroup>[3]; //array with ONLY thos airgroups that are currently the prime lead member of a grouping

    //CircularArray <AiAirGroup> closeAircraft = new CircularArray<AiAirGroup>(4); //Here we store which a/c are close to any given aircraft this run.  We save the last 4 runs in a circular array & we can use that to determine which aircraft/airgroups are traveling together



    public void groupAllAircraft_recurs()
    {
        /************************************************
         * 
         * Check/download/transfer stats data
         * Recursive function called every X seconds
         ************************************************/
        //Timeout(188, () => { CheckStatsData(); });

        //Timeout(31, () => { Task.Run(() => groupAllAircraft()); });
        Timeout(31, () => { groupAllAircraft_recurs(); });
        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX2 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        //Console.WriteLine("groupAllAircraft: -1");
        //OK< if we keep having the HighCPU bug caused by listpositionallaircraft, it is VERY possible that this Task.Run is the cause of it.  It will 
        //access/write some of the data structures in parallel & this could cause weird things to happen? (?)  2020/04/07
        Task.Run(() => groupAllAircraft());
        //groupAllAircraft();  //trying as not task.run as it's already done via a timeout?  2020/04/04
    }


    //This is called via Task.Run so no need to re-do that here/
    public void groupAllAircraft()
    {
        try
        {
            numBlueAircraft = 0;
            numRedAircraft = 0;
            numTotalAircraft = 0;
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("GPAAXX2-1 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping

            Dictionary<AiAirGroup, AirGroupInfo> airGroupInfoDict = new Dictionary<AiAirGroup, AirGroupInfo>();

            //First go through & identify which airgroups are nearby to which others individually

            //List<Tuple<AiAircraft, int>> aircraftPlaces = new List<Tuple<AiAircraft, int>>();
            if (GamePlay != null && GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
            {
                Console.WriteLine("groupallaircraft: gpArmies " + string.Join(",", GamePlay.gpArmies().Select(x => x.ToString()).ToArray()));
                
                foreach (int army in GamePlay.gpArmies())
                {
                    //Console.WriteLine("groupAllAircraft: 0");
                    CurrentAG[army] = new HashSet<AiAirGroup>();

                    HashSet<AiAirGroup> doneAG = new HashSet<AiAirGroup>();
                    
                    //trying to avoid obj ref not set to instance obj heree which CAN happen if a array is set to null instead of empty.
                    AiAirGroup[] aGa = GamePlay.gpAirGroups(army);
                    if (aGa == null || aGa.Count() == 0 ) continue;

                    try
                    {
                        //if (GamePlay.gpAirGroups(army) != null)
                        foreach (AiAirGroup airGroup in aGa)
                        {
                            if (airGroup == null) continue;
                            //Console.WriteLine("groupAllAircraft: 0.5");
                            doneAG.Add(airGroup);
                            //aigroup_count++;
                            if (airGroup != null && airGroup.GetItems() != null && airGroup.GetItems().Length > 0)
                            {
                                bool first = true;
                                //Console.WriteLine("groupAllAircraft: 1");
                                //poscount = airGroup.NOfAirc;
                                foreach (AiActor actor in airGroup.GetItems())
                                {

                                    //Console.WriteLine("groupAllAircraft: 1.1");
                                    if (actor != null && actor is AiAircraft)
                                    {
                                        //Keep a tally of the total number  of a/c altogether and for each side.
                                        //We do it by AIRGROUP so we really only need to do this for the first one in the group
                                        if (first)
                                        {
                                            int num = airGroup.GetItems().Length;
                                            if (army == 1) numRedAircraft += airGroup.NOfAirc;  //I THINK*** that NOfAirc will be more accurate as AC get killed etc over the course of the mission.  We'll see
                                            else if (army == 2) numBlueAircraft += airGroup.NOfAirc;
                                            numTotalAircraft += num;

                                            //Console.WriteLine("groupAllAircraft: 1.2 getitems count:{0} red:{1} blue:{2} total:{3} NOfAirc:{4}", num, numRedAircraft, numBlueAircraft, numTotalAircraft, airGroup.NOfAirc);
                                            first = false;
                                        }


                                        CurrentAG[army].Add(airGroup);
                                        //Console.WriteLine("groupAllAircraft: 1.3");

                                        //AirGroupInfo tmp = new AirGroupInfo(actor, airGroup, this, Time.current());
                                        AirGroupInfo tmp = new AirGroupInfo();
                                        //Console.WriteLine("groupAllAircraft: 1.3a");
                                        //Console.WriteLine("groupAllAircraft: 1.3a {0} {1} {2}", actor, airGroup, this);

                                        /*
                                        if (!airGroupInfoDict.TryGetValue(airGroup, out tmp))
                                        {
                                            Console.WriteLine("groupAllAircraft: 1.3b");
                                            tmp = new AirGroupInfo(actor, airGroup, this, 32);
                                            airGroupInfoDict[airGroup] = tmp;
                                        }*/

                                        if (!(airGroupInfoDict.ContainsKey(airGroup))) airGroupInfoDict[airGroup] = new AirGroupInfo(actor, airGroup, this, Time.current());

                                        //trying to avoid obj ref not set to instance obj heree which CAN happen if a array is set to null instead of empty.
                                        AiAirGroup[] aGa2 = GamePlay.gpAirGroups(army);
                                        if (aGa2 == null || aGa2.Count() == 0) continue;

                                        //Console.WriteLine("groupAllAircraft: 1.4");
                                        foreach (AiAirGroup airGroup2 in aGa)
                                        {
                                            //Console.WriteLine("groupAllAircraft: 1.5");
                                            if (doneAG.Contains(airGroup2)) continue;
                                            if (airGroup2 != null && airGroup2.GetItems() != null && airGroup2.GetItems().Length > 0)
                                            {
                                                //Console.WriteLine("groupAllAircraft: 1.6");
                                                //poscount2 = airGroup.NOfAirc;
                                                foreach (AiActor actor2 in airGroup2.GetItems())
                                                {
                                                    if (actor2 != null && actor2 is AiAircraft)
                                                    {
                                                        //Console.WriteLine("groupAllAircraft: 1.7");
                                                        if (!airGroupInfoDict.ContainsKey(airGroup2)) airGroupInfoDict[airGroup2] = new AirGroupInfo(actor2, airGroup2, this, Time.current());
                                                        /*
                                                        AirGroupInfo tmp1 = new AirGroupInfo();
                                                        if (!airGroupInfoDict.TryGetValue(airGroup2, out tmp1))
                                                        {
                                                            Console.WriteLine("groupAllAircraft: 1.7b");
                                                            tmp1 = new AirGroupInfo(actor, airGroup2, this, 32);
                                                        }
                                                        */
                                                        //Console.WriteLine("groupAllAircraft: 1.8");
                                                        airGroupInfoDict[airGroup2].checkIfNearbyAndAdd(airGroupInfoDict[airGroup]);
                                                        break;  //we only need the first one of each AI group


                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                    catch (Exception ex)
                    { Console.WriteLine("GroupAirgroups foreach #4 ERROR: {0}", ex); }

                    //Console.WriteLine("groupAllAircraft: 2.2 getitems red:{0} blue:{1} total:{2}", numRedAircraft, numBlueAircraft, numTotalAircraft);

                    //Console.WriteLine("groupAllAircraft: 3");

                    //Now go through & group them into groups that are close together and the same type (bomber/fighter)
                    //CurrentAGGroupLeaders[army] = new HashSet<AiAirGroup>();
                    HashSet<AiAirGroup> DoneAGnearby = new HashSet<AiAirGroup>();

                    try
                    {

                        foreach (AiAirGroup airGroup in CurrentAG[army])
                        {
                            //Console.WriteLine("groupAllAircraft: 4");
                            if (DoneAGnearby.Contains(airGroup))
                            {
                                continue;
                            }
                            //Console.WriteLine("groupAllAircraft: 4.1");
                            //CurrentAGGroupLeaders[army].Add(airGroup); //This ag is the primary/lead of this airgroup
                            //airGroupInfoDict[airGroup].isLeader = true;    //.isLeader = true;

                            //Console.WriteLine("groupAllAircraft: 4.2");
                            bool complete = false;
                            int i = 0;
                            while (!complete && i < 40)
                            {  //keep adding nearby aircraft greedily, but with a circuit breaker of 40X
                                complete = true;
                                i++;
                                HashSet<AiAirGroup> nb = new HashSet<AiAirGroup>(airGroupInfoDict[airGroup].nearbyAirGroups);
                                //HashSet <AiAirGroup> nb = ;
                                //Console.WriteLine("groupAllAircraft: 4.3");
                                if (nb != null) foreach (AiAirGroup ag in nb)
                                    {
                                        //Console.WriteLine("groupAllAircraft: 4.35");
                                        if (DoneAGnearby.Contains(ag)) continue;

                                        //Console.WriteLine("groupAllAircraft: 4.4");
                                        if (airGroupInfoDict.ContainsKey(ag))
                                        {
                                            complete = false;
                                            airGroupInfoDict[airGroup].mutuallyAddNearbyAirgroups(airGroupInfoDict[ag]);  //any a/c that is close an a/c close to the leader, is close to & grouped with the leader.  A "greedy" algorithm.
                                                                                                                          //Console.WriteLine("groupAllAircraft: 4.5");
                                            airGroupInfoDict[ag].leader = airGroup;
                                            airGroupInfoDict[ag].isLeader = false;
                                        }
                                        //Console.WriteLine("groupAllAircraft: 4.6");
                                        DoneAGnearby.Add(ag);
                                        //Console.WriteLine("groupAllAircraft: 4.7");
                                    }
                                //Console.WriteLine("groupAllAircraft: 4.8");
                            }

                            //DoneAGgrouped.UnionWith(airGroupInfoDict[airGroup].nearbyAirGroups);

                        }

                    }
                    catch (Exception ex)
                    { Console.WriteLine("GroupAirgroups foreach #3 ERROR: {0}", ex); }

                    /*Dictionary<AiAirGroup, AirGroupInfo> a1 = airGroupInfoCircArr.Get(0); //Last iteration
                    Dictionary<AiAirGroup, AirGroupInfo> a2 = airGroupInfoCircArr.Get(1); //2nd to last iteration
                    Dictionary<AiAirGroup, AirGroupInfo> a3 = airGroupInfoCircArr.Get(2); //3rd to last iteration 
                    */
                    //Dictionary<AiAirGroup, AirGroupInfo>[] aGICA = new Dictionary<AiAirGroup, AirGroupInfo>[] (airGroupInfoCircArr.ArrayStack); //The array with last pushed on in 0 position
                    Dictionary<AiAirGroup, AirGroupInfo>[] aGICA;

                    try
                    {
                        lock (airGroupInfoCircArr)
                        {
                            aGICA = airGroupInfoCircArr.ArrayStack.ToArray(); //The array with last pushed on in 0 position
                        }
                    }
                    catch (Exception ex)
                    { Console.WriteLine("GroupAirgroups aGICA ERROR!!!!!!!!!!!!!!! {0}", ex); return; }

                    //airGroupInfoCircArr.Push(airGroupInfoDict);

                    //Now go through AGAIN & identify which have been nearby for X iterations, meaning that they are traveling together & part of the same group
                    CurrentAGGroupLeaders[army] = new HashSet<AiAirGroup>();
                    //Console.WriteLine("groupAllAircraft: 4.9 {0}",army);
                    HashSet<AiAirGroup> DoneAGgrouped = new HashSet<AiAirGroup>();

                    try
                    {

                        foreach (AiAirGroup airGroup in CurrentAG[army])
                        {
                            //Console.WriteLine("groupAllAircraft: a4");
                            if (DoneAGgrouped.Contains(airGroup))
                            {
                                continue;
                            }
                            //Console.WriteLine("groupAllAircraft: a4.1");
                            CurrentAGGroupLeaders[army].Add(airGroup); //This ag is the primary/lead of this airgroup
                            airGroupInfoDict[airGroup].isLeader = true;    //.isLeader = true;

                            //Console.WriteLine("groupAllAircraft: a4.2");
                            bool complete = false;
                            int i = 0;
                            HashSet<AiAirGroup> nb = airGroupInfoDict[airGroup].nearbyAirGroups;
                            HashSet<AiAirGroup> grouped = new HashSet<AiAirGroup>(nb);
                            //airGroupInfoDict[airGroup].groupedAirGroups = nb;  //we start off with the a/c that are nearby us now

                            //Console.WriteLine("Grouping: Leader {0} started with {1} groups at {2:N0}", airGroupInfoDict[airGroup].playerNames, grouped.Count, airGroupInfoDict[airGroup].time);

                            int maxStack = 6;//We are saving 6 of the aiGroupInfoCircArr; we save a new one every 30 seconds approx.  So 6 means the a/c have been flying together for about 3 minutes
                            if (aGICA.Length < maxStack) maxStack = aGICA.Length;

                            for (i = 0; i < maxStack; i++)
                            {
                                //aGICA

                                HashSet<AiAirGroup> nba = new HashSet<AiAirGroup>();
                                if (aGICA[i] != null && aGICA[i].ContainsKey(airGroup))
                                {
                                    nba = new HashSet<AiAirGroup>(aGICA[i][airGroup].nearbyAirGroups);
                                    double time = aGICA[i][airGroup].time;
                                    //if (nba != null)
                                    if (nba.Count > 0) grouped.IntersectWith(nba);  //Now we eliminate any that were NOT nearby last run
                                                                                    //Console.WriteLine("Grouping: Leader {0} step{5}: {1} groups of {2} ({3}) possible at {4:N0} ", airGroupInfoDict[airGroup].playerNames, grouped.Count, nba.Count, aGICA[i][airGroup].nearbyAirGroups.Count, time, i);
                                }
                            }
                            /*
                            //We are intersecting here, so if the 2nd hashset is EMPTY or DOESN'T EXIST
                            //we'll end up with a grouping with 0 elements, not even the original a/c.
                            //So we check to make sure the airGroupInfoDict from previous runs exists, and then
                            //also that it's length is >0.  It should always be at least 1 as it should include itself
                            HashSet<AiAirGroup> nba = new HashSet<AiAirGroup>();
                            if (a1 != null && a1.ContainsKey(airGroup))
                            {
                                nba = new HashSet<AiAirGroup>(a1[airGroup].nearbyAirGroups);
                                double time = a1[airGroup].time;
                                //if (nba != null)
                                if (nba.Count > 0) grouped.IntersectWith(nba);  //Now we eliminate any that were NOT nearby last run
                                Console.WriteLine("Grouping: Leader {0} step2: {1} groups of {2} ({3}) possible at {4:N0} ", airGroupInfoDict[airGroup].playerNames, grouped.Count, nba.Count, a1[airGroup].nearbyAirGroups.Count, time);
                            }
                            HashSet<AiAirGroup> nbb = new HashSet<AiAirGroup>();
                            if (a2 != null && a2.ContainsKey(airGroup))
                            {
                                nbb = new HashSet<AiAirGroup>(a1[airGroup].nearbyAirGroups);
                                double time = a2[airGroup].time;
                                //if (nba != null)
                                if (nbb.Count > 0) grouped.IntersectWith(nbb);  //Now we eliminate any that were NOT nearby last run
                                Console.WriteLine("Grouping: Leader {0} step3: {1} groups of {2} ({3}) possible at {4:N0} ", airGroupInfoDict[airGroup].playerNames, grouped.Count, nbb.Count, a2[airGroup].nearbyAirGroups.Count, time);
                            }
                            */
                            /*

                            HashSet<AiAirGroup> nbb = new HashSet<AiAirGroup>();
                            if (a2 != null && a2.ContainsKey(airGroup))
                            {
                                nbb = a2[airGroup].nearbyAirGroups;
                                //if (set && nbb != null)
                                if (nbb.Count > 0) airGroupInfoDict[airGroup].groupedAirGroups.IntersectWith(nbb);  //Eliminate any NOT nearby two runs ago
                                Console.WriteLine("Grouping: Leader {0} step3: {1} groups of {2} possible ", airGroupInfoDict[airGroup].playerNames, airGroupInfoDict[airGroup].groupedAirGroups.Count, nbb.Count);
                            }
                            */

                            //HashSet<AiAirGroup> gag = new HashSet<AiAirGroup> ( airGroupInfoDict[airGroup].groupedAirGroups);
                            HashSet<AiAirGroup> toremovefrom_gag = new HashSet<AiAirGroup>();

                            //Console.WriteLine("Grouping: Leader {0} added {1} groups ", airGroupInfoDict[airGroup].playerNames, grouped.Count);

                            //Console.WriteLine("groupAllAircraft: a4.3");
                            if (grouped != null) foreach (AiAirGroup ag in grouped)
                                {


                                    //Console.WriteLine("groupAllAircraft: a4.4");
                                    if (airGroupInfoDict.ContainsKey(ag))
                                    {

                                        //Console.WriteLine("groupAllAircraft: a4.35");
                                        if (DoneAGgrouped.Contains(ag))
                                        {
                                            if (airGroupInfoDict[ag].leader != airGroup) //ag is close to more than one a/c but another has already claimed it as leader, and that one hasn't also claimed airGroup as part of its group.  So, we have to remove ag from airGroup's group as it's already been claimed by another
                                            {
                                                //airGroupInfoDict[airGroup].groupedAirGroups.Remove(ag);
                                                //mysteriously, we can't remove it inside the foreach loop (even though we're supposedly running on a copy?!) so we save it for later removal
                                                toremovefrom_gag.Add(ag);
                                            }
                                            continue;
                                        }
                                        complete = false;
                                        //Console.WriteLine("Grouping: Leader {0} added {1} groups ", airGroupInfoDict[airGroup].actor.Name(), airGroupInfoDict[ag].actor.Name());
                                        airGroupInfoDict[ag].groupedAirGroups = grouped;  //the airgroups in this grouping
                                                                                          //Console.WriteLine("groupAllAircraft: a4.5");
                                        if (ag != airGroup)
                                        {
                                            airGroupInfoDict[ag].leader = airGroup;
                                            airGroupInfoDict[ag].isLeader = false;
                                            if (CurrentAGGroupLeaders[army].Contains(ag)) CurrentAGGroupLeaders[army].Remove(ag); //Make sure we have but one leader for the group & it has 
                                        }
                                    }
                                    //Console.WriteLine("groupAllAircraft: a4.6");
                                    DoneAGgrouped.Add(ag);
                                    //Console.WriteLine("groupAllAircraft: a4.7");
                                }
                            else
                            {
                                Console.WriteLine("groupAllAircraft ERROR: No AirGroup in the grouping - this should never happen!");
                            }
                            //Console.WriteLine("groupAllAircraft: a4.8");

                            //now remove any ags that were claimed by another previous leader
                            //airGroupInfoDict[airGroup].groupedAirGroups.Remove(ag);
                            //foreach (AiAirGroup ai2 in toremovefrom_gag) airGroupInfoDict[airGroup].groupedAirGroups.Remove(ai2);                            
                            foreach (AiAirGroup ai2 in toremovefrom_gag) grouped.Remove(ai2);
                            foreach (AiAirGroup ai3 in grouped) airGroupInfoDict[ai3].groupedAirGroups = grouped;  //grouped just change, so we re-add it to each AG in the group
                                                                                                                   //airGroupInfoDict[airGroup].groupedAirGroups.Remove(ai2);


                            //DoneAGgrouped.UnionWith(airGroupInfoDict[airGroup].nearbyAirGroups);

                        }
                    }
                    catch (Exception ex)
                    { Console.WriteLine("GroupAirgroups foreach #2 ERROR: {0}", ex); }

                    //Console.WriteLine("groupAllAircraft: 5");

                    try { 
                    //Now go through each group & calculate needed info such as # of aircraft in group.  Later we can add fancier ways of figuring group velocity, direction, altitude etc but for now we're
                    //just using the values from the primary aircraft of the group
                    if (CurrentAGGroupLeaders[army] != null) foreach (AiAirGroup airGroup in CurrentAGGroupLeaders[army])
                        {
                            //Console.WriteLine("groupAllAircraft: 6");
                            AirGroupInfo agid = airGroupInfoDict[airGroup];
                            int c = 0;
                            int cAboveRadar = 0;
                            int cBelowRadar = 0;
                            double aveAltAGL_ft = 0;
                            aiorhuman ah = aiorhuman.Human;
                            if (agid.isAI) ah = aiorhuman.AI;
                            double minAlt = agid.pos.z;
                            double maxAlt = agid.pos.z;
                            double aveAlt = 0;
                            Point3d avePos = new Point3d(0, 0, 0);
                            Point3d vwld = new Point3d(0, 0, 0);
                            string typeName = "";
                            string playerNames = "";
                            bool first = true;
                            string ids = "";



                            if (airGroupInfoDict[airGroup].groupedAirGroups != null) foreach (AiAirGroup ag in airGroupInfoDict[airGroup].groupedAirGroups)
                                {
                                    if (!airGroupInfoDict.ContainsKey(ag)) continue;
                                    AirGroupInfo agid2 = airGroupInfoDict[ag];
                                    c += airGroupInfoDict[ag].count;
                                    if (agid2.belowRadar) cBelowRadar += airGroupInfoDict[ag].count;
                                    else cAboveRadar += airGroupInfoDict[ag].count;
                                    if (agid2.pos.z > maxAlt) maxAlt = agid2.pos.z;
                                    if (agid2.pos.z < minAlt) minAlt = agid2.pos.z;
                                    aveAlt += agid2.pos.z * agid2.count;
                                    aveAltAGL_ft += agid2.altAGL_ft * agid2.count;

                                    if (!first)
                                    {
                                        playerNames += " - ";
                                        typeName += " - ";
                                        ids += " - ";
                                    }
                                    else first = false;


                                    playerNames += agid.playerNames;
                                    typeName += Calcs.GetAircraftType(agid2.actor as AiAircraft);
                                    ids += agid2.actor.Name();
                                    if (!agid2.isAI && (agid2.actor as AiAircraft).Player(0) != null) playerNames += (agid2.actor as AiAircraft).Player(0).Name() + " - ";
                                    vwld = new Point3d(vwld.x + (double)agid2.count * agid2.vel.x, vwld.y + (double)agid2.count * agid2.vel.y, vwld.z + (double)agid2.count * agid2.vel.z); //weight the direction vector by the # of aircraft in this airgroup
                                    avePos = new Point3d(avePos.x + (double)agid2.count * agid2.pos.x, avePos.y + (double)agid2.count * agid2.pos.y, avePos.z + (double)agid2.count * agid2.pos.z); //weight the direction vector by the # of aircraft in this airgroup



                                    if (airGroupInfoDict[ag].isAI)
                                    {
                                        if (ah == aiorhuman.Human) ah = aiorhuman.Mixed;
                                    }
                                    else if (ah == aiorhuman.AI) ah = aiorhuman.Mixed;

                                    //can do other calculations here such as averaging speed, altitude, direction, whatever
                                    //Figure out speed & direction  from actual travel time over last two radar measurements, etc.

                                }
                            agid.AGGcount = c;
                            agid.AGGisHeavyBomber = agid.isHeavyBomber;
                            agid.AGGpos = agid.pos;
                            agid.AGGtype = agid.type;
                            //agid.AGGvel = agid.vel;
                            agid.AGGvel = new Point3d(vwld.x / (double)c, vwld.y / (double)c, vwld.z / (double)c);  //The 'average' of the direction vectors
                            agid.AGGavePos = new Point3d(avePos.x / (double)c, avePos.y / (double)c, avePos.z / (double)c);  //The 'average' of the position vectors
                            agid.AGGminAlt_m = minAlt;
                            agid.AGGmaxAlt_m = maxAlt;
                            agid.AGGaveAlt_m = aveAlt / (double)c;
                            agid.AGGavealtAGL_ft = aveAltAGL_ft / (double)c;
                            agid.AGGcountBelowRadar = cBelowRadar;
                            agid.AGGcountAboveRadar = cAboveRadar;
                            agid.AGGtypeNames = typeName;
                            agid.AGGplayerNames = playerNames;
                            agid.AGGids = ids;
                            agid.AGGAIorHuman = ah;

                            agid.AGGmixupType = agid.AGGtype;

                            if (random.Next(21) == 1)
                            { //oops, sometimes we get mixed up on the type.  So sad . . .  See notes below about relative inaccuracy of early radar.
                                agid.AGGmixupType = "U";
                                //if (random.Next(3) == 1) agid.AGGmixupType = "B";
                            }

                            //So if we have the old mixupType, and it actually WAS mixed up, then it will have a high probability of staying mixed up for several cycles
                            if (aGICA[0] != null && aGICA[0].ContainsKey(airGroup))
                            {
                                AiAirGroup oldLeader = aGICA[0][airGroup].leader;
                                if (aGICA[0].ContainsKey(oldLeader)) {
                                    if (agid.AGGtype != aGICA[0][oldLeader].AGGmixupType && random.Next(4) < 3)
                                    {
                                        agid.AGGmixupType = aGICA[0][oldLeader].AGGmixupType;
                                    }


                                }
                            }

                            //Calculate average speed based on actual movement over time rather than instantaneous current movement, if possible
                            //Only do this in the case the current AG leader was also leader for the past three periods  
                            //using index 4 seems too much, results are quite discrepant from the 'old' style plotting table.  Maybe just use the one a/c's vel, or the average vel
                            /*
                            int aGICAindex = 4;
                            bool useAGICA = false;
                            for (int i = 0; i <= aGICAindex; i++)
                                {
                                    if (aGICA[i] != null && aGICA[i].ContainsKey(airGroup) && aGICA[i][airGroup].leader == airGroup) useAGICA = true;
                                    else
                                    {
                                        useAGICA = false;
                                        break;
                                    }
                                }                      
                            //if (a3 != null && a3.ContainsKey(airGroup) && a2 != null && a2.ContainsKey(airGroup) && a1 != null && a1.ContainsKey(airGroup) &&
                                     a1[airGroup].leader == airGroup && a2[airGroup].leader == airGroup && a3[airGroup].leader == airGroup) 
                            if (useAGICA)
                                {
                                    //Point3d p1 = aGICA[aGICAindex][airGroup].AGGavePos; //This would be using the average position of the entire airgroup
                                    //Point3d p2 = agid.AGGavePos; 
                                    Point3d p1 = aGICA[aGICAindex][airGroup].pos; //instead we'll use this one aircraft's ACTUAL position, which might be more consistent
                                    Point3d p2 = agid.pos; 
                                    double timeDiff = Time.current() - aGICA[aGICAindex][airGroup].time;
                                    Point3d vel2 = new Point3d ((p2.x-p1.x)/timeDiff, (p2.y - p1.y) / timeDiff, 0 );
                                    //Console.WriteLine("AveVel vs Vel2: {0:0} {1:0} {2:0} {3:0} {4:0} {5:0} ", agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z, vel2.x, vel2.y, vel2.z);
                                    agid.AGGvel = vel2;                                
                                }
                        */




                            agid.AGGradarDropout = false;

                            int dropoutValue = 14;
                            if (agid.AGGcount > 5) dropoutValue = Convert.ToInt32(11 * agid.AGGcount * agid.AGGcount / 25);
                            //Some radar returns vanish for no particular reason.  Random bug in the system, flock of seagulls, whatever
                            if (random.Next(dropoutValue) == 1)
                            {
                                agid.AGGradarDropout = true;
                                //Console.WriteLine("RG: AGGradarDropout due to random 1/7 {0} {1} {2}", agid.actor.Name(), agid.AGGcount, dropoutValue);
                            }

                            //Small groups of human heavy bombers are more likely to disappear from radar, in order to give them more of a fighting chance
                            //So bombers will drop out 1/7 and the amount indicated below.  Tried dropout 3/4 of the time but that leaves only 3/4*6/7 that
                            //they would show up, which means they didn't show up hardly at all. Around 50% for heavy bomber might be OK, means they
                            //show up like 40% of the time?  This applies to 1-2 bombers.  3-4-5 bombers also drop out some but less so as the bomber group size grows
                            if ((agid.AGGAIorHuman == aiorhuman.Human) && agid.AGGisHeavyBomber && agid.AGGcount <= 2 && random.Next(100) <= 50)  //2018-10-24, was 58, trying it lower.  10-25, 42 was worse, trying 67 instead. 67 seems to basically make them disappear, trying 50 instead.
                            {
                                agid.AGGradarDropout = true;
                                //Console.WriteLine("RG: AGGradarDropout due to HeavyBomber random 47% {0}", agid.actor.Name());
                            }
                            else if ((agid.AGGAIorHuman == aiorhuman.Human) && agid.AGGisHeavyBomber && agid.AGGcount <= 5 && agid.AGGcount > 2 && random.Next(100) <= (50 - 10 * (agid.AGGcount - 2)))  //2018-10-24, was 58, trying it lower.  10-25, 42 was worse, trying 67 instead.  Now 50, same as above.
                            {
                                agid.AGGradarDropout = true;
                                //Console.WriteLine("RG: AGGradarDropout due to HeavyBomber random 47% {0}", agid.actor.Name());
                            }




                            airGroupInfoDict[airGroup] = agid;

                            //Console.WriteLine("Airgroup Grouping: {0} {1} {2} {3:0} {4:0} {5:0} ", agid.actor.Name(), agid.count, agid.AGGcount, agid.AGGcountAboveRadar, agid.AGGcountBelowRadar, agid.AGGids);
                            //agid.AGGpos.x, agid.AGGpos.y, agid.AGGpos.z, agid.AGGtype, ah, agid.AGGisHeavyBomber, agid.AGGavePos.x, agid.AGGavePos.y,agid.AGGaveAlt_m, agid.AGGmaxAlt_m, agid.AGGids, agid.AGGplayerNames, agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z);
                        }
                    }
                    catch (Exception ex)
                    { Console.WriteLine("GroupAirgroups foreach #1 ERROR: {0}", ex); }



                }

            }
            //Console.WriteLine("groupAllAircraft: 7");
            lock (airGroupInfoCircArr) {
                airGroupInfoCircArr.Push(airGroupInfoDict);  //We save the last ~4 iterations of infodict on a circular array, so that we can go back & look @ what airgroups/leaders were doing in the last few minutes
            }

            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("GPAAXX2-2 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        } catch (Exception ex)    { Console.WriteLine("GroupAirgroups ERROR: {0}", ex); }
    }

    public string showGiantSectorOverview(Player player = null, int army = 0, bool display = true, bool html = false)
    {
        try
        {

            double delay = 8;

            Player[] to = null;
            if (player != null) to = new Player[] { player };

            string newline = Environment.NewLine;
            if (html) newline = "<br>" + Environment.NewLine;
            string retmsg = "";

            if (display) Timeout(0.4, () => twcLogServer(to, "Requesting Map Overview summary from headquarters, please stand by . . . ", null));


            string msg = "***Schematic Map Overview of Enemy Activity***";
            retmsg += msg + newline;


            string msg2 = "Airgroups:Aircraft in each Large Map Keypad Area";
            retmsg += msg2 + newline;


           //string msg3 = "For more details, ask your Commander or Radar Operator to consult the Contact Plotting Table - or simply patrol the area, use Tab-4-1";
            //retmsg += msg3 + newline;

            /*for (int i = 1; i < 10; i++)
            {
                string tild = "~";
                if (GiantSectorOverview[player.Army()][i, 1] == 0) tild = "";

                twcLogServer(new Player[] { player }, "Sector {0}: {1} enemy airgroups, {2}{3} aircraft",new object [] { i, GiantSectorOverview[player.Army()][i, 0], tild, GiantSectorOverview[player.Army()][i, 1] });
            }*/
            //Console.WriteLine("Giant: " + GiantSectorOverview.ToString());

            if (display) Timeout(delay, () =>
            {

                twcLogServer(to, msg, null);
                twcLogServer(to, msg2, null);
                //twcLogServer(to, msg3, null);

            });

            var msgList = new List<string>();

            for (int i = 2; i > -1; i--)
            {
                string msg4 = string.Format("{0:D3}:{1:D3} {2:D3}:{3:D3} {4:D3}:{5:D3} ",
                    GiantSectorOverview[army][i * 3 + 1, 0], GiantSectorOverview[army][i * 3 + 1, 1],
                    GiantSectorOverview[army][i * 3 + 2, 0], GiantSectorOverview[army][i * 3 + 2, 1],
                    GiantSectorOverview[army][i * 3 + 3, 0], GiantSectorOverview[army][i * 3 + 3, 1]

                    );

                retmsg += msg4 + newline;
                msgList.Add(msg4);
                
            }

            if (display) Timeout(delay, () => { foreach (string m in msgList) { twcLogServer(to, m, null); } });

            return retmsg;
        }
        catch (Exception ex)
        { Console.WriteLine("showGiantSectorOverview ERROR: {0}", ex); return ""; }
    }

    /************************************************
         * Get radar returns for each AI aircraft group
         * Can be used to, ie, reprogram the flight plans for aiairgroups so they intercept any
         * enemies in their area
         * Recursive function called every X seconds
         ************************************************/


    public void aiAirGroupRadarReturns_recurs()
    {


        Timeout(127, () => { aiAirGroupRadarReturns_recurs(); });
        //Console.WriteLine("groupAllAircraft: -1");
        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MRXX3 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        //Task.Run(() => aiAirGroupRadarReturns());
        aiAirGroupRadarReturns();
        //aiAirGroupRadarReturns();


    }

    //Called via Task.Run so don't need to do it in the method here.
    public void aiAirGroupRadarReturns()
    {
        //NEW here to make a separate copy of this & not touch the existing airGroupInfoCircArr.Get(0);
        //so lock airGroupInfoCircArrf PLUS making a copy of airGroupInfoCircArr.Get(0) rather than just directly referencing it, SHOULD (?!?) make this thread safe?
        Dictionary<AiAirGroup, AirGroupInfo> airGroupInfoDict;
        lock (airGroupInfoCircArr) {
            airGroupInfoDict = new Dictionary<AiAirGroup, AirGroupInfo>(airGroupInfoCircArr.Get(0)); //Most recent iteration of airgroup groupings
        }

        //Console.WriteLine("AIAGRR: Checking radar returns for AI groups");
        Task.Run( () =>
            {
                if (airGroupInfoDict != null) foreach (AiAirGroup airGroup in airGroupInfoDict.Keys)
                    {
                        AirGroupInfo agi = airGroupInfoDict[airGroup];
                        if (!agi.isAI || agi.type != "F") continue; //we're only doing aiaircraft here, and fighters

                        //Console.WriteLine("AIAGRR: Checking radar returns for " + agi.playerNames);
                        listPositionAllAircraft(player: null, playerArmy: airGroup.getArmy(), inOwnArmy: false, radar_realism: RADAR_REALISM, aiairgroup: airGroup);
                    }
            }
        );
    }

    public class AiAirGroupRadarInfo : IAiAirGroupRadarInfo
    {
        public double time { get; set; } //Battle.time.current;
        //public SortedDictionary<string, AirGroupInfo> interceptList {get; set;}
        public IAirGroupInfo agi { get; set; } //airgroup info for TARGET airgroup
        public IAirGroupInfo pagi { get; set; } //airgroup info for SOURCE airgroup (ie the 'player' or the one that will be targeting the TARGET
        public Point3d interceptPoint { get; set; } //intcpt, with x,y as location and z as intcpt time in seconds
        public bool climbPossible { get; set; } //climb_possible
        public AMission mission { get; set; }


        public AiAirGroupRadarInfo(Mission msn, IAirGroupInfo AGI, IAirGroupInfo PAGI, Point3d InterceptPoint, bool ClimbPossible, double tm = 0)
        {
            //interceptList = InterceptList;
            mission = msn;
            if (tm != 0) time = tm;
            else time = mission.Time.current();
            interceptPoint = InterceptPoint;
            climbPossible = ClimbPossible;
            agi = AGI;
            pagi = PAGI;
        }
    }
    //returns TRUE if player is off the radar, either by being too low or in an area where the radar is out.
    public bool offRadar(Player player)
    {

        //if (player.Place() == null || player.Army() == null || !MO_isRadarEnabledByArea(player.Place().Pos(), radarArmy: player.Army())) return true;
        //TOBRUK
        if (player == null || player.Place() == null || player.Army() == null || !MO_isRadarEnabledByArea_TOBRUK(player.Place().Pos(), radarArmy: player.Army())) return true;
        if (belowRadar(player)) return true;
        return false;
    }
    public bool belowRadar(Player player)
    {
        if (player != null || player.Place() != null && (player.Place() as AiAircraft) != null) return belowRadar(player.Place() as AiAircraft);
        else return true;
    }

    public bool belowRadar(AiAircraft aircraft = null)
    {
        if (aircraft == null) return true;
        AiAirGroup airGroup = aircraft.AirGroup();
        double vel_mps = Calcs.CalculatePointDistance(airGroup.Vwld());
        double altAGL_m = aircraft.getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?
        double altAGL_ft = Calcs.meters2feet(altAGL_m);
        //Console.WriteLine("belowradar: " + altAGL_ft + " " + vel_mps);
        return belowRadar(altAGL_ft, vel_mps, airGroup, aircraft);
    }

    //unified location to determine if an a/c is low enough to drop off the radar
    //TRUE if off the radar, false otherwise
    public bool belowRadar(double altAGL_ft, double vel_mps, AiAirGroup airGroup = null, AiAircraft aircraft = null)
    {
        try { 
        //So mostly flying "below radar" is quite safe and undetected.  But in some cases there will be a detection, either because radar got a return somehow, or (far
        //more likely) the aircraft was spotted by an observer or some other way.  So this type of thing is far more likely to happen when over
        //enemy ground and far, far more  likely when near an enemy objective, which is likely to be well guarded etc.
        bool onEnemyGround = false;
        bool nearMissionObjective = false;
        bool isAI = false;
        if (aircraft != null && (aircraft as AiActor != null))
        {
            bool onEnemyTerritory = false;
            int terr = GamePlay.gpFrontArmy(aircraft.Pos().x, aircraft.Pos().y);

            if ((terr == 1 || terr == 2) && (aircraft as AiActor).Army() != terr) onEnemyTerritory = true;

            maddox.game.LandTypes landType = GamePlay.gpLandType(aircraft.Pos().x, aircraft.Pos().y);
            if (onEnemyTerritory && landType != maddox.game.LandTypes.WATER) onEnemyGround = true;

            int numMissionObjectivesNear = 0;

            if (onEnemyGround && MO_MissionObjectivesNear(aircraft.Pos(), dist_m: 8000) > 1) nearMissionObjective = true;

            isAI = isAiControlledPlane2(aircraft);

        }

        if (isAI) altAGL_ft = altAGL_ft - 800; //AI aircraft just can't fly below a certain altitude.  So we're giving them a break as far as disappearing from radar if they're low.

        double leakageRate = .14;  //was .12, seemed too low
        double below250LeakageRate = 0.35;

        if (onEnemyGround)
        {
            leakageRate = .24;  //was .24, seemed too low
            below250LeakageRate = 0.09;
        }

        if (nearMissionObjective)
        {
            leakageRate = .55;//was .64, seemed too low
            below250LeakageRate = 0.45;
        }
        
        bool below = ((altAGL_ft < 500 && altAGL_ft - 325 < random.Next(175)) || //Less then 400 ft AGL they start to phase out from radar     
                                                                                 //(dis_mi < 10 && altAGL_ft < 400 && altAGL_ft < random.Next(500)) || //Within 10 miles though you really have to be right on the deck before the radar starts to get flakey, less than 250 ft. Somewhat approximating 50 foot alt lower limit.
        (altAGL_ft < 350)); //And, if they are less than 350 feet AGL, they are gone from radar.  Except for a bit of leakage.

        //So, 80% of the time we cloak them if below radar, but 20% it somehow leaks out anyway . . .
        if (altAGL_ft < 20 && vel_mps < 20 && random.NextDouble() < 0.9 && Stb_distanceToNearestAirport(aircraft as AiActor) < 2500) return false; //So airplanes on the ground, taxiing at airport, etc, are picked up.  This isn't radar per se but intelligence or intercepts of radio chatter & other comms giving indications of future movements & where they are happening.
        if (random.NextDouble() < (1 - leakageRate) || (altAGL_ft < 250 && random.NextDouble() < (1 - below250LeakageRate))) return below;
        else return false;  //so, sometimes, 20% of the time or 5% of the time below 100 ft AGL, aircraft below radar elevation show up somehow, leakage probably, or maybe an observer spotted them

        }
        catch (Exception ex) { Console.WriteLine("ERROR belowRadar()! " + ex.ToString()); return false; }
    }

    public System.IO.FileInfo fi;// = new System.IO.FileInfo(STATSCS_FULL_PATH + MISSION_ID + "_radar.txt"); //file to write to
    public System.IO.StreamWriter sw;

    //List all a/c positions to console///////////////////////////
    //Radar . . . 
    // RADAR_REALISM = 0 lists <pos detailed info to chat window, for admins
    // RADAR_REALISM > 0 is regular tab-4-1 <rad filtered radar returns for in-game
    // RADAR_REALISM = -1 is for online radar/TOPHAT system and saves the info for both armies to a file
    // inOwnArmy = true list aircraft in own army, false in opposing army
    //BUT inOwnArmy = false & playerArmy -1, -2, -3 will list ALL aircraft regardless
    // playerArmy -1 is for TOPHAT & will list all a/c but with the red TOPHAT slant
    // playerArmy -2 is for TOPHAT & will list all a/c but with the blue TOPHAT slant
    // playerArmy -3 is for TOPHAT & will list all a/c but is for ADMINS listing all kinds of details etc vs the red/blue TOPHAT which is more filtered to simulate real WWII radar
    // playerArmy -4 is for TOPHAT BUT GROUPED & will also list all a/c but shown as grouped and is for ADMINS listing all kinds of details etc vs the red/blue TOPHAT which is more filtered to simulate real WWII radar

    public void listPositionAllAircraft(Player player, int playerArmy, bool inOwnArmy, int radar_realism = -10000000, AiAirGroup aiairgroup = null, bool disp = true)
    {
        try
        {

            if (radar_realism == -10000000) radar_realism = RADAR_REALISM;
            DateTime d = DateTime.UtcNow;
            // int radar_realism;     //realism = 0 gives exact position, bearing, velocity of each a/c.  We plan to make various degrees of realism ranging from 0 to 10.  Implemented now is just 0=exact, >0 somewhat more realistic    
            // realism = -1 gives the lat/long output for radar files.

            Dictionary<AiAirGroup, AirGroupInfo> airGroupInfoDict;
            //so lock airGroupInfoCircArrf PLUS making a copy of airGroupInfoCircArr.Get(0) rather than just directly referencing it, SHOULD (?!?) make this thread safe?
            lock (airGroupInfoCircArr)
            {
                airGroupInfoDict = new Dictionary<AiAirGroup, AirGroupInfo>(airGroupInfoCircArr.Get(0)); //Most recent iteration of airgroup groupings
            }

            bool display = true;

            if (disp == false || (player == null && aiairgroup != null)) display = false; //don't display for aiairgroup calcs

            string posmessage = "";
            int poscount = 0;
            int totalcount = 0;
            int belowradarcount = 0;
            AiAircraft p = null;
            AiActor pa = null;

            AirGroupInfo padig = null;

            Point3d pos1;
            Point3d pos2;
            Point3d VwldP, intcpt, longlat;
            Point3d ppos = new Point3d(0, 0, 0);
            Vector3d Vwld, player_Vwld;
            double player_vel_mps = 0;
            double player_vel_mph = 0;
            double player_alt_m = 0;
            string type, player_sector;
            string playertype = "";
            bool player_place_set = false;
            bool isHeavyBomber = false;
            double vel_mps = 0;
            double vel_mph = 0;
            int vel_mph_10 = 0;
            double heading = 0;
            int heading_10 = 0;
            double dis_m = 0;
            double dis_mi = 0;
            int dis_10 = 0;
            double bearing = 0;
            int bearing_10 = 0;
            double alt_ft = 0;
            double alt_km = 0;
            double altAGL_m = 0;
            double altAGL_ft = 0;
            int alt_angels = 0;
            string sector = "";
            double intcpt_heading = 0;
            double intcpt_time_min = 0;
            string intcpt_sector = "";
            bool intcpt_reasonable_time = false;
            bool climb_possible = true;
            int aigroup_count = 0;
            string playername = "TWC_server_159273";
            string playername_index;
            bool playerOffRadar = true;
            string enorfriend;
            long currtime_ms = 0;
            long storedtime_ms = -1;
            bool savenewmessages = true;
            Tuple<long, SortedDictionary<string, string>> message_data;
            SortedDictionary<string, string> radar_messages =
                new SortedDictionary<string, string>(new ReverseComparer<string>()); //reverse sorted so "best" messages come last on the list players receive
            SortedDictionary<string, IAiAirGroupRadarInfo> ai_radar_info =
                new SortedDictionary<string, IAiAirGroupRadarInfo>() { }; //NOT reverse sorted so on the list of AI radar returns, the best messages come first
            //string [] radar_messages, radar_messages_index;             
            int wait_s = 0;
            long refreshtime_ms = 0;
            //There is now a delay BUILT IN to the airgroup grouping system, 0-30 seconds (15 sec on average).
            //So we cut our required wait time here from 20 sec to 5 seconds.  We don't have to wait for them
            //to be stale--they're ALREADY stale!  Plus, we use the player's position, velocity, etc
            //from the radar DB as well as other a/c location/velocity, so it's ALL somewhat stale.
            if (radar_realism >= 1) { wait_s = 1; refreshtime_ms = 60 * 1000; }
            //if (radar_realism >= 5) { wait_s = 10; refreshtime_ms = 2 * 60 * 1000; } //CloD Blitz/Campaign Serer settings
            if (radar_realism >= 5)
            {
                if (MO_BRBumrushActive() && MO_BRCurrentBumrushMissionObjective() != null && player != null && player.Place() != null && (player.Place() is AiAircraft) &&
                    Calcs.CalculatePointDistance(MO_BRCurrentBumrushMissionObjective().Pos, (player.Place() as AiAircraft).Pos()) < 40000)
                {
                    wait_s = 3; refreshtime_ms = 15 * 1000; //So within the Bumrush area, during bumrush, they have set up special radar thingers & they are much faster. Unless the enemy has destroyed them of course.
                }
                else
                {
                    wait_s = 15; refreshtime_ms = 7 / 2 * 60 * 1000; //Tobruk Campaign Settings/radar in desert was spottier/worse
                } 
            }
            //if (radar_realism >= 5) { wait_s = 5; refreshtime_ms = Convert.ToInt32 (0.02 * 60 * 1000); } //FOR TESTING - MUCH FASTER
            if (radar_realism >= 9) { wait_s = 30; refreshtime_ms = 5 * 60 * 1000; }

            //if admin==true we'll list ALL aircraft regardless of position, radars out et.
            //admin==false we start filtering out depending on whether a radar station has been knocked out etc
            bool admin = false;
            if ((radar_realism == 0) || (radar_realism == -1 && playerArmy == -3) || (radar_realism == -1 && playerArmy == -4)) admin = true;

            //RadarArmy is the army/side for which the radar is being generated.
            //Some radar areas will be out for Red but still active for Blue.  Blue radar might have some inherent restrictions Red radar doesn't, etc. 
            //if radarArmy==0 it will be more an admin radar that ignores these restrictions
            int radarArmy = Math.Abs(playerArmy);
            if (radarArmy > 2) radarArmy = 0;

            //Zero out the GiantSectorOverview totals (BEFORE starting any loops involving them, dur)
            if (playerArmy == -1 || playerArmy == -2) GiantSectorOverview[-playerArmy] = new int[10, 2]; //A simple count of how many enemy airgroups & aircraft in this sector
            if (playerArmy == -4) GiantSectorOverview[0] = new int[10, 2]; //both sides, for admin purposes (army = 0)

            //wait_s = 1; //for testing
            //refreshtime_ms = 1 * 1000;

            enorfriend = "ENEMY";
            if (inOwnArmy) enorfriend = "FRIENDLY";
            if (playerArmy < 0) enorfriend = "BOTH ARMIES";


            try
            {
                if (player != null && player.Place() != null && (player.Place() is AiAircraft))
                {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"
                    p = player.Place() as AiAircraft;
                    pa = player.Place();

                    if (airGroupInfoDict != null && p.AirGroup() != null && airGroupInfoDict.ContainsKey(p.AirGroup()))
                    {
                        padig = airGroupInfoDict[p.AirGroup()];
                        player_Vwld = new Vector3d(padig.vel.x, padig.vel.y, padig.vel.z);
                        player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                        player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                        player_alt_m = padig.pos.z;
                        // player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                        //player_sector = player_sector.Replace(",", ""); // remove the comma 
                        player_sector = Calcs.correctedSectorName(this, padig.pos);
                        player_place_set = true;
                        playername = player.Name();
                        playertype = padig.type;

                        ppos = padig.pos;

                    }
                    else
                    {


                        player_Vwld = p.AirGroup().Vwld();
                        player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                        player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                        player_alt_m = p.Pos().z;
                        // player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                        //player_sector = player_sector.Replace(",", ""); // remove the comma 
                        player_sector = Calcs.correctedSectorName(this, p.Pos());
                        player_place_set = true;
                        playername = player.Name();
                        playertype = p.Type().ToString();
                        if (playertype.Contains("Fighter") || playertype.Contains("fighter")) playertype = "F";
                        else if (playertype.Contains("Bomber") || playertype.Contains("bomber")) playertype = "B";
                        else playertype = "U";

                        ppos = p.Pos();
                    }

                    string posmessageCSP;
                    string speedMsg = player_vel_mph.ToString("F0") + "mph ";
                    if (playerArmy == 2) speedMsg = (player_vel_mps * 3.6).ToString("F0") + "km/h ";
                    playerOffRadar = offRadar(player);

                    posmessageCSP = "Radar intercepts are based on your speed/position as last detected at the command center: ";
                    if (playerOffRadar) posmessageCSP += "Unknown!";
                    else posmessageCSP += speedMsg + player_sector.ToString();

                    gpLogServerAndLog(new Player[] { player }, posmessageCSP, null);



                }
                else if (player == null && aiairgroup != null) //The case where we are asking for radar returns for an AIAirgroup
                {
                    if (airGroupInfoDict != null && airGroupInfoDict.ContainsKey(aiairgroup))
                    {
                        padig = airGroupInfoDict[aiairgroup];
                        if (aiairgroup != null && aiairgroup.GetItems().Length > 0) pa = aiairgroup.GetItems()[0];
                        else { Console.WriteLine("AIAGRRR: No a/c in this airgroup, returning"); return; }
                        p = pa as AiAircraft;
                        player_Vwld = new Vector3d(padig.vel.x, padig.vel.y, padig.vel.z);
                        player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                        player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                        player_alt_m = padig.pos.z;
                        // player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                        //player_sector = player_sector.Replace(",", ""); // remove the comma 
                        player_sector = Calcs.correctedSectorName(this, padig.pos);
                        player_place_set = true;
                        playername = padig.playerNames; //the actor.Name() in case of ai groups
                        playertype = padig.type;

                        ppos = padig.pos;

                    }
                    else
                    {
                        return;  //if we're requesting aiairgroup contacts & they're not in the aiGroupInfoDict yet, we'll just skip it
                    }

                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Radar ERROR5: " + ex.ToString());
            }

            playername_index = playername + "_0";
            if (inOwnArmy) playername_index = playername + "_1";
            playername_index = playername_index + "_" + radar_realism.ToString();
            if (radar_realism < 0) playername_index = playername_index + "_" + playerArmy.ToString();

            savenewmessages = true; //save the messages that are generated
            currtime_ms = stopwatch.ElapsedMilliseconds;

            try
            {
                //If the person has requested a new radar return too soon, just repeat the old return verbatim
                //We have 3 cases:
                // #1. ok to give new radar return
                // #2. Too soon since last radar return to give a new one
                // #3. New radar return is underway but not finished, so don't give them a new one. 
                if (radar_realism > 0 && radar_messages_store != null && radar_messages_store.ContainsKey(playername_index) && display && player != null)
                {
                    message_data = radar_messages_store[playername_index];
                    long time_elapsed_ms = currtime_ms - message_data.Item1;
                    long time_until_new_s = (long)((refreshtime_ms - time_elapsed_ms) / 1000);
                    long time_elapsed_s = (long)time_elapsed_ms / 1000;
                    radar_messages = message_data.Item2;
                    if (time_elapsed_ms < refreshtime_ms || message_data.Item1 == -1)
                    {
                        string posmessageIP;
                        if (message_data.Item1 == -1) posmessageIP = "New radar returns are in process.  Your previous radar return:";
                        else posmessageIP = time_until_new_s.ToString("F0") + "s until " + playername + " can receive a new radar return.  Your previous radar return:";
                        gpLogServerAndLog(new Player[] { player }, posmessageIP, null);

                        Console.WriteLine("RAD: Giving old message to " + playername_index);

                        wait_s = 0;
                        storedtime_ms = message_data.Item1;
                        savenewmessages = false; //don't save the messages again because we aren't generating anything new


                        //Wait just 2 seconds, which gives people a chance to see the message about how long until they can request a new radar return.
                        Timeout(2, () =>
                        {
                            double delay = 0;
                            //print out the radar contacts in reverse sort order, which puts closest distance/intercept @ end of the list               
                            foreach (var mess in message_data.Item2)
                            {


                                delay += 0.2;
                                Timeout(delay, () =>
                                {
                                    if (radar_realism == 0) gpLogServerAndLog(new Player[] { player }, mess.Value + " : " + mess.Key, null);
                                    else gpLogServerAndLog(new Player[] { player }, mess.Value, null);
                                });

                            }
                        });
                    }

                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Radar ERROR4: " + ex.ToString());
            }

            //If they haven't requested a return before, or enough time has elapsed, give them a new return  
            if (savenewmessages)
            {
                try
                {
                    //When we start to work on the messages we save current messages (either blank or the previous one that was fetched from radar_messages_store)
                    //with special time code -1, which means that radar returns are currently underway; don't give them any more until finished.
                    radar_messages_store[playername_index] = new Tuple<long, SortedDictionary<string, string>>(-1, radar_messages);

                    if (radar_realism > 0 && display) twcLogServer(new Player[] { player }, "Fetching radar contacts, please stand by . . . ", null);




                    radar_messages = new SortedDictionary<string, string>(new ReverseComparer<string>());//clear it out before starting anew . . .           
                    radar_messages.Add("9999999999", " >>> " + enorfriend + " RADAR CONTACTS <<< ");

                    if (radar_realism < 0) radar_messages.Add("9999999998", "p" + Calcs.GetMD5Hash(radarpasswords[playerArmy].ToUpper())); //first letter 'p' indicates passward & next characters up to space or EOL are the password.  Can customize this per  type of return, randomize each mission, or whatever.
                                                                                                                                           //radar_realism < 0 is our returns for the online radar screen, -1 = red returns, -2 = blue returns, -3 = admin (ALL SEEING EYE) returns
                                                                                                                                           //passwords are CASEINSENSITIVE and the MD5 of the password is saved in the -radar.txt file for red, blue, and admin respectively



                    //List<Tuple<AiAircraft, int>> aircraftPlaces = new List<Tuple<AiAircraft, int>>();
                    if (GamePlay != null && GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
                    {
                        foreach (int army in GamePlay.gpArmies())
                        {
                            if ((playerArmy == -3 && radar_realism == -1) || radar_realism == 0) //case of admin TOPHAT OR admin in-game <pos, we list every a/c with no grouping
                                                                                                 //TODO: lots of dead code below now because this used to handle the cases of ALL playerArmy & ALL radar_realism types, before grouping.  This can be cleaned up now.
                            {
                                //List a/c in player army if "inOwnArmy" == true; otherwise lists a/c in all armies EXCEPT the player's own army
                                if (GamePlay.gpAirGroups(army) != null && GamePlay.gpAirGroups(army).Length > 0 && (!inOwnArmy ^ (army == playerArmy)))
                                {
                                    foreach (AiAirGroup airGroup in GamePlay.gpAirGroups(army))
                                    {
                                        posmessage = "";
                                        aigroup_count++;
                                        if (airGroup != null && airGroup.GetItems() != null && airGroup.GetItems().Length > 0)
                                        {
                                            poscount = airGroup.NOfAirc;
                                            foreach (AiActor actor in airGroup.GetItems())
                                            {
                                                if (actor is AiAircraft)
                                                {
                                                    AiAircraft a = actor as AiAircraft;
                                                    //if (!player_place_set &&  (a.Place () is AiAircraft)) {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"


                                                    //Check on any radar outages or restrictions for each army, and remove any radar returns from areas where radar is restricted or inoperative
                                                    //if (!MO_isRadarEnabledByArea(a.Pos(), admin, radarArmy)) break; //breaks us out of this airGroup
                                                    //TOBRUK
                                                    if (!MO_isRadarEnabledByArea_TOBRUK(a.Pos(), admin, radarArmy)) break; //breaks us out of this airGroup

                                                    if (!player_place_set)
                                                    {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"                                                                        
                                                        p = actor as AiAircraft;
                                                        player_Vwld = p.AirGroup().Vwld();
                                                        player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                                                        player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                                                        player_alt_m = p.Pos().z;
                                                        /* player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                                                        player_sector = player_sector.Replace(",", ""); // remove the comma */
                                                        player_sector = Calcs.correctedSectorName(this, p.Pos());
                                                        ppos = p.Pos();
                                                        player_place_set = true;
                                                    }

                                                    bool isAI = isAiControlledPlane2(a);

                                                    string acType = Calcs.GetAircraftType(a);
                                                    isHeavyBomber = Calcs.isHeavyBomber(acType);

                                                    type = a.Type().ToString().ToUpper();
                                                    if (type.Contains("FIGHTER") || type.Contains("JABO") || type.Contains("SCOUT")) type = "F";
                                                    else if (type.Contains("BOMBER") || type.Contains("AMPHIB") || type.Contains("BLENHEIM")) type = "B";
                                                    else type = type.Substring(0, 1);  //Otherwise, the first letter - whatever it is

                                                    if (a == p && radar_realism >= 0) type = "Your position (" + p.Pos().x.ToString("N0") + ", " + p.Pos().y.ToString("N0") + ", " + p.Pos().z.ToString("N0") + ")";
                                                    /* if (DEBUG) twcLogServer(new Player[] { player }, "DEBUG: Destroying: Airgroup: " + a.AirGroup() + " " 
                                                     
                                                     + a.Type() + " " 
                                                     + a.TypedName() + " " 
                                                     +  a.AirGroup().ID(), new object[] { });
                                                    */
                                                    pos1 = a.Pos();
                                                    //Thread.Sleep(100);
                                                    //pos2=a.Pos();
                                                    //bearing=Calcs.CalculateGradientAngle (pos1,pos2);
                                                    Vwld = airGroup.Vwld();
                                                    vel_mps = Calcs.CalculatePointDistance(Vwld);
                                                    vel_mph = Calcs.meterspsec2milesphour(vel_mps);
                                                    vel_mph_10 = Calcs.RoundInterval(vel_mph, 10);
                                                    heading = (Calcs.CalculateBearingDegree(Vwld));
                                                    heading_10 = Calcs.GetDegreesIn10Step(heading);
                                                    dis_m = Calcs.CalculatePointDistance(a.Pos(), p.Pos());
                                                    dis_mi = Calcs.meters2miles(dis_m);
                                                    dis_10 = (int)dis_mi;
                                                    if (dis_mi > 20) dis_10 = Calcs.RoundInterval(dis_mi, 10);
                                                    bearing = Calcs.CalculateGradientAngle(p.Pos(), a.Pos());
                                                    bearing_10 = Calcs.GetDegreesIn10Step(bearing);

                                                    longlat = Calcs.Il2Point3dToLongLat(a.Pos());

                                                    alt_km = a.Pos().z / 1000;
                                                    alt_ft = Calcs.meters2feet(a.Pos().z);
                                                    altAGL_m = (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?
                                                    altAGL_ft = Calcs.meters2feet(altAGL_m);
                                                    alt_angels = Calcs.Feet2Angels(alt_ft);
                                                    sector = GamePlay.gpSectorName(a.Pos().x, a.Pos().y).ToString();
                                                    sector = sector.Replace(",", ""); // remove the comma
                                                    VwldP = new Point3d(Vwld.x, Vwld.y, Vwld.z);

                                                    intcpt = Calcs.calculateInterceptionPoint(a.Pos(), VwldP, p.Pos(), player_vel_mps);
                                                    intcpt_heading = (Calcs.CalculateGradientAngle(p.Pos(), intcpt));
                                                    intcpt_time_min = intcpt.z / 60;
                                                    /* intcpt_sector = GamePlay.gpSectorName(intcpt.x, intcpt.y).ToString();
                                                    intcpt_sector = intcpt_sector.Replace(",", ""); // remove the comma */
                                                    intcpt_sector = Calcs.correctedSectorName(this, intcpt);
                                                    intcpt_reasonable_time = (intcpt_time_min >= 0.02 && intcpt_time_min < 20);

                                                    climb_possible = true;
                                                    if (player_alt_m <= a.Pos().z && intcpt_time_min > 1)
                                                    {
                                                        double altdiff_m = a.Pos().z - player_alt_m;
                                                        if (intcpt_time_min > 3 && altdiff_m / intcpt_time_min > 1100) { climb_possible = false; } //109 can climb @ a little over 1000 meters per minute in a sustained way.  So anything that requires more climb than that we exclude from the listing
                                                        else if (altdiff_m / intcpt_time_min > 2500) climb_possible = false; //We allow for the possibility of more climb for a brief time, less then 3 minutes

                                                    }

                                                    string mi = dis_mi.ToString("F0") + "mi";
                                                    string mi_10 = dis_10.ToString("F0") + "mi";
                                                    string ft = alt_ft.ToString("F0") + "ft ";
                                                    string ftAGL = altAGL_ft.ToString("F0") + "ftAGL ";
                                                    string mph = vel_mph.ToString("F0") + "mph";
                                                    string ang = "A" + alt_angels.ToString("F0") + " ";

                                                    if (playerArmy == 2) //metric for the Germanos . . . 
                                                    {
                                                        mi = (dis_m / 1000).ToString("F0") + "k";
                                                        mi_10 = mi;
                                                        if (dis_m > 30000) mi_10 = ((double)(Calcs.RoundInterval(dis_m, 10000)) / 1000).ToString("F0") + "k";

                                                        ft = alt_km.ToString("F2") + "k ";
                                                        ftAGL = altAGL_m.ToString("F0") + "mAGL ";
                                                        mph = (Calcs.RoundInterval(vel_mps * 3.6, 10)).ToString("F0") + "k/h";
                                                        ang = ((double)(Calcs.RoundInterval(alt_km * 10, 5)) / 10).ToString("F1") + "k ";
                                                    }

                                                    //comprehensive radar returns for tophat/sysadmin purposes
                                                    //TODO:
                                                    //Add strong server-generated password for each session that can be communicated to admins etc
                                                    //Make a more filtered "TopHat" version that could be actually used by a commander/mission 
                                                    //control during missions, and also broadcast instructions & password for one person
                                                    //(or maybe a couple of people, or maybe everyone ? ) from each side to be able to use
                                                    //the more filtered version that is pretty comparable to what is already 
                                                    //shown as text radar in-mission
                                                    //TODO: 
                                                    //We could give Blue tophat measurements in metric units, maybe
                                                    if (radar_realism < 0)
                                                    {

                                                        string numContacts = poscount.ToString();
                                                        string aircraftType = Calcs.GetAircraftType(a);
                                                        string vel = vel_mph.ToString("n0");
                                                        string alt = alt_angels.ToString("n0");
                                                        string he = heading.ToString("F0");


                                                        bool first = true;
                                                        string aplayername = "";

                                                        //if (a.Player(0) != null && a.Player(0).Name() != null) aplayername = a.Player(0).Name(); //old way, only gets one player and only if in the pilot seat

                                                        HashSet<string> namesHS = new HashSet<string>();
                                                        for (int i = 0; i < a.Places(); i++)
                                                        {
                                                            if (a.Player(i) != null && a.Player(i).Name() != null && a.Player(i).Name() != null && !namesHS.Contains(a.Player(i).Name()))
                                                            {
                                                                if (!first) aplayername += " - ";
                                                                aplayername += a.Player(i).Name();
                                                                namesHS.Add(a.Player(i).Name());
                                                                first = false;

                                                            }
                                                        }

                                                        //aplayername = agid.AGGplayerNames;

                                                        //red & blue tophat operators only get an approximation of how many a/c in each group and also
                                                        //don't get perfect information about whether fighters or bombers or unknown
                                                        //and also don't get the EXACT type of a/c or the name of the player
                                                        if (playerArmy == -1 || playerArmy == -2)
                                                        {
                                                            numContacts = "~" + Calcs.NoOfAircraft(poscount).ToString("F0");
                                                            if (random.Next(8) == 1)
                                                            { //oops, sometimes we get mixed up on the type.  So sad . . .  See notes below about relative inaccuracy of early radar.
                                                                type = "F";
                                                                if (random.Next(3) == 1) type = "B";
                                                                if (random.Next(8) == 1) type = "U";
                                                            }
                                                            aircraftType = "";
                                                            aplayername = "";

                                                            vel = vel_mph_10.ToString("n0");
                                                            alt = alt_angels.ToString("n0");
                                                            he = heading_10.ToString("F0");

                                                        }


                                                        posmessage =
                                                        a.Pos().x.ToString()
                                                        + "," + a.Pos().y.ToString() + "," +
                                                        longlat.y.ToString()
                                                        + "," + longlat.x.ToString() + "," +
                                                        army.ToString() + "," +
                                                        type + "," +
                                                        he + "," +
                                                        vel + "," +
                                                        alt + "," +
                                                        sector.ToString() + "," +
                                                        numContacts + "," +
                                                        aircraftType.Replace(',', '_') + "," //Replace any commas since we are using comma as a delimiter here
                                                        + a.Name().GetHashCode().ToString() + "," //unique hashcode for each actor that will allow us to be able to identify it uniquely on the other end, without giving away anything about what type of actor it is (what type of aircraft, whether AI or live player, etc)
                                                        + aplayername.Replace(',', '_'); //Replace any commas since we are using comma as a delimiter here

                                                        //-radar.txt data file structure is:
                                                        //First line header info - just ignore it
                                                        //Each succeeding line is comma delimited, no quotation marks:
                                                        //0 & 1 - posx & posy (meters), 2 & 3 - lat & long (approximate & not too accurate) 
                                                        //4 - army (int), 5 type (string, F or B), 6 Heading (degrees), 7 vel (int, MPH), 
                                                        //8 - altitude (int, Angels, 1000s of feet), 9 - IL2 CloD sector (string)
                                                        //10 - how many in this formation (int, exact)
                                                        //11 - aircraft type (string, exact type & CloD a/c name)
                                                        //12 - unique hashcode (int) for this actor (not actually 100% guaranteed to be unique but fast & probably good enough for our simple purposes)
                                                        //13 - player steam name (string) if it exists


                                                        //For red & blue TopHot operators we give a slightly filtered view of the contacts,
                                                        //simulating what actual WWII radar could see
                                                        //For example contacts low to the ground fade out.
                                                        //TODO: We could set up radar towers & contacts could be seen better if closer to the 
                                                        //tower (ie, lower to the ground.  But then if the enemy destroys your tower you lose
                                                        //that & can only see what your remaining towers can see (which will likely be contacts only quite high in altitude)
                                                        //Also each army could have its own towers giving it better visibility on its own side of the lines where its own towers
                                                        //are etc
                                                        if ((playerArmy == -1 || playerArmy == -2) && (
                                                                       belowRadar(altAGL_ft, vel_mps, airGroup, a) || //unified method for deciding below radar or not
                                                                       ((!isAI && isHeavyBomber) && poscount <= 2 && random.Next(3) == 1) || // Breather bombers have a much higher chance of being overlooked/dropping out 
                                                                                                                                             //However if the player heavy bombers group up they are MUCH more likely to show up on radar.  But they will still be harder than usual to track because each individual bomber will phase in/out quite often

                                                                       (random.Next(7) == 1)  //it just malfunctions & shows nothing 1/7 of the time, for no reason, because. Early radar wasn't 100% reliable at all
                                                                       )
                                                       ) { posmessage = ""; }


                                                    }
                                                    else if (radar_realism == 0)
                                                    {
                                                        posmessage = poscount.ToString() + type + " " +

                                                          mi +
                                                          bearing.ToString("F0") + "°" +
                                                          ft +
                                                          ftAGL +
                                                          mph +
                                                          heading.ToString("F0") + "° " +
                                                          sector.ToString() + " " +
                                                          Calcs.GetAircraftType(a);
                                                        if (intcpt_time_min > 0.02)
                                                        {
                                                            posmessage +=
                                                               " Intcpt: " +
                                                               intcpt_heading.ToString("F0") + "°" +
                                                               intcpt_time_min.ToString("F0") + "min " +
                                                               intcpt_sector + " " +
                                                               intcpt.x.ToString("F0") + " " + intcpt.y.ToString("F0");
                                                        }

                                                        /* "(" + 
                                                        Calcs.meters2miles(a.Pos().x).ToString ("F0") + ", " +
                                                        Calcs.meters2miles(a.Pos().y).ToString ("F0") + ")";
                                                        */
                                                        //twcLogServer(new Player[] { player }, posmessage, new object[] { });
                                                    }
                                                    else if (radar_realism > 0)
                                                    {

                                                        //dropoutValue used below to randomly drop some readings from the radar.  As group gets larger the chance of dropouts goes to nil.
                                                        int dropoutValue = 7;
                                                        if (poscount > 5) dropoutValue = Convert.ToInt32(7 * poscount ^ 2 / 25);


                                                        //Trying to give at least some semblance of reality based on capabilities of Chain Home & Chain Home Low
                                                        //https://en.wikipedia.org/wiki/Chain_Home
                                                        //https://en.wikipedia.org/wiki/Chain_Home_Low
                                                        if (random.Next(8) == 1)
                                                        { //oops, sometimes we get mixed up on the type.  So sad . . .  See notes below about relative inaccuracy of early radar.
                                                            type = "F";
                                                            if (random.Next(3) == 1) type = "B";
                                                        }
                                                        if (dis_mi <= 2 && a != p && Math.Abs(player_alt_m - a.Pos().z) < 5000)
                                                        {
                                                            posmessage = type + " nearby";
                                                        }
                                                        //Below conditions are situations where radar doesn't work/fails, working to integrate realistic conditions for radar
                                                        //To do this in full realism we'd need the full locations of Chain Home & Chain Home Low stations & exact capabilities
                                                        //As an approximation we're using distance from the current aircraft, altitude, etc.
                                                        /* wikipedia gives an idea of how rough early CH output & methods were: CH output was read with an oscilloscope. When a pulse was sent from the broadcast towers, a visible line travelled horizontally across the screen very rapidly. The output from the receiver was amplified and fed into the vertical axis of the scope, so a return from an aircraft would deflect the beam upward. This formed a spike on the display, and the distance from the left side – measured with a small scale on the bottom of the screen – would give target range. By rotating the receiver goniometer connected to the antennas, the operator could estimate the direction to the target (this was the reason for the cross shaped antennas), while the height of the vertical displacement indicated formation size. By comparing the strengths returned from the various antennas up the tower, altitude could be gauged with some accuracy.
                                                         * Upshot is, exact #, position, no of aircraft, type of aircraft, altitude etc were NOT that precisely known.  Rather they were estimates/guesstimates based on strength of pulse of the radar return as viewed on an oscilliscope etc.
                                                         * ******************/
                                                        else if ((dis_mi >= 50 && poscount < 8 && random.Next(15) > 1 && !intcpt_reasonable_time) ||  //don't show enemy groups too far away, unless they are quite large, or can be intercepted in reasonable time.  Except once in a while randomly show one.
                                                                 (dis_mi >= 25 && poscount < 4 && random.Next(12) > 1 && !intcpt_reasonable_time) ||
                                                                 (dis_mi >= 15 && poscount <= 2 && random.Next(8) > 1 && !intcpt_reasonable_time) ||
                                                                 (!climb_possible && playertype != "B" && army != playerArmy) ||  //If the aircraft is too high for us to be able to climb to, we exclude it from the listing, unless the player is a bomber pilot (who is going to be interested in which planes are above in attack position) OR we are getting a listing of our own army, in which case we want all nearby a/c not just ones we can attack
                                                                 (dis_mi >= 70 && altAGL_ft < 4500) || //chain home only worked above ~4500 ft & Chain Home Low had effective distance only 35 miles
                                                                                                       //however, to implement this we really need the distance of the target from the CHL stations, not the current aircraft
                                                                                                       //We'll approximate it by eliminating low contacts > 70 miles away from current a/c 
                                                                 (dis_mi >= 10 && altAGL_ft < 650 && altAGL_ft < random.Next(500)) || //low contacts become less likely to be seen the lower they go.  Chain Low could detect only to about 4500 ft, though that improved as a/c came closer to the radar facility.
                                                                                                                                      //but Chain Home Low detected targets well down to 500 feet quite early in WWII and after improvements, down to 50 feet.  We'll approximate this by
                                                                                                                                      //phasing out targets below 250 feet.

                                                                belowRadar(altAGL_ft, vel_mps, airGroup, a) || //unified method for deciding below radar or not
                                                                 ((!isAI && isHeavyBomber && army != playerArmy) && dis_mi > 11 && poscount <= 2 && random.Next(4) <= 2) || // Breather bombers have a higher chance of being overlooked/dropping out, especially when further away.  3/4 times it doesn't show up on radar.
                                                                 ((!isAI && isHeavyBomber && army != playerArmy) && dis_mi <= 11 && poscount <= 2 && random.Next(5) == 1) || // Breather bombers have a much higher chance of being overlooked/dropping out when close (this is close enough it should be visual range, so we're not going to help them via radar)
                                                                                                                                                                             //((!isAI && type == "B" && army != playerArmy) && random.Next(5) > 0) || // Enemy bombers don't show up on your radar screen if less than 7 miles away as a rule - just once in a while.  You'll have to spot them visually instead at this distance!
                                                                                                                                                                             //We're always showing breather FIGHTERS here (ie, they are not included in isAI || type == "B"), because they always show up as a group of 1, and we'd like to help them find each other & fight it out
                                                                 (random.Next(dropoutValue) == 1)  //it just malfunctions & shows nothing 1/dropoutValue of the time, for no reason, because. Early radar wasn't 100% reliable at all. dropoutValue is 7 for small groups & increases rather quickly as the groups get larger, so that large groups don't drop out so much
                                                                 ) { posmessage = ""; }
                                                        else
                                                        {
                                                            posmessage = type + " " +
                                                               mi_10 +
                                                               bearing_10.ToString("F0") + "°" +
                                                               ang +
                                                               mph +
                                                               heading_10.ToString("F0") + "° ";
                                                            //+ sector.ToString();
                                                            if (intcpt_time_min >= 0.02)
                                                            {
                                                                posmessage +=
                                                                   " Intcpt: " +
                                                                   intcpt_heading.ToString("F0") + "°" +
                                                                   intcpt_time_min.ToString("F0") + "min ";
                                                                //+ intcpt_sector + " ";
                                                            }

                                                        }

                                                    }




                                                    //poscount+=1;
                                                    break; //only get 1st a/c in each group, to save time/processing


                                                }
                                            }



                                            //We'll print only one message per Airgroup, to reduce clutter
                                            //twcLogServer(new Player[] { player }, "RPT: " + posmessage + posmessage.Length.ToString(), new object[] { });
                                            if (posmessage.Length > 0)
                                            {
                                                //gpLogServerAndLog(new Player[] { player }, "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + "" + posmessage, null);
                                                //Console.WriteLine("ADMIN: ~" + Calcs.NoOfAircraft(poscount).ToString("F0") + "" + posmessage, null);
                                                //We add the message to the list along with an index that will allow us to reverse sort them in a logical/useful order                               
                                                int intcpt_time_index = (int)intcpt_time_min;
                                                if (intcpt_time_min <= 0 || intcpt_time_min > 99) intcpt_time_index = 99;

                                                try
                                                {
                                                    string addMess = posmessage;
                                                    if (radar_realism > 0) addMess = "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + posmessage;
                                                    radar_messages.Add(
                                                       ((int)intcpt_time_index).ToString("D2") + ((int)dis_mi).ToString("D3") + aigroup_count.ToString("D5"), //adding aigroup ensure uniqueness of index
                                                       addMess
                                                    );
                                                }
                                                catch (Exception e)
                                                {
                                                    Console.WriteLine("RadError: " + e);
                                                }

                                            }
                                        }
                                    }

                                }
                            }
                            //Using our GROUPED AirGroups instead of chunking through each individual aircraft
                            //This should apply to Red & Blue TOPHAT plus all in-game player radar (tab-7-1 etc)
                            else
                            {
                                try
                                {
                                    //List a/c in player army if "inOwnArmy" == true; otherwise lists a/c in all armies EXCEPT the player's own army
                                    if (GamePlay.gpAirGroups(army) != null && GamePlay.gpAirGroups(army).Length > 0 && (!inOwnArmy ^ (army == playerArmy)))
                                    {
                                        //if (CurrentAGGroupLeaders[army] != null) foreach (AiAirGroup airGroup in CurrentAGGroupLeaders[army])
                                        if (airGroupInfoDict != null) foreach (AiAirGroup airGroup in airGroupInfoDict.Keys)
                                            {
                                                posmessage = "";
                                                if (airGroup == null) continue;

                                                //Console.WriteLine("LPAA: Processing ag: PA{0} {1} {2} ", playerArmy, airGroup.getArmy(), airGroup.NOfAirc);
                                                AirGroupInfo agid = airGroupInfoDict[airGroup];
                                                if (agid.actor == null) continue; //can't do anything with this . . .
                                                if (agid.actor.Army() != army) continue;
                                                if (!agid.isLeader) continue;

                                                //Console.WriteLine("LPAA: Processing ag: PA{0} {1} {2} ", playerArmy, agid.actor.Army(), agid.actor.Name());

                                                aigroup_count++;
                                                /*
                                                AirGroupInfo agid = new AirGroupInfo();
                                                if (airGroupInfoDict != null && airGroupInfoDict.ContainsKey(airGroup))
                                                {
                                                    agid = airGroupInfoDict[airGroup];
                                                }
                                                else continue; //this shouldn't happen except at startup etc.  If it does we want to continue to try each succeeding airgroup, hopefully some of them will work
                                                */

                                                AiActor actor = agid.actor;
                                                AiAircraft a = actor as AiAircraft;
                                                if (a == null) continue; //can't do anything with null
                                                //if (!player_place_set &&  (a.Place () is AiAircraft)) {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"
                                                totalcount = agid.AGGcount;
                                                poscount = agid.AGGcountAboveRadar;
                                                belowradarcount = agid.AGGcountBelowRadar;

                                                //Check on any radar outages or restrictions for each army, and remove any radar returns from areas where radar is restricted or inoperative
                                                //if (!MO_isRadarEnabledByArea(agid.AGGavePos, admin, radarArmy)) continue;
                                                //TOBRUK
                                                if (!MO_isRadarEnabledByArea_TOBRUK(agid.AGGavePos, admin, radarArmy)) continue;

                                                //Console.WriteLine("LPAA: Processing ag2: PA{0} {1} {2} ", playerArmy, airGroup.getArmy(), airGroup.NOfAirc);

                                                if (!player_place_set)
                                                {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"                                                                        
                                                    p = actor as AiAircraft;
                                                    player_Vwld = p.AirGroup().Vwld();
                                                    player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                                                    player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                                                    player_alt_m = p.Pos().z;
                                                    /* player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                                                    player_sector = player_sector.Replace(",", ""); // remove the comma */
                                                    player_sector = Calcs.correctedSectorName(this, p.Pos());

                                                    ppos = p.Pos();

                                                    player_place_set = true;
                                                }

                                                bool isAI = (agid.AGGAIorHuman == aiorhuman.AI);

                                                string acType = agid.AGGtypeNames;
                                                isHeavyBomber = agid.AGGisHeavyBomber;


                                                type = agid.AGGtype;

                                                //if (a == p && radar_realism >= 0) type = "Your position";
                                                if (a == p && radar_realism >= 0) continue; //the player is in the DB and we don't want/need to give an intercept to self-location a while ago, as shown in the DB.
                                                /* if (DEBUG) twcLogServer(new Player[] { player }, "DEBUG: Destroying: Airgroup: " + a.AirGroup() + " " 

                                                 + a.Type() + " " 
                                                 + a.TypedName() + " " 
                                                 +  a.AirGroup().ID(), new object[] { });
                                                */
                                                pos1 = agid.AGGavePos;
                                                //Thread.Sleep(100);
                                                //pos2=a.Pos();
                                                //bearing=Calcs.CalculateGradientAngle (pos1,pos2);
                                                Vwld = new Vector3d(agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z);
                                                vel_mps = Calcs.CalculatePointDistance(Vwld);
                                                vel_mph = Calcs.meterspsec2milesphour(vel_mps);
                                                vel_mph_10 = Calcs.RoundInterval(vel_mph, 10);
                                                heading = (Calcs.CalculateBearingDegree(Vwld));
                                                heading_10 = Calcs.GetDegreesIn10Step(heading);
                                                dis_m = Calcs.CalculatePointDistance(agid.AGGavePos, p.Pos());
                                                dis_mi = Calcs.meters2miles(dis_m);
                                                dis_10 = (int)dis_mi;
                                                if (dis_mi > 20) dis_10 = Calcs.RoundInterval(dis_mi, 10);
                                                bearing = Calcs.CalculateGradientAngle(p.Pos(), agid.AGGavePos);
                                                bearing_10 = Calcs.GetDegreesIn10Step(bearing);

                                                longlat = Calcs.Il2Point3dToLongLat(agid.AGGavePos);

                                                //alt_km = agid.AGGavePos.z / 1000;
                                                //alt_ft = Calcs.meters2feet(agid.AGGavePos.z);
                                                alt_km = agid.AGGmaxAlt_m / 1000; //So rather than using average altitude, I think we must use MAX altitude of the group here. If not that, we should indicate a range or something
                                                alt_ft = Calcs.meters2feet(agid.AGGmaxAlt_m);
                                                //altAGL_m = (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?

                                                //We're using group leaders alt & AGL to get aveAGL for the entire group. Formula: AveAlt - (alt-AGL) = AveAGL
                                                //altAGL_m = agid.AGGaveAlt - (agid.pos.z - (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0)); // I THINK (?) that Z_AltitudeAGL is in meters?
                                                //altAGL_ft = Calcs.meters2feet(altAGL_m);
                                                altAGL_ft = agid.AGGavealtAGL_ft;
                                                altAGL_m = Calcs.feet2meters(altAGL_ft);

                                                alt_angels = Calcs.Feet2Angels(alt_ft);
                                                sector = GamePlay.gpSectorName(agid.AGGavePos.x, agid.AGGavePos.y).ToString();
                                                sector = sector.Replace(",", ""); // remove the comma
                                                VwldP = new Point3d(agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z);

                                                intcpt = Calcs.calculateInterceptionPoint(agid.AGGavePos, VwldP, ppos, player_vel_mps);
                                                intcpt_heading = (Calcs.CalculateGradientAngle(ppos, intcpt));
                                                intcpt_time_min = intcpt.z / 60;
                                                /* intcpt_sector = GamePlay.gpSectorName(intcpt.x, intcpt.y).ToString();
                                                intcpt_sector = intcpt_sector.Replace(",", ""); // remove the comma */
                                                intcpt_sector = Calcs.correctedSectorName(this, intcpt);
                                                intcpt_reasonable_time = (intcpt_time_min >= 0.02 && intcpt_time_min < 25);

                                                climb_possible = true;
                                                if (player_alt_m <= agid.AGGminAlt_m && intcpt_time_min > 1)
                                                {
                                                    double altdiff_m = agid.AGGminAlt_m - player_alt_m;
                                                    if (intcpt_time_min > 3 && altdiff_m / intcpt_time_min > 1300) { climb_possible = false; } //109 can climb @ a little over 1000 meters per minute in a sustained way.  So anything that requires more climb than that we exclude from the listing
                                                    else if (altdiff_m / intcpt_time_min > 2500) climb_possible = false; //We allow for the possibility of more climb for a brief time, less then 3 minutes

                                                }

                                                string mi = dis_mi.ToString("F0") + "mi";
                                                string mi_10 = dis_10.ToString("F0") + "mi";
                                                string ft = alt_ft.ToString("F0") + "ft ";
                                                string ftAGL = altAGL_ft.ToString("F0") + "ftAGL ";
                                                string mph = vel_mph.ToString("F0") + "mph";
                                                string ang = "A" + alt_angels.ToString("F0") + " ";

                                                if (playerArmy == 2) //metric for the Germanos . . . 
                                                {
                                                    mi = (dis_m / 1000).ToString("F0") + "k";
                                                    mi_10 = mi;
                                                    if (dis_m > 30000) mi_10 = ((double)(Calcs.RoundInterval(dis_m, 10000)) / 1000).ToString("F0") + "k";

                                                    ft = alt_km.ToString("F2") + "k ";
                                                    ftAGL = altAGL_m.ToString("F0") + "mAGL ";
                                                    mph = (Calcs.RoundInterval(vel_mps * 3.6, 10)).ToString("F0") + "k/h";
                                                    ang = ((double)(Calcs.RoundInterval(alt_km * 10, 5)) / 10).ToString("F1") + "k ";
                                                }
                                                //comprehensive radar returns for tophat/sysadmin purposes
                                                //TODO:
                                                //Add strong server-generated password for each session that can be communicated to admins etc
                                                //Make a more filtered "TopHat" version that could be actually used by a commander/mission 
                                                //control during missions, and also broadcast instructions & password for one person
                                                //(or maybe a couple of people, or maybe everyone ? ) from each side to be able to use
                                                //the more filtered version that is pretty comparable to what is already 
                                                //shown as text radar in-mission
                                                //TODO: 
                                                //We could give Blue tophat measurements in metric units, maybe
                                                if (radar_realism < 0) //This applies to Red & Blue tophat, and Admin-Grouped Tophat which uses groupings.  Admin-regular tophat still uses individual per aircraft returns.
                                                {

                                                    string numContacts = poscount.ToString();
                                                    if (playerArmy == -4 && belowradarcount > 0) numContacts = poscount.ToString() + "+" + belowradarcount.ToString();  //for admin-grouping radar
                                                    string aircraftType = agid.AGGtypeNames;
                                                    string vel = vel_mph.ToString("n0");
                                                    string alt = alt_angels.ToString("n0");
                                                    string he = heading.ToString("F0");

                                                    string aplayername = agid.AGGplayerNames;
                                                    //if (isAI) aplayername = agid.AGGids;

                                                    //red & blue tophat operators only get an approximation of how many a/c in each group and also
                                                    //don't get perfect information about whether fighters or bombers or unknown
                                                    //and also don't get the EXACT type of a/c or the name of the player
                                                    if (playerArmy == -1 || playerArmy == -2)
                                                    {
                                                        numContacts = "~" + Calcs.NoOfAircraft(poscount).ToString("F0");

                                                        aircraftType = "";
                                                        aplayername = "";

                                                        vel = vel_mph_10.ToString("n0");
                                                        alt = alt_angels.ToString("n0");
                                                        he = heading_10.ToString("F0");

                                                    }


                                                    posmessage =
                                                    agid.AGGavePos.x.ToString()
                                                    + "," + agid.AGGavePos.y.ToString() + "," +
                                                    longlat.y.ToString()
                                                    + "," + longlat.x.ToString() + "," +
                                                    army.ToString() + "," +
                                                    agid.AGGmixupType + "," + //We use this to keep the (possibly mixed-up) a/c type standard among all types of radar, it is set once for all in agid instead of randomly set here for each individual radar sweep
                                                    he + "," +
                                                    vel + "," +
                                                    alt + "," +
                                                    sector.ToString() + "," +
                                                    numContacts + "," +
                                                    aircraftType.Replace(',', '_') + "," //Replace any commas since we are using comma as a delimiter here
                                                    + a.Name().GetHashCode().ToString() + "," //unique hashcode for each actor that will allow us to be able to identify it uniquely on the other end, without giving away anything about what type of actor it is (what type of aircraft, whether AI or live player, etc)
                                                    + aplayername.Replace(',', '_'); //Replace any commas since we are using comma as a delimiter here

                                                    try
                                                    {
                                                        if (playerArmy == -4)
                                                        {
                                                            GiantSectorOverview[0][agid.AGGgiantKeypad, 0]++; //A simple count of how many enemy airgroups (index = 0) in this sector
                                                            GiantSectorOverview[0][agid.AGGgiantKeypad, 1] += poscount; //A simple count of how many enemy aircraft (index =1) in this sector
                                                        }
                                                    }
                                                    catch (Exception ex) { Console.WriteLine("Radar ERROR: GiantSectorOverview (probably exceeded index): " + ex.ToString()); }

                                                    //-radar.txt data file structure is:
                                                    //First line header info - just ignore it
                                                    //Each succeeding line is comma delimited, no quotation marks:
                                                    //0 & 1 - posx & posy (meters), 2 & 3 - lat & long (approximate & not too accurate) 
                                                    //4 - army (int), 5 type (string, F or B), 6 Heading (degrees), 7 vel (int, MPH), 
                                                    //8 - altitude (int, Angels, 1000s of feet), 9 - IL2 CloD sector (string)
                                                    //10 - how many in this formation (int, exact)
                                                    //11 - aircraft type (string, exact type & CloD a/c name)
                                                    //12 - unique hashcode (int) for this actor (not actually 100% guaranteed to be unique but fast & probably good enough for our simple purposes)
                                                    //13 - player steam name (string) if it exists

                                                    //dropoutValue used below to randomly drop some readings from the radar.  As group gets larger the chance of dropouts goes to nil.
                                                    //int dropoutValue = 7;
                                                    //if (poscount > 5) dropoutValue = Convert.ToInt32(7 * poscount ^ 2 / 25);

                                                    //For red & blue TopHot operators we give a slightly filtered view of the contacts,
                                                    //simulating what actual WWII radar could see
                                                    //For example contacts low to the ground fade out.
                                                    //TODO: We could set up radar towers & contacts could be seen better if closer to the 
                                                    //tower (ie, lower to the ground.  But then if the enemy destroys your tower you lose
                                                    //that & can only see what your remaining towers can see (which will likely be contacts only quite high in altitude)
                                                    //Also each army could have its own towers giving it better visibility on its own side of the lines where its own towers
                                                    //are etc
                                                    if ((playerArmy == -1 || playerArmy == -2) && (
                                                                   belowRadar(altAGL_ft, vel_mps, airGroup, a) || //unified method for deciding below radar or not    
                                                                   poscount == 0 || //this happens if all a/c in a group are belowRadar
                                                                   agid.AGGradarDropout
                                                                   //((!isAI && isHeavyBomber) && poscount <= 2 && random.Next(3) == 1) || // Breather bombers have a much higher chance of being overlooked/dropping out 
                                                                   //However if the player heavy bombers group up they are MUCH more likely to show up on radar.  But they will still be harder than usual to track because each individual bomber will phase in/out quite often

                                                                   //(random.Next(dropoutValue) == 1)  //it just malfunctions & shows nothing 1/7 of the time, for no reason, because. Early radar wasn't 100% reliable at all
                                                                   )
                                                   )
                                                    {
                                                        //Console.WriteLine("Radar: Dropping contact {5} from map {0} bec agl {1:0} bR {2} ct {3} AGGrD {4}", playerArmy, altAGL_ft, belowRadar(altAGL_ft), poscount, agid.AGGradarDropout, a.Name());

                                                        posmessage = "";
                                                    }


                                                    //add to the GiantSectorOverview ONLY IF their is a radar return for this airgroup
                                                    if ((playerArmy == -1 || playerArmy == -2) && posmessage.Length > 0)
                                                    {
                                                        //we put this here bec. we want to tally only those ag & a/c that show in that side's radar display
                                                        if ((-playerArmy) != army)
                                                        {
                                                            GiantSectorOverview[(-playerArmy)][agid.AGGgiantKeypad, 0]++; //A simple count of how many enemy airgroups (index = 0) in this sector
                                                            GiantSectorOverview[(-playerArmy)][agid.AGGgiantKeypad, 1] += Calcs.NoOfAircraft(poscount); //A simple count of how many enemy aircraft (index =1) in this sector
                                                                                                                                                        //Console.WriteLine("RADadding: " + agid.AGGgiantKeypad.ToString() + " " + (-playerArmy).ToString() + " " + GiantSectorOverview[(-playerArmy)][agid.AGGgiantKeypad, 0].ToString() + " " + posmessage);

                                                        }
                                                        else
                                                        {
                                                            //Console.WriteLine("RADNOTadding: " + agid.AGGgiantKeypad.ToString() + " " + (-playerArmy).ToString() + " " + posmessage);
                                                        }

                                                    }


                                                }


                                                else if (radar_realism == 1)
                                                {
                                                    posmessage = poscount.ToString() + type + " " +

                                                      mi +
                                                      bearing.ToString("F0") + "°" +
                                                      ft +
                                                      ftAGL +
                                                      mph +
                                                      heading.ToString("F0") + "° " +
                                                      sector.ToString() + " " +
                                                      Calcs.GetAircraftType(a);
                                                    if (intcpt_time_min > 0.02)
                                                    {
                                                        posmessage +=
                                                           " Intcpt: " +
                                                           intcpt_heading.ToString("F0") + "°" +
                                                           intcpt_time_min.ToString("F0") + "min " +
                                                           intcpt_sector + " " +
                                                           intcpt.x.ToString("F0") + " " + intcpt.y.ToString("F0");
                                                    }

                                                    /* "(" + 
                                                    Calcs.meters2miles(a.Pos().x).ToString ("F0") + ", " +
                                                    Calcs.meters2miles(a.Pos().y).ToString ("F0") + ")";
                                                    */
                                                    //twcLogServer(new Player[] { player }, posmessage, new object[] { });
                                                }
                                                else if (radar_realism > 0)
                                                {

                                                    //Trying to give at least some semblance of reality based on capabilities of Chain Home & Chain Home Low
                                                    //https://en.wikipedia.org/wiki/Chain_Home
                                                    //https://en.wikipedia.org/wiki/Chain_Home_Low

                                                    //dropoutValue used below to randomly drop some readings from the radar.  As group gets larger the chance of dropouts goes to nil.
                                                    int dropoutValue = 7;
                                                    if (poscount > 5) { dropoutValue = Convert.ToInt32(7 * poscount ^ 2 / 25); }

                                                    if (dis_mi <= 2 && a != p && Math.Abs(player_alt_m - agid.AGGaveAlt_m) < 5000)
                                                    {
                                                        posmessage = agid.AGGmixupType + " nearby";
                                                    }
                                                    //Below conditions are situations where radar doesn't work/fails, working to integrate realistic conditions for radar
                                                    //To do this in full realism we'd need the full locations of Chain Home & Chain Home Low stations & exact capabilities
                                                    //As an approximation we're using distance from the current aircraft, altitude, etc.
                                                    /* wikipedia gives an idea of how rough early CH output & methods were: CH output was read with an oscilloscope. When a pulse was sent from the broadcast towers, a visible line travelled horizontally across the screen very rapidly. The output from the receiver was amplified and fed into the vertical axis of the scope, so a return from an aircraft would deflect the beam upward. This formed a spike on the display, and the distance from the left side – measured with a small scale on the bottom of the screen – would give target range. By rotating the receiver goniometer connected to the antennas, the operator could estimate the direction to the target (this was the reason for the cross shaped antennas), while the height of the vertical displacement indicated formation size. By comparing the strengths returned from the various antennas up the tower, altitude could be gauged with some accuracy.
                                                     * Upshot is, exact #, position, no of aircraft, type of aircraft, altitude etc were NOT that precisely known.  Rather they were estimates/guesstimates based on strength of pulse of the radar return as viewed on an oscilliscope etc.
                                                     * ******************/
                                                    else if ((dis_mi >= 50 && poscount < 8 && random.Next(15) > 1 && !intcpt_reasonable_time) ||  //don't show enemy groups too far away, unless they are quite large, or can be intercepted in reasonable time.  Except once in a while randomly show one.
                                                             (dis_mi >= 25 && poscount < 4 && random.Next(12) > 1 && !intcpt_reasonable_time) ||
                                                             (dis_mi >= 15 && poscount <= 2 && random.Next(8) > 1 && !intcpt_reasonable_time) ||
                                                             (!climb_possible && playertype != "B" && army != playerArmy) ||  //If the aircraft is too high for us to be able to climb to, we exclude it from the listing, unless the player is a bomber pilot (who is going to be interested in which planes are above in attack position) OR we are getting a listing of our own army, in which case we want all nearby a/c not just ones we can attack
                                                             (dis_mi >= 70 && altAGL_ft < 4500) || //chain home only worked above ~4500 ft & Chain Home Low had effective distance only 35 miles
                                                                                                   //however, to implement this we really need the distance of the target from the CHL stations, not the current aircraft
                                                                                                   //We'll approximate it by eliminating low contacts > 70 miles away from current a/c 
                                                             (dis_mi >= 10 && altAGL_ft < 650 && altAGL_ft < random.Next(500)) || //low contacts become less likely to be seen the lower they go.  Chain Low could detect only to about 4500 ft, though that improved as a/c came closer to the radar facility.
                                                                                                                                  //but Chain Home Low detected targets well down to 500 feet quite early in WWII and after improvements, down to 50 feet.  We'll approximate this by
                                                                                                                                  //phasing out targets below 250 feet.

                                                             belowRadar(altAGL_ft, vel_mps, airGroup, a) || //unified method for deciding below radar or not

                                                             poscount == 0 || //this happens if all a/c in a group are belowRadar
                                                             agid.AGGradarDropout && random.Next(3) == 1 || //For Tab-4-1 listings we honor the heavy bomber radar dropout only 33% of the time.  This is bec. the radar screen operators have ways of picking up tracks even if they appear just once in a while, but Tab-4-1 folks less so.

                                                             //((!isAI && isHeavyBomber && army != playerArmy) && dis_mi > 11 && poscount <= 2 && random.Next(4) <= 2) || // Breather bombers have a higher chance of being overlooked/dropping out, especially when further away.  3/4 times it doesn't show up on radar.

                                                             ((!isAI && isHeavyBomber && army != playerArmy) && dis_mi <= 4 && poscount <= 2 && random.Next(5) <= 3) // Breather bombers have a much higher chance of being overlooked/dropping out when close (this is close enough it should be visual range, so we're not going to help them via radar)
                                                                                                                                                                     //((!isAI && type == "B" && army != playerArmy) && random.Next(5) > 0) || // Enemy bombers don't show up on your radar screen if less than 7 miles away as a rule - just once in a while.  You'll have to spot them visually instead at this distance!
                                                                                                                                                                     //We're always showing breather FIGHTERS here (ie, they are not included in isAI || type == "B"), because they always show up as a group of 1, and we'd like to help them find each other & fight it out
                                                                                                                                                                     //(random.Next(dropoutValue) == 1)  //it just malfunctions & shows nothing 1/7 of the time, for no reason, because. Early radar wasn't 100% reliable at all
                                                             )
                                                    {
                                                        posmessage = "";
                                                        //posmessage = string.Format (dis_mi, )

                                                        /*
                                                        posmessage = type + " " +
                                                                        mi_10 +
                                                                        bearing_10.ToString("F0") + "°" +
                                                                        ang +
                                                                        mph +
                                                                        heading_10.ToString("F0") + "° " + sector.ToString();

                                                        if (intcpt_time_min >= 0.02)
                                                        {
                                                            posmessage +=
                                                               " Intcpt: " +
                                                               intcpt_heading.ToString("F0") + "°" +
                                                               intcpt_time_min.ToString("F0") + "min ";
                                                            //+ intcpt_sector + " ";
                                                        }
                                                        */
                                                    }
                                                    else
                                                    {
                                                        posmessage = agid.AGGmixupType + " " +
                                                           mi_10 +
                                                           bearing_10.ToString("F0") + "°" +
                                                           ang +
                                                           mph +
                                                           heading_10.ToString("F0") + "° ";
                                                        //+ sector.ToString();

                                                        if (!playerOffRadar && intcpt_time_min >= 0.02) //omit intercept messages when the player is below radar (need player position/speed to calculate intercept)
                                                        {
                                                            posmessage +=
                                                               " Intcpt: " +
                                                               intcpt_heading.ToString("F0") + "°" +
                                                               intcpt_time_min.ToString("F0") + "min ";
                                                            //+ intcpt_sector + " ";
                                                        }

                                                    }

                                                }


                                                //Console.WriteLine("Rad: pos " + posmessage);

                                                //We'll print only one message per Airgroup, to reduce clutter
                                                //twcLogServer(new Player[] { player }, "RPT: " + posmessage + posmessage.Length.ToString(), new object[] { });
                                                if (posmessage.Length > 0)
                                                {
                                                    //gpLogServerAndLog(new Player[] { player }, "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + "" + posmessage, null);
                                                    //Console.WriteLine("NON-ADMIN: ~" + Calcs.NoOfAircraft(poscount).ToString("F0") + "" + posmessage, null);
                                                    //We add the message to the list along with an index that will allow us to reverse sort them in a logical/useful order                               
                                                    int intcpt_time_index = (int)intcpt_time_min;
                                                    if (intcpt_time_min <= 0 || intcpt_time_min > 99) intcpt_time_index = 99;

                                                    try
                                                    {
                                                        string addMess = posmessage;
                                                        if (radar_realism > 0) addMess = "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + posmessage;
                                                        radar_messages.Add(
                                                           ((int)intcpt_time_index).ToString("D2") + ((int)dis_mi).ToString("D3") + aigroup_count.ToString("D5"), //adding aigroup ensure uniqueness of index
                                                           addMess
                                                        );


                                                        if (aiairgroup != null)
                                                        {
                                                            ai_radar_info.Add(
                                     ((int)intcpt_time_index).ToString("D2") + ((int)dis_mi).ToString("D3") + aigroup_count.ToString("D5"), //adding aigroup ensure uniqueness of index
                                     new AiAirGroupRadarInfo(this, agid, padig, intcpt, climb_possible)
                                  );
                                                            //Console.WriteLine("Adding ai_radar_info: {0} {1} {2} {3} {4}", intcpt.x, intcpt.y, intcpt.z, agid.playerNames, padig.playerNames);
                                                        }


                                                    }
                                                    catch (Exception e)
                                                    {
                                                        Console.WriteLine("RadErrorAdd: " + e);
                                                    }

                                                }
                                            }

                                    }
                                }
                                catch (Exception ex)
                                {
                                    Console.WriteLine("Radar ERROR2: " + ex.ToString());
                                }
                            }
                        }
                    }










                    /*
                                //Using our GROUPED AirGroups instead of chunking through each individual aircraft
                                else
                                {


                                    //List<Tuple<AiAircraft, int>> aircraftPlaces = new List<Tuple<AiAircraft, int>>();
                                    if (GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
                                    {
                                        foreach (int army in GamePlay.gpArmies())
                                        {
                                            //List a/c in player army if "inOwnArmy" == true; otherwise lists a/c in all armies EXCEPT the player's own army
                                            if (GamePlay.gpAirGroups(army) != null && GamePlay.gpAirGroups(army).Length > 0 && (!inOwnArmy ^ (army == playerArmy)))
                                            {
                                                //if (CurrentAGGroupLeaders[army] != null) foreach (AiAirGroup airGroup in CurrentAGGroupLeaders[army])
                                                if (airGroupInfoDict != null) foreach (AiAirGroup airGroup in airGroupInfoDict.Keys)
                                                    {

                                                        Console.WriteLine("LPAA: Processing ag: {0} {1} ", airGroup.getArmy(), airGroup.NOfAirc);
                                                        AirGroupInfo agid = airGroupInfoDict[airGroup];
                                                        if (agid.actor.Army() != army) continue;

                                                        Console.WriteLine("LPAA: Processing ag: {0} {1} ", agid.actor.Army(), agid.actor.Name());

                                                        aigroup_count++;


                                                        AiActor actor = agid.actor;
                                                        AiAircraft a = actor as AiAircraft;
                                                        //if (!player_place_set &&  (a.Place () is AiAircraft)) {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"

                                                        poscount = agid.AGGcount;

                                                        //Check on any radar outages or restrictions for each army, and remove any radar returns from areas where radar is restricted or inoperative
                                                        if (!MO_isRadarEnabledByArea(agid.AGGavePos, admin, radarArmy)) continue;

                                                        if (!player_place_set)
                                                        {  //if player==null or not in an a/c we use the very first a/c encountered as a "stand-in"                                                                        
                                                            p = actor as AiAircraft;
                                                            player_Vwld = p.AirGroup().Vwld();
                                                            player_vel_mps = Calcs.CalculatePointDistance(player_Vwld);
                                                            player_vel_mph = Calcs.meterspsec2milesphour(player_vel_mps);
                                                            player_alt_m = p.Pos().z;
                                                            // player_sector = GamePlay.gpSectorName(p.Pos().x, p.Pos().y).ToString();
                                                            //player_sector = player_sector.Replace(",", ""); // remove the comma 
                                                            player_sector = Calcs.correctedSectorName(this, p.Pos());
                                                            ppos = p.Pos();
                                                            player_place_set = true;
                                                        }

                                                        bool isAI = (agid.AGGAIorHuman == aiorhuman.AI);

                                                        string acType = agid.AGGtypeNames;
                                                        isHeavyBomber = agid.AGGisHeavyBomber;


                                                        type = agid.AGGtype;
                                                        if (a == p && radar_realism >= 0) type = "Your position";
                                                        // if (DEBUG) twcLogServer(new Player[] { player }, "DEBUG: Destroying: Airgroup: " + a.AirGroup() + " " 
                                                        
                                                        // + a.Type() + " " 
                                                        // + a.TypedName() + " " 
                                                        // +  a.AirGroup().ID(), new object[] { });

                                                        pos1 = agid.AGGavePos;
                                                        //Thread.Sleep(100);
                                                        //pos2=a.Pos();
                                                        //bearing=Calcs.CalculateGradientAngle (pos1,pos2);
                                                        Vwld = new Vector3d(agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z);
                                                        vel_mps = Calcs.CalculatePointDistance(Vwld);
                                                        vel_mph = Calcs.meterspsec2milesphour(vel_mps);
                                                        vel_mph_10 = Calcs.RoundInterval(vel_mph, 10);
                                                        heading = (Calcs.CalculateBearingDegree(Vwld));
                                                        heading_10 = Calcs.GetDegreesIn10Step(heading);
                                                        dis_m = Calcs.CalculatePointDistance(agid.AGGavePos, p.Pos());
                                                        dis_mi = Calcs.meters2miles(dis_m);
                                                        dis_10 = (int)dis_mi;
                                                        if (dis_mi > 20) dis_10 = Calcs.RoundInterval(dis_mi, 10);
                                                        bearing = Calcs.CalculateGradientAngle(p.Pos(), agid.AGGavePos);
                                                        bearing_10 = Calcs.GetDegreesIn10Step(bearing);

                                                        longlat = Calcs.Il2Point3dToLongLat(agid.AGGavePos);

                                                        alt_km = agid.AGGavePos.z / 1000;
                                                        alt_ft = Calcs.meters2feet(agid.AGGavePos.z);
                                                        //altAGL_m = (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?

                                                        //We're using group leaders alt & AGL to get aveAGL for the entire group. Formula: AveAlt - (alt-AGL) = AveAGL
                                                        altAGL_m = agid.AGGaveAlt - (agid.pos.z - (actor as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0)); // I THINK (?) that Z_AltitudeAGL is in meters?
                                                        altAGL_ft = Calcs.meters2feet(altAGL_m);
                                                        alt_angels = Calcs.Feet2Angels(alt_ft);
                                                        sector = GamePlay.gpSectorName(agid.AGGavePos.x, agid.AGGavePos.y).ToString();
                                                        sector = sector.Replace(",", ""); // remove the comma
                                                        VwldP = new Point3d(agid.AGGvel.x, agid.AGGvel.y, agid.AGGvel.z);

                                                        intcpt = Calcs.calculateInterceptionPoint(agid.AGGavePos, VwldP, p.Pos(), player_vel_mps);
                                                        intcpt_heading = (Calcs.CalculateGradientAngle(agid.AGGavePos, intcpt));
                                                        intcpt_time_min = intcpt.z / 60;
                                                        // intcpt_sector = GamePlay.gpSectorName(intcpt.x, intcpt.y).ToString();
                                                        //intcpt_sector = intcpt_sector.Replace(",", ""); // remove the comma 
                                                        intcpt_sector = Calcs.correctedSectorName(this, intcpt);
                                                        intcpt_reasonable_time = (intcpt_time_min >= 0.02 && intcpt_time_min < 20);

                                                        climb_possible = true;
                                                        if (player_alt_m <= agid.AGGminAlt && intcpt_time_min > 1)
                                                        {
                                                            double altdiff_m = agid.AGGminAlt - player_alt_m;
                                                            if (intcpt_time_min > 3 && altdiff_m / intcpt_time_min > 1300) { climb_possible = false; } //109 can climb @ a little over 1000 meters per minute in a sustained way.  So anything that requires more climb than that we exclude from the listing
                                                            else if (altdiff_m / intcpt_time_min > 2500) climb_possible = false; //We allow for the possibility of more climb for a brief time, less then 3 minutes

                                                        }

                                                        string mi = dis_mi.ToString("F0") + "mi";
                                                        string mi_10 = dis_10.ToString("F0") + "mi";
                                                        string ft = alt_ft.ToString("F0") + "ft ";
                                                        string ftAGL = altAGL_ft.ToString("F0") + "ftAGL ";
                                                        string mph = vel_mph.ToString("F0") + "mph";
                                                        string ang = "A" + alt_angels.ToString("F0") + " ";

                                                        if (playerArmy == 2) //metric for the Germanos . . . 
                                                        {
                                                            mi = (dis_m / 1000).ToString("F0") + "k";
                                                            mi_10 = mi;
                                                            if (dis_m > 30000) mi_10 = ((double)(Calcs.RoundInterval(dis_m, 10000)) / 1000).ToString("F0") + "k";

                                                            ft = alt_km.ToString("F2") + "k ";
                                                            ftAGL = altAGL_m.ToString("F0") + "mAGL ";
                                                            mph = (Calcs.RoundInterval(vel_mps * 3.6, 10)).ToString("F0") + "k/h";
                                                            ang = ((double)(Calcs.RoundInterval(alt_km * 10, 5)) / 10).ToString("F1") + "k ";
                                                        }
                                                        //comprehensive radar returns for tophat/sysadmin purposes
                                                        //TODO:
                                                        //Add strong server-generated password for each session that can be communicated to admins etc
                                                        //Make a more filtered "TopHat" version that could be actually used by a commander/mission 
                                                        //control during missions, and also broadcast instructions & password for one person
                                                        //(or maybe a couple of people, or maybe everyone ? ) from each side to be able to use
                                                        //the more filtered version that is pretty comparable to what is already 
                                                        //shown as text radar in-mission
                                                        //TODO: 
                                                        //We could give Blue tophat measurements in metric units, maybe
                                                        if (radar_realism < 0) //This applies to Red & Blue tophat, which uses groupings.  Admin tophat still uses individual per aircraft returns.
                                                        {

                                                            string numContacts = poscount.ToString();
                                                            string aircraftType = agid.AGGtypeNames;
                                                            string vel = vel_mph.ToString("n0");
                                                            string alt = alt_angels.ToString("n0");
                                                            string he = heading.ToString("F0");

                                                            string aplayername = agid.AGGplayerNames;

                                                            //red & blue tophat operators only get an approximation of how many a/c in each group and also
                                                            //don't get perfect information about whether fighters or bombers or unknown
                                                            //and also don't get the EXACT type of a/c or the name of the player
                                                            if (playerArmy == -1 || playerArmy == -2)
                                                            {
                                                                numContacts = "~" + Calcs.NoOfAircraft(poscount).ToString("F0");
                                                                if (random.Next(8) == 1)
                                                                { //oops, sometimes we get mixed up on the type.  So sad . . .  See notes below about relative inaccuracy of early radar.
                                                                    type = "F";
                                                                    if (random.Next(3) == 1) type = "B";
                                                                    if (random.Next(8) == 1) type = "U";
                                                                }
                                                                aircraftType = "";
                                                                aplayername = "";

                                                                vel = vel_mph_10.ToString("n0");
                                                                alt = alt_angels.ToString("n0");
                                                                he = heading_10.ToString("F0");

                                                            }


                                                            posmessage =
                                                            agid.AGGavePos.x.ToString()
                                                            + "," + agid.AGGavePos.y.ToString() + "," +
                                                            longlat.y.ToString()
                                                            + "," + longlat.x.ToString() + "," +
                                                            army.ToString() + "," +
                                                            type + "," +
                                                            he + "," +
                                                            vel + "," +
                                                            alt + "," +
                                                            sector.ToString() + "," +
                                                            numContacts + "," +
                                                            aircraftType.Replace(',', '_') + "," //Replace any commas since we are using comma as a delimiter here
                                                            + a.Name().GetHashCode().ToString() + "," //unique hashcode for each actor that will allow us to be able to identify it uniquely on the other end, without giving away anything about what type of actor it is (what type of aircraft, whether AI or live player, etc)
                                                            + aplayername.Replace(',', '_'); //Replace any commas since we are using comma as a delimiter here

                                                            //-radar.txt data file structure is:
                                                            //First line header info - just ignore it
                                                            //Each succeeding line is comma delimited, no quotation marks:
                                                            //0 & 1 - posx & posy (meters), 2 & 3 - lat & long (approximate & not too accurate) 
                                                            //4 - army (int), 5 type (string, F or B), 6 Heading (degrees), 7 vel (int, MPH), 
                                                            //8 - altitude (int, Angels, 1000s of feet), 9 - IL2 CloD sector (string)
                                                            //10 - how many in this formation (int, exact)
                                                            //11 - aircraft type (string, exact type & CloD a/c name)
                                                            //12 - unique hashcode (int) for this actor (not actually 100% guaranteed to be unique but fast & probably good enough for our simple purposes)
                                                            //13 - player steam name (string) if it exists


                                                            //For red & blue TopHot operators we give a slightly filtered view of the contacts,
                                                            //simulating what actual WWII radar could see
                                                            //For example contacts low to the ground fade out.
                                                            //TODO: We could set up radar towers & contacts could be seen better if closer to the 
                                                            //tower (ie, lower to the ground.  But then if the enemy destroys your tower you lose
                                                            //that & can only see what your remaining towers can see (which will likely be contacts only quite high in altitude)
                                                            //Also each army could have its own towers giving it better visibility on its own side of the lines where its own towers
                                                            //are etc
                                                            if ((playerArmy == -1 || playerArmy == -2) && (
                                                                           belowRadar(altAGL_ft) || //unified method for deciding below radar or not
                                                                           ((!isAI && isHeavyBomber) && poscount <= 2 && random.Next(3) == 1) || // Breather bombers have a much higher chance of being overlooked/dropping out 
                                                                                                                                                 //However if the player heavy bombers group up they are MUCH more likely to show up on radar.  But they will still be harder than usual to track because each individual bomber will phase in/out quite often

                                                                           (random.Next(7) == 1)  //it just malfunctions & shows nothing 1/7 of the time, for no reason, because. Early radar wasn't 100% reliable at all
                                                                           )
                                                           ) { posmessage = ""; }


                                                        }


                                                        else if (radar_realism == 0)
                                                        {
                                                            posmessage = poscount.ToString() + type + " " +

                                                              mi +
                                                              bearing.ToString("F0") + "°" +
                                                              ft +
                                                              ftAGL +
                                                              mph +
                                                              heading.ToString("F0") + "° " +
                                                              sector.ToString() + " " +
                                                              Calcs.GetAircraftType(a);
                                                            if (intcpt_time_min > 0.02)
                                                            {
                                                                posmessage +=
                                                                   " Intcpt: " +
                                                                   intcpt_heading.ToString("F0") + "°" +
                                                                   intcpt_time_min.ToString("F0") + "min " +
                                                                   intcpt_sector + " " +
                                                                   intcpt.x.ToString("F0") + " " + intcpt.y.ToString("F0");
                                                            }

                                                            // "(" + 
                                                            //Calcs.meters2miles(a.Pos().x).ToString ("F0") + ", " +
                                                            //Calcs.meters2miles(a.Pos().y).ToString ("F0") + ")";

                                                            //twcLogServer(new Player[] { player }, posmessage, new object[] { });
                                                        }
                                                        else if (radar_realism > 0)
                                                        {

                                                            //Trying to give at least some semblance of reality based on capabilities of Chain Home & Chain Home Low
                                                            //https://en.wikipedia.org/wiki/Chain_Home
                                                            //https://en.wikipedia.org/wiki/Chain_Home_Low
                                                            if (random.Next(8) == 1)
                                                            { //oops, sometimes we get mixed up on the type.  So sad . . .  See notes below about relative inaccuracy of early radar.
                                                                type = "F";
                                                                if (random.Next(3) == 1) type = "B";
                                                            }
                                                            if (dis_mi <= 2 && a != p && Math.Abs(player_alt_m - agid.AGGaveAlt) < 5000) { posmessage = type + " nearby"; }


                                                            //Below conditions are situations where radar doesn't work/fails, working to integrate realistic conditions for radar
                                                            //To do this in full realism we'd need the full locations of Chain Home & Chain Home Low stations & exact capabilities
                                                            //As an approximation we're using distance from the current aircraft, altitude, etc.
                                                             //wikipedia gives an idea of how rough early CH output & methods were: CH output was read with an oscilloscope. When a pulse was sent from the broadcast towers, a visible line /
                                                             //travelled horizontally across the screen very rapidly. The output from the receiver was amplified and fed into the vertical axis of the scope, so a return from an aircraft //
                                                             //would deflect the beam upward. This formed a spike on the display, and the distance from the left side – measured with a small scale on the bottom of the screen – would give 
                                                             //target range. By rotating the receiver goniometer connected to the antennas, the operator could estimate the direction to the target (this was the reason for the cross shaped 
                                                             //antennas), while the height of the vertical displacement indicated formation size. By comparing the strengths returned from the various antennas up the tower, altitude could be
                                                                // gauged with some accuracy.
                                                              //Upshot is, exact #, position, no of aircraft, type of aircraft, altitude etc were NOT that precisely known.  Rather they were estimates/guesstimates based on strength of pulse 
                                                              //of the radar return as viewed on an oscilliscope etc.
                                                             //
                                                            else if ((dis_mi >= 50 && poscount < 8 && random.Next(15) > 1 && !intcpt_reasonable_time) ||  //don't show enemy groups too far away, unless they are quite large, or can be intercepted in reasonable time.  Except once in a while randomly show one.
                                                                     (dis_mi >= 25 && poscount < 4 && random.Next(12) > 1 && !intcpt_reasonable_time) ||
                                                                     (dis_mi >= 15 && poscount <= 2 && random.Next(8) > 1 && !intcpt_reasonable_time) ||
                                                                     (!climb_possible && playertype != "B" && army != playerArmy) ||  //If the aircraft is too high for us to be able to climb to, we exclude it from the listing, unless the player is a bomber pilot (who is going to be interested in which planes are above in attack position) OR we are getting a listing of our own army, in which case we want all nearby a/c not just ones we can attack
                                                                     (dis_mi >= 70 && altAGL_ft < 4500) || //chain home only worked above ~4500 ft & Chain Home Low had effective distance only 35 miles
                                                                                                           //however, to implement this we really need the distance of the target from the CHL stations, not the current aircraft
                                                                                                           //We'll approximate it by eliminating low contacts > 70 miles away from current a/c 
                                                                     (dis_mi >= 10 && altAGL_ft < 650 && altAGL_ft < random.Next(500)) || //low contacts become less likely to be seen the lower they go.  Chain Low could detect only to about 4500 ft, though that improved as a/c came closer to the radar facility.
                                                                                                                                          //but Chain Home Low detected targets well down to 500 feet quite early in WWII and after improvements, down to 50 feet.  We'll approximate this by
                                                                                                                                          //phasing out targets below 250 feet.

                                                                     belowRadar(altAGL_ft) || //unified method for deciding below radar or not
                                                                     ((!isAI && isHeavyBomber && army != playerArmy) && dis_mi > 11 && poscount <= 2 && random.Next(4) <= 2) || // Breather bombers have a higher chance of being overlooked/dropping out, especially when further away.  3/4 times it doesn't show up on radar.
                                                                     ((!isAI && isHeavyBomber && army != playerArmy) && dis_mi <= 11 && poscount <= 2 && random.Next(5) == 1) || // Breather bombers have a much higher chance of being overlooked/dropping out when close (this is close enough it should be visual range, so we're not going to help them via radar)
                                                                                                                                                                                 //((!isAI && type == "B" && army != playerArmy) && random.Next(5) > 0) || // Enemy bombers don't show up on your radar screen if less than 7 miles away as a rule - just once in a while.  You'll have to spot them visually instead at this distance!
                                                                                                                                                                                 //We're always showing breather FIGHTERS here (ie, they are not included in isAI || type == "B"), because they always show up as a group of 1, and we'd like to help them find each other & fight it out
                                                                     (random.Next(7) == 1)  //it just malfunctions & shows nothing 1/7 of the time, for no reason, because. Early radar wasn't 100% reliable at all
                                                                     ) { posmessage = ""; }
                                                            else
                                                            {
                                                                posmessage = type + " " +
                                                                   mi_10 +
                                                                   bearing_10.ToString("F0") + "°" +
                                                                   ang +
                                                                   mph +
                                                                   heading_10.ToString("F0") + "° ";
                                                                //+ sector.ToString();
                                                                if (intcpt_time_min >= 0.02)
                                                                {
                                                                    posmessage +=
                                                                       " Intcpt: " +
                                                                       intcpt_heading.ToString("F0") + "°" +
                                                                       intcpt_time_min.ToString("F0") + "min ";
                                                                    //+ intcpt_sector + " ";
                                                                }

                                                            }

                                                        }







                                                    }
                                            }
                                            //We'll print only one message per Airgroup, to reduce clutter
                                            twcLogServer(new Player[] { player }, "RPT: " + posmessage + posmessage.Length.ToString(), new object[] { });
                                            if (posmessage.Length > 0)
                                            {
                                                gpLogServerAndLog(new Player[] { player }, "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + "" + posmessage, null);
                                                //We add the message to the list along with an index that will allow us to reverse sort them in a logical/useful order                               
                                                int intcpt_time_index = (int)intcpt_time_min;
                                                if (intcpt_time_min <= 0 || intcpt_time_min > 99) intcpt_time_index = 99;

                                                try
                                                {
                                                    string addMess = posmessage;
                                                    if (radar_realism > 0) addMess = "~" + Calcs.NoOfAircraft(poscount).ToString("F0") + posmessage;
                                                    radar_messages.Add(
                                                       ((int)intcpt_time_index).ToString("D2") + ((int)dis_mi).ToString("D3") + aigroup_count.ToString("D5"), //adding aigroup ensure uniqueness of index
                                                       addMess
                                                    );
                                                }
                                                catch (Exception e)
                                                {
                                                    twcLogServer(new Player[] { player }, "RadError: " + e, new object[] { });
                                                }







                                            }

                                        }
                                    }
                               } 

                    */
                    //There is always one message - the header.  
                    if (radar_messages.Count == 1) radar_messages.Add("0000000000", "<NO TRADE>");


                    if (radar_realism < 0)
                    {
                        try
                        {
                            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX9 " + DateTime.UtcNow.TimeOfDay.ToString("T")); //Testing for potential causes of warping
                            string typeSuff = "";
                            if (playerArmy == -3) typeSuff = "_ADMIN";
                            if (playerArmy == -4) typeSuff = "_ADMINGROUP";
                            if (playerArmy == -1) typeSuff = "_RED";
                            if (playerArmy == -2) typeSuff = "_BLUE";
                            //Console.WriteLine("RADAR WRITE 1");
                            //TODO!!!!  Rewrite all this to just create a string with the file & then write using File.WriteAllText(file,data);
                            //The avoids the problem of files not being closed/disposed & then they are LOCKED!!!!!
                            //For now the try/catch should take care of any problems, but we'll see.
                            string filepath = STATSCS_FULL_PATH + SERVER_ID_SHORT.ToUpper() + typeSuff + "_radar.txt";
                            if (File.Exists(filepath)) { File.Delete(filepath); }

                            //Ok, now this has been replaced with an async write, see below.

                            /*
                            fi = new System.IO.FileInfo(filepath); //file to write to
                            sw = fi.CreateText(); // Writes Lat long & other info to file

                            try
                            {
                                foreach (var mess in radar_messages)
                                {
                                    sw.WriteLine(mess.Value);
                                }
                            }
                            catch (Exception ex) { Console.WriteLine("Radar Write2: " + ex.ToString()); }

                            sw.Close();
                            sw.Dispose();
                            */

                            string bigMess = "";
                            foreach (var mess in radar_messages) bigMess += mess.Value + Environment.NewLine;
                            Calcs.WriteAllTextAsync(filepath, bigMess);
                            //Console.WriteLine("RADAR WRITE 2");

                            //And, now we create a file with the list of players:
                            //TODO: This probably could/should be a separate method that we just call here

                            //TODO!!!!  Rewrite all this to just create a string with the file & then write using File.WriteAllText(file,data);
                            //The avoids the problem of files not being closed/disposed & then they are LOCKED!!!!!
                            //For now the try/catch should take care of any problems, but we'll see.
                            filepath = STATSCS_FULL_PATH + SERVER_ID_SHORT.ToUpper() + typeSuff + "_players.txt";
                            if (File.Exists(filepath)) { File.Delete(filepath); }


                            //fi = new System.IO.FileInfo(filepath); //file to write to
                            //try
                            /*
                            {
                                sw = fi.CreateText(); // Writes Lat long & other info to file
                                sw.WriteLine("[[" + DateTime.UtcNow.ToString("u").Trim() + "]] " + showTimeLeft(null, false).Item1);
                                sw.WriteLine();

                                int pycount = 0;
                                int pyinplace = 0;
                                string msg = "";
                                if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
                                {

                                    foreach (Player py in GamePlay.gpRemotePlayers())
                                    {
                                        pycount++;
                                        string pl = "(none)";
                                        if (py.Place() != null)
                                        {
                                            pyinplace++;
                                            AiActor act = py.Place();
                                            if (act == null) continue; // no point in going on if nothing here

                                            if (act as AiAircraft != null)
                                            {
                                                AiAircraft acf = act as AiAircraft;
                                                string acType = Calcs.GetAircraftType(acf);
                                                pl = acType;
                                            }

                                            if (playerArmy == -3 || playerArmy == -4)
                                            {
                                                //Point3d ps = Calcs.Il2Point3dToLongLat(act.Pos());
                                                //pl += " " + ps.y.ToString("n2") + " " + ps.x.ToString("n2");
                                                pl += " " + act.Pos().x.ToString("n0") + " " + act.Pos().y.ToString("n0");  //2018/09/20 - switching order of x & y & now need to do the same in radar.php
                                            }

                                        }
                                        msg += py.Name() + " " + py.Army() + " " + pl + "\n";

                                    }

                                }

                                sw.WriteLine("Players logged in: " + pycount.ToString() + " Active: " + pyinplace.ToString());
                                sw.WriteLine();

                                sw.WriteLine(CAMPAIGN_ID.ToUpper() + " MISSION SUMMARY");

                                sw.WriteLine(string.Format("BLUE session totals: {0:0.0} total points; {1:0.0}/{2:0.0}/{3:0.0}/{4:0.0} Air/AA/Naval/Ground points", BlueTotalF,
              BlueAirF, BlueAAF, BlueNavalF, BlueGroundF));
                                sw.WriteLine(string.Format("RED session totals: {0:0.0} total points; {1:0.0}/{2:0.0}/{3:0.0}/{4:0.0} Air/AA/Naval/Ground points", RedTotalF,
              RedAirF, RedAAF, RedNavalF, RedGroundF));
                                sw.WriteLine();

                                sw.WriteLine("Blue Objectives complete (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Blue]));
                                sw.WriteLine();
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4) sw.WriteLine(MO_ListRemainingPrimaryObjectives(player: player, army: (int)ArmiesE.Blue, numToDisplay: 50, delay: 0, display: false, html: false));//sw.WriteLine("Blue Primary Objectives: " + MissionObjectivesString[ArmiesE.Blue]);

                                sw.WriteLine("Red Objectives complete (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Red]));
                                sw.WriteLine();
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4) sw.WriteLine(MO_ListRemainingPrimaryObjectives(player: player, army: (int)ArmiesE.Red, numToDisplay: 50, delay: 0, display: false, html: false));//sw.WriteLine("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]);

                                /***TODO: Need to include some kind of current mission & campaign summary here
                                 * 
                                 * /

                                
                                //if (playerArmy == -2 || playerArmy == -3) sw.WriteLine(osk_BlueObjDescription);
                                //if (playerArmy == -1 || playerArmy == -3) sw.WriteLine(osk_RedObjDescription);
                                //sw.WriteLine("Blue Objectives complete: " + osk_BlueObjCompleted);
                                //sw.WriteLine("Red Objectives complete: " + osk_RedObjCompleted);
                                /////sw.WriteLine("Blue/Red total score: " + (BlueTotalF).ToString("N1") + "/" + (RedTotalF).ToString("N1"));
                                

                                sw.WriteLine(CAMPAIGN_ID.ToUpper() + " CAMPAIGN SUMMARY");

                                Tuple<double, string> res = CalcMapMove("", false, false, null);
                                sw.Write(res.Item2);
                                double newMapState = CampaignMapState + res.Item1;
                                sw.Write(summarizeCurrentMapstate(newMapState + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0, false, null)); //We don't add in the objective points any more until mape turned/ so for display purposes we can add them here.


                                if (msg.Length > 0)
                                {
                                    sw.WriteLine();
                                    sw.WriteLine("PLAYER SUMMARY");
                                    sw.WriteLine(msg);
                                }

                                //try
                                {
                                    msg = ListRadarTargetDamage(null, -1, false, false); //Add the list of current radar airport conditions
                                    msg += Environment.NewLine;
                                    msg += ListAirfieldTargetDamage(null, -1, false, false); //Add the list of current airport conditions
                                    if (msg.Length > 0)
                                    {
                                        sw.WriteLine();
                                        sw.WriteLine("RADAR AND AIRFIELD CONDITION SUMMARY");
                                        sw.WriteLine(msg);
                                    }
                                }
                                //catch (Exception ex) { Console.WriteLine("Radar Write34: " + ex.ToString()); }

                                sw.WriteLine();
                                //string netRed = TWCStatsMission.Display_SessionStatsAll(null, 1, false, false);
                                //string netBlue = TWCStatsMission.Display_SessionStatsAll(null, 2, false, false);
                                string netRed = statsmission.Display_SessionStatsAll(null, 1, false, false);
                                string netBlue = statsmission.Display_SessionStatsAll(null, 2, false, false);
                                sw.WriteLine("PLAYER ACTIVITY SUMMARY");
                                sw.WriteLine(netBlue);
                                sw.WriteLine(netRed);

                                if (TWCSupplyMission != null)
                                {
                                    sw.WriteLine();
                                    if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4) sw.WriteLine(TWCSupplyMission.ListAircraftLost(2, null, false, false));//sw.WriteLine("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]);
                                                                                                                                                                         //if (playerArmy == -3 || playerArmy == -4) sw.WriteLine();
                                    if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4) sw.WriteLine(TWCSupplyMission.ListAircraftLost(1, null, false, false));//sw.WriteLine("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]);


                                }


                                msg = "";
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4) msg += MO_ListScoutedObjectives(null, 2) + Environment.NewLine;
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4) msg += MO_ListScoutedObjectives(null, 1) + Environment.NewLine;

                                if (msg.Length > 0)
                                {
                                    sw.WriteLine();
                                    sw.WriteLine(CAMPAIGN_ID.ToUpper() + " RECONNAISSANCE SUMMARY");
                                    sw.WriteLine(msg);
                                }


                                msg = "";
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4)
                                {
                                    if (TWCSupplyMission != null) msg += (TWCSupplyMission.DisplayNumberOfAvailablePlanes(2, null, false)) + Environment.NewLine;
                                }
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4)
                                {
                                    if (TWCSupplyMission != null) msg += (TWCSupplyMission.DisplayNumberOfAvailablePlanes(1, null, false)) + Environment.NewLine;
                                }

                                if (msg.Length > 0)
                                {
                                    sw.WriteLine();
                                    sw.WriteLine(CAMPAIGN_ID.ToUpper() + " CURRENT AIRCRAFT STOCK LEVELS");
                                    sw.WriteLine(msg);
                                }

                            }
                            //catch (Exception ex) { Console.WriteLine("Radar Write3: " + ex.ToString()); }

                            sw.Close();
                            sw.Dispose();
                        */

                            //Console.WriteLine("RADAR WRITE 3");
                            {
                                bigMess = "";
                                bigMess += ("[[" + DateTime.UtcNow.ToString("u").Trim() + "]] " + showTimeLeft(null, false).Item1) + Environment.NewLine;
                                bigMess += Environment.NewLine;

                                int pycount = 0;
                                int pyinplace = 0;
                                string msg = "";
                                if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
                                {

                                    foreach (Player py in GamePlay.gpRemotePlayers())
                                    {
                                        pycount++;
                                        string pl = "(none)";
                                        if (py.Place() != null)
                                        {
                                            pyinplace++;
                                            AiActor act = py.Place();
                                            if (act == null) continue; // no point in going on if nothing here

                                            if (act as AiAircraft != null)
                                            {
                                                AiAircraft acf = act as AiAircraft;
                                                string acType = Calcs.GetAircraftType(acf);
                                                pl = acType;
                                            }

                                            if (playerArmy == -3 || playerArmy == -4)
                                            {
                                                //Point3d ps = Calcs.Il2Point3dToLongLat(act.Pos());
                                                //pl += " " + ps.y.ToString("n2") + " " + ps.x.ToString("n2");
                                                pl += " " + act.Pos().x.ToString("n0") + " " + act.Pos().y.ToString("n0");  //2018/09/20 - switching order of x & y & now need to do the same in radar.php
                                            }

                                        }
                                        msg += py.Name() + " " + py.Army() + " " + pl + "\n";

                                    }

                                }

                                bigMess += ("Players logged in: " + pycount.ToString() + " Active: " + pyinplace.ToString()) + Environment.NewLine;
                                bigMess += Environment.NewLine;

                                bigMess += (CAMPAIGN_ID.ToUpper() + " MISSION SUMMARY") + Environment.NewLine;

                                bigMess += (string.Format("BLUE session totals: {0:0.0} total points; {1:0.0}/{2:0.0}/{3:0.0}/{4:0.0} Air/AA/Naval/Ground points", BlueTotalF,
              BlueAirF, BlueAAF, BlueNavalF, BlueGroundF)) + Environment.NewLine;
                                bigMess += (string.Format("RED session totals: {0:0.0} total points; {1:0.0}/{2:0.0}/{3:0.0}/{4:0.0} Air/AA/Naval/Ground points", RedTotalF,
              RedAirF, RedAAF, RedNavalF, RedGroundF)) + Environment.NewLine;
                                bigMess += Environment.NewLine;


                                var leakTo = new List<bool>() { false, false, false };  //0, 1, 2 indexes - note that index 0 will be ignored.
                                try
                                {
                                    for (int attackingArmy = 1; attackingArmy < 3; attackingArmy++)
                                    {

                                        if (GeneralStaffLocations.ContainsKey((ArmiesE)attackingArmy) && GeneralStaffLocations[(ArmiesE)attackingArmy] != null)
                                        {
                                            var gsl = GeneralStaffLocations[(ArmiesE)attackingArmy]; //ArmiesE.Blue is the ATTACKING army here, not the owner army
                                            leakTo[attackingArmy] = gsl.discovered;
                                        }
                                    }
                                }
                                catch (Exception ex) { Console.WriteLine("Radar leakTo ERROR: " + ex.ToString()); }

                                bigMess += ("Blue Objectives complete (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Blue])) + Environment.NewLine;
                                bigMess += Environment.NewLine;
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4 || leakTo[1]) bigMess += (MO_ListRemainingPrimaryObjectives(player: player, army: (int)ArmiesE.Blue, numToDisplay: 50, delay: 0, display: false, html: false)) + Environment.NewLine;//bigMess += ("Blue Primary Objectives: " + MissionObjectivesString[ArmiesE.Blue]) + Environment.NewLine;

                                if (leakTo[1] && playerArmy == -1) bigMess += "(enemy objectives leaked via low-level photo recon of General & staff)" + Environment.NewLine;

                                bigMess += ("Red Objectives complete (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):" + (MissionObjectivesCompletedString[ArmiesE.Red])) + Environment.NewLine;
                                bigMess += Environment.NewLine;
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4 || leakTo[2]) bigMess += (MO_ListRemainingPrimaryObjectives(player: player, army: (int)ArmiesE.Red, numToDisplay: 50, delay: 0, display: false, html: false)) + Environment.NewLine;//bigMess += ("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]) + Environment.NewLine;
                                bigMess += Environment.NewLine;

                                if (playerArmy == -1 || playerArmy == -2 || playerArmy == -3 || playerArmy == -4) bigMess += (MO_BRBumrushSituationReport(player: player, numToDisplay: 50, delay: 0, display: false, html: false)) + Environment.NewLine;

                                bigMess += Environment.NewLine;

                                /***TODO: Need to include some kind of current mission & campaign summary here
                                 * 
                                 */


                                //if (playerArmy == -2 || playerArmy == -3) bigMess += (osk_BlueObjDescription) + Environment.NewLine;
                                //if (playerArmy == -1 || playerArmy == -3) bigMess += (osk_RedObjDescription) + Environment.NewLine;
                                //bigMess += ("Blue Objectives complete: " + osk_BlueObjCompleted) + Environment.NewLine;
                                //bigMess += ("Red Objectives complete: " + osk_RedObjCompleted) + Environment.NewLine;
                                /////bigMess += ("Blue/Red total score: " + (BlueTotalF).ToString("N1") + "/" + (RedTotalF).ToString("N1")) + Environment.NewLine;


                                bigMess += (CAMPAIGN_ID.ToUpper() + " CAMPAIGN SUMMARY") + Environment.NewLine;

                                Tuple<double, string> res = CalcMapMove("", false, false, null);
                                bigMess += (res.Item2) + Environment.NewLine;
                                double newMapState = CampaignMapState + res.Item1;
                                bigMess += (summarizeCurrentMapstate(newMapState + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0, false, null)) + Environment.NewLine; //We don't add in the objective points any more until map turned/ so for display purposes we can add them here.


                                if (msg.Length > 0)
                                {
                                    bigMess += Environment.NewLine;
                                    bigMess += ("PLAYER SUMMARY") + Environment.NewLine;
                                    bigMess += (msg) + Environment.NewLine;
                                }

                                try
                                {
                                    msg = ListRadarTargetDamage(null, -1, false, false); //Add the list of current radar airport conditions
                                    msg += Environment.NewLine;
                                    msg += ListAirfieldTargetDamage(null, -1, all: false, display: false, condensed: false); //Add the list of current airport conditions
                                    if (msg.Length > 0)
                                    {
                                        bigMess += Environment.NewLine;
                                        bigMess += ("RADAR AND AIRFIELD CONDITION SUMMARY") + Environment.NewLine;
                                        bigMess += (msg);
                                    }
                                }
                                catch (Exception ex) { Console.WriteLine("Radar Write34: " + ex.ToString()); }

                                bigMess += Environment.NewLine;
                                //string netRed = TWCStatsMission.Display_SessionStatsAll(null, 1, false, false);
                                //string netBlue = TWCStatsMission.Display_SessionStatsAll(null, 2, false, false);
                                string netRed = statsmission.Display_SessionStatsAll(null, 1, false, false);
                                string netBlue = statsmission.Display_SessionStatsAll(null, 2, false, false);
                                bigMess += ("PLAYER ACTIVITY SUMMARY") + Environment.NewLine;
                                bigMess += (netBlue) + Environment.NewLine;
                                bigMess += (netRed) + Environment.NewLine;

                                //Console.WriteLine("RADAR WRITE 4");

                                if (TWCSupplyMission != null)
                                {
                                    bigMess += Environment.NewLine;
                                    if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4) bigMess += (TWCSupplyMission.ListAircraftLost(2, null, false, false)) + Environment.NewLine;//bigMess += ("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]) + Environment.NewLine;
                                                                                                                                                                                              //if (playerArmy == -3 || playerArmy == -4) bigMess += Environment.NewLine;
                                    if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4) bigMess += (TWCSupplyMission.ListAircraftLost(1, null, false, false)) + Environment.NewLine;//bigMess += ("Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red]) + Environment.NewLine;


                                }


                                msg = "";
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4) msg += MO_ListScoutedObjectives(null, 2) + Environment.NewLine;
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4) msg += MO_ListScoutedObjectives(null, 1) + Environment.NewLine;

                                if (msg.Length > 0)
                                {
                                    bigMess += Environment.NewLine;
                                    bigMess += (CAMPAIGN_ID.ToUpper() + " RECONNAISSANCE SUMMARY") + Environment.NewLine;
                                    bigMess += (msg) + Environment.NewLine;
                                }

                                //Console.WriteLine("RADAR WRITE 5");

                                msg = "";
                                if (playerArmy == -2 || playerArmy == -3 || playerArmy == -4)
                                {
                                    if (TWCSupplyMission != null) msg += (TWCSupplyMission.DisplayNumberOfAvailablePlanes(2, null, false)) + Environment.NewLine;
                                }
                                if (playerArmy == -1 || playerArmy == -3 || playerArmy == -4)
                                {
                                    if (TWCSupplyMission != null) msg += (TWCSupplyMission.DisplayNumberOfAvailablePlanes(1, null, false)) + Environment.NewLine;
                                }

                                if (msg.Length > 0)
                                {
                                    bigMess += Environment.NewLine;
                                    bigMess += (CAMPAIGN_ID.ToUpper() + " CURRENT AIRCRAFT STOCK LEVELS") + Environment.NewLine;
                                    bigMess += (msg) + Environment.NewLine;
                                }

                            }

                            //Console.WriteLine("RADAR WRITE 6");

                            Calcs.WriteAllTextAsync(filepath, bigMess);

                            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX9-2 " + DateTime.UtcNow.TimeOfDay.ToString("T")); //Testing for potential causes of warping


                        }
                        catch (Exception ex) { Console.WriteLine("Radar Write1: " + ex.ToString()); }
                    }

                    TimeSpan timeDiff = DateTime.UtcNow.Subtract(d);

                    var saveradar_realism = radar_realism;

                    if (display) Timeout(wait_s, () =>
                    {
                        Task.Run(() =>
                      {
                          try
                          {
                              //Console.WriteLine("RADAR WRITE 7Start");

                              //So, overly long radar messages are incomprehensible & jam up the comms.  So, just trimming it down to 12 msgs max.
                              //It has to be the last 12, because the most important msgs are at the end. Can't eliminate the header, either, so always include 1st msg
                              //Maybe should be even shorter?
                              SortedDictionary<string, string> radar_messages_trim = new SortedDictionary<string, string>(new ReverseComparer<string>());
                              int trim = 0;
                              int c = 0;
                              if (!admin && playerArmy >= 0 && radar_messages != null && radar_messages.Count > 12) trim = radar_messages.Count - 12;
                              //Console.WriteLine("RadTrim: {0} {1} {2}", trim, c, radar_messages.Count);


                              //print out the radar contacts in reverse sort order, which puts closest distance/intercept @ end of the list               
                              double delay = 0;
                              if (radar_messages != null) foreach (var mess in radar_messages)
                                  {
                                      if (c > 0 && c <= trim)
                                      {
                                          c++;
                                          // Console.WriteLine("RadTrim: Trimming {0} {1} {2}", trim, c, radar_messages.Count);
                                          continue;
                                      }
                                      //Console.WriteLine("RadTrim: NoTrim {0} {1} {2}", trim, c, radar_messages.Count);
                                      c++;
                                      if (mess.Key == null) continue;
                                      radar_messages_trim.Add(mess.Key, mess.Value);
                                      delay += 0.2;
                                      Timeout(delay, () =>
                                         {
                                             if (saveradar_realism == 0 && display) gpLogServerAndLog(new Player[] { player }, mess.Value + " : " + mess.Key, null);
                                             else if (saveradar_realism >= 0 && display) gpLogServerAndLog(new Player[] { player }, mess.Value, null);
                                             //if (!display && aiairgroup != null) Console.WriteLine("AiAirgroup radar return: " + mess.Value); //for testing
                                         });


                                  }
                              radar_messages_store[playername_index] = new Tuple<long, SortedDictionary<string, string>>(currtime_ms, radar_messages_trim);
                              if (aiairgroup != null) ai_radar_info_store[aiairgroup] = ai_radar_info;

                              //Console.WriteLine("RADAR WRITE 7End");
                          }
                          catch (Exception ex)
                          {
                              Console.WriteLine("Radar ERROR1: " + ex.ToString());
                          }
                      });//Task.Run

                    });//timeout      

                }
                catch (Exception ex)
                {
                    Console.WriteLine("Radar ERROR37: " + ex.ToString());
                }

            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Radar *MAIN* ERROR: " + ex.ToString());
        }
    }//method radar     

    /******************************************************************************************************************** 
    * ****END****RADAR
    * **********************************************************************************************************************/


    //The lines below in OnBattleStarted() start the chat parser.  See method Mission_EventChat for the rest of the code
    //
    //Note that to make this work, you need all (or maybe just most) of these:  
    //
    //  //$reference parts/core/Strategy.dll
    //  //$reference parts/core/gamePlay.dll
    //  using maddox.game;
    //  using maddox.game.world;
    //  using maddox.GP;
    //
    //PLUS you need lines like this in your conf.ini and confs.ini files:
    //
    //  [rts]
    //  scriptAppDomain=0 
    //  ;avoids the dreaded serialization runtime error when running server
    //  ;per http://forum.1cpublishing.eu/showthread.php?t=34797
    public class c1
    {
        event maddox.game.GameDef.Chat EventChat;
    }

    public override void OnBattleStarted()
    {
        base.OnBattleStarted();
        //try
        {
            //listen to events from all missions.
            //Note: this is in Init now, so disabling it here.  See note in Init (below).
            //MissionNumberListener = -1;

            //When battle is started we re-start the Mission tick clock - setting it up to start events
            //happening when the first player connects

            //TOBRUK: Disabling this FOR NOW.  2020/09.
            CheckAndChangeStartTimeAndWeather(); //will check desired start time vs actual in-game time & rewrite the .mis file, restart the mission if needed to get the time at the right place

            //HOW TO ADD TRIGGERS FROM A SUBMISSION TO THE MAIN MISSION
            //by  ATAG_Oskar
            //2020-08-24


            // First add this line in your main mission in public override void OnBattleStarted()
            //DataDictionary["MAIN.MISSION"] = this;
            /*
             * // Then add this to your sub-mission.

                        Mission mainMission;

                        public override void OnBattleStarted()
                        {
                        mainMission = (Mission)DataDictionary["MAIN.MISSON"];
                        }


                        public override void OnTrigger(int missionNumber, string shortName, bool active)
                        {
                        mainMission.OnTrigger(missionNumber, shortName, active);
                        } 
            *  
            *  Then you can just use triggers from the sub-mission as normal.
            *  
            *  
            *  UPDATE!!!!! It turns out all this is NOT NECESSARY if you just set //MissionNumberListener = -1;  Then you get the triggers from ALL missions
            */


            // if (!DataDictionary.ContainsKey("MAIN.MISSION")) DataDictionary.Add("MAIN.MISSION", this);
            //else
            DataDictionary["MAIN.MISSION"] = this; //takes care of case where it already exists but is stale, or deosnt' exist at all




            MISSION_STARTED = true;
            if (WAIT_FOR_PLAYERS_BEFORE_STARTING_MISSION_ENABLED) MISSION_STARTED = false;
            START_MISSION_TICK = -1;

            COOP_START_MODE = false;
            if (COOP_START_MODE_ENABLED) COOP_START_MODE = true;
            START_COOP_TICK = -1;
            CheckCoop();  //Start the routine to enforce the coop start/no takeoffs etc

            CampaignMapSuffix = GetMapSuffix(); //This must happen BEFORE EndMissionIfPlayersInactive(); as this reads in the initial campaign state variable & EndMissionIfPlayersInactive(); will overwrite it.
                                                //Timeout(5, () => { SetAirfieldTargets(); });  //Delay for the situation where airfields are loaded via init submissions, which might take a while to load


            //Not doing this for Tobruk
            //DrawFrontLinesPerMapState(-MAP_WIN_POINTS / 100, MAP_WIN_POINTS / 100);

            //TESTING
            /*
            for (double i = -25; i <= 25; i = i + 12.5)
            {
                DrawFrontLinesPerMapState(-25, 25, i, "test" + i.ToString("F0") + ".mis");

            }
            */

            //ReadInitialSubmissions(MISSION_ID + "-initairports", 0, 0, subdir: "FocusAirports"); //The "focus airports" file(s) for the TOBRUK mission 2020-08

            try
            {

                twc_tobruk_campaign_mission_objectives = new TWCTobrukCampaignMissionObjectives(GamePlay, this, GetMapState()); //Can't really initialize this until now as we don't have the MAPSTATE

                Console.WriteLine("Main load TTCMO SUCCEEDED");

                twc_tobruk_campaign_mission_objectives.ReadInitialFocusAirportSubmission(); //Reads the .mis file in FocusAirports as chosen by the appropriate mission subclass
                Console.WriteLine("TTCMO ReadInitialFocusAirports SUCCEEDED");

            }
            catch (Exception ex) { Console.WriteLine("Main load TTCMO ERROR: " + ex.ToString()); }

            //Thread.Sleep(3000); //wait for the airports etc to load.

            Timeout(30, () =>
           {
               Console.WriteLine("INITIALIZING mission_objectives now");
               SetAirfieldTargets(); //but since we're not doing that now, we can load it immediately.  Airfields MUST be loaded before mission_objectives bec. the airfield list is used to create mission_objectives                                            

                if (mission_objectives == null) Console.WriteLine("#00.4  Mission Objectives doesn't exist yet!");

               mission_objectives = new MissionObjectives(this, GamePlay); //this must be done AFTER GetMapSuffix as that reads results of previous mission & that is needed for setting up mission objectives

                if (mission_objectives == null) Console.WriteLine("#00.5  Mission Objectives doesn't exist still!");

               ReadInitialSubmissions(MISSION_ID + "-initsubmission", 0, 0); //so we can include initsubmissions if we want


                //LoadRandomSubmission(MISSION_ID + "-" + "initairports" + CampaignMapSuffix); // choose which of the airport & front files to load initially

                //LoadRandomSubmission("weather",@"Weather"); // weather to load initially
                //Loading weather as a submission doesn't seem to work, so we're doing this by directly editing the .mis file, as with triggers, airgroups, time, etc.


                //Turning EndMissionIfPlayersInactive(); off for TF 4.5 testing.
                EndMissionIfPlayersInactive(); //start routine to check if no players in game & stop the mission if so


                //ReadInitialSubmissions(MISSION_ID + "-stats", 0, 0.1);
                ReadInitialSubmissions(MISSION_ID + "-supply", 0, 0.2);

               SaveCampaignStateIntermediate(); //save campaign state/score every 10 minutes so that it isn't lost of we end unexpectedly or crash etc
            });

            /// CONFIGURE REARM/REFUEL
            /// Duration in seconds for full rearm
            // RearmRefuelConfig.REARM_DURATION = 150;

            /// Duration in seconds for 100% refuel
            /// Lesser fuel amounts result in relative fractions of that.
            /// Note: see REFUEL_MIN_DURATION below
            // RearmRefuelConfig.REFUEL_DURATION =  270;

            /// Minimum duration in seconds for refuel
            /// Refuel time cannot be shorter than that
            // RearmRefuelConfig.REFUEL_MIN_DURATION = 150;

            /// Interval in seconds of "... complete in Min::Sec messages
            // RearmRefuelConfig.MESSAGE_INTERVAL = 15;

            /// The visible airfields are sometimes bigger than the technical value configured.
            /// Even spawn points may sometimes be outside of that technical perimeter
            /// Technical airfield perimeter is multiplied with this.
            // RearmRefuelConfig.AIRFIELD_PERIMETER_ADJUST = 1.5;

            /// Allowable deviation from airfield's elevation in meter.
            /// To check if we're actually on the ground, we need to check plane's elevation
            /// against the airfield's. Unfortunately airfield elevation is not homogenous, en
            /// extreme is Maidstone with places up to 7m different from technical elevation.
            /// Note: This is strictly not necessary, because speed=0 within airfield
            ///       perimeter would mean the same, but for user friendliness we say 
            ///       'land on airfield' first and 'set chokes' later
            /// value in meters
            // public static double AIRFIELD_ELEVATION_ADJUST = 7;

            /// maximum engines to check (tanks, fuelcocks, magnetos, etc.)
            // RearmRefuelConfig.MAX_ENGINE_COUNT = 2;

            /// output debugging messages
            // public static bool DEBUG_MESSAGES = false;



            if (GamePlay is GameDef)
            {
                //Calcs.RemoveDelegates((GamePlay as GameDef).EventChat as object);
                //(GamePlay as GameDef).EventChat.ResetSubscriptions;
                //(GamePlay as GameDef).EventChat--;
                //(GamePlay as GameDef).EventChat = c1;
                //(GamePlay as GameDef).EventChat = delegate { };
                //Console.WriteLine ( (GamePlay as GameDef).EventChat.ToString());
                (GamePlay as GameDef).EventChat += new GameDef.Chat(Mission_EventChat);
                //Console.WriteLine((GamePlay as GameDef).EventChat.ToString());
                //(GamePlay as GameDef).EventChat = null;


                //Various attempts to hut up chat messages.
                //cevent.RemoveAllEventHandlers((GamePlay as GameDef).EventChat as object);
                //cevent.cEventHelper.RemoveAllEventHandlers((GamePlay as GameDef).EventChat as object);
                //Component[] cmp = this.components.Components;


                //Calcs.GetEventKeysList(Component);
                //System.Reflection.PropertyInfo eventsProp = typeof(Component).GetProperty("Events", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                /*

                List<Component> cmps = (from field in GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                                        where typeof(Component).IsAssignableFrom(field.FieldType)
                                        let component = (Component)field.GetValue(this)
                                        where component != null
                                        select component).ToList();

                foreach (Component c in cmps) Console.WriteLine("COMP EVENTS PROPS HI!" + c.ToString());


                System.Reflection.PropertyInfo eventsProp = typeof(Component).GetProperty("Events", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                //eventsProp.
                //Calcs.GetEventKeysList(GamePlay);
                Console.WriteLine("COMP EVENTS PROPS " + cmps.ToString());
                */
                /*
                EventHandlerList events = (EventHandlerList)eventsProp.GetValue((GamePlay as GameDef).EventChat, null);

                foreach (EventHandler ehl in eventsProp ){
                    Console.WriteLine("EVENTS PROPS " + ehl.ToString());
                }
                */
                /*
                Delegate[] dary = (GamePlay as GameDef).EventChat.GetInvocationList();

                if (dary != null)
                {
                    foreach (Delegate del in dary)
                    {
                        (GamePlay as GameDef).EventChat -= (Action)del;
                    }
                }
                */
            }
            balanceAILoadTimer_recurs();  //do this once only, not in ONMISSIONLOADED for gods sake.  And it is turned off/disposed at onbattlestoped.
        }
        //catch (Exception ex) { Console.WriteLine("MO_OnBattleStarted error3: " + ex.Message); };

        //Delete any old CampaignSummary.txt files so that they are not hanging around causing trouble
        try
        {
            File.Delete(STATSCS_FULL_PATH + "CampaignSummary.txt");
        }
        catch (Exception ex) { Console.WriteLine("CampaignSummary Delete: " + ex.ToString()); }


        //if (GamePlay is GameDef) (GamePlay as GameDef).gameInterface.CmdExec("ban LOAD twc_banned.txt");
        //we do the "ban" system loading in BurnBabyBurn.cs instead of here.  


    }

    public override void OnBattleStoped()
    {
        base.OnBattleStoped();

        Console.WriteLine("Battle Stopping -- saving map state & current supply status");

        /// REARM/REFUEL: CLEANUP ANY PENDING REQUESTS
        //   ManageRnr.cancelAll(GamePlay);

        //NEED TO DISPOSE OF ALL TIMERS USED ANYWHERE IN THE CODE, HERE.  Otherwise they keep runnign & calling the callback method until the server is restarted !!!!!
        try
        {
            if (balanceAILoadTimer != null) balanceAILoadTimer.Dispose();
            if (MO_BRAdvanceBumrushPhaseTimer != null) MO_BRAdvanceBumrushPhaseTimer.Dispose();
            if (MO_BRBumrushCheckTimer != null) MO_BRBumrushCheckTimer.Dispose();
            if (MO_BRBumrushAIAttackTimer != null) MO_BRBumrushAIAttackTimer.Dispose();
        }
        catch (Exception ex) { Console.WriteLine("ERROR OnBattleStoped1! " + ex.ToString()); }


        try { 
        if (!final_SaveMapState_completed && Time.tickCounter() > 15000) SaveMapState(""); //A call here just to be safe; we can get here if 'exit' is called etc, and the map state may not be saved yet . . . 
        }
        catch (Exception ex) { Console.WriteLine("ERROR OnBattleStoped2! " + ex.ToString()); }

        try { 
        if (!final_MO_WriteMissionObjects_completed) MO_WriteMissionObjects(wait: true);
        }
        catch (Exception ex) { Console.WriteLine("ERROR OnBattleStoped3! " + ex.ToString()); }

        if (GamePlay is GameDef)
        {
            //Console.WriteLine ( (GamePlay as GameDef).EventChat.ToString());
            (GamePlay as GameDef).EventChat -= new GameDef.Chat(Mission_EventChat);
            //If we don't remove the new EventChat when the battle is stopped
            //we tend to get several copies of it operating, if we're not careful
        }
        
        Thread.Sleep(750); //just wait for all files to save etc
    }

    /****************************************
     * READINITIALSUBMISSIONS
     * 
     * Loads any files in the FILE_PATH that match the pattern (anything or nothing) + filenameID + (anything or nothing) + .mis
     * wait tells how many seconds to wait before starting to load, timespread will spread multiple initialsubmission loads
     * over a certain time period (seconds)
     * 
     * **************************************/

    public int ReadInitialSubmissions(string filenameID, int timespread = 60, double wait = 0, string subdir = "")
    {
        List<string> InitSubMissions = GetFilenamesFromDirectory(CLOD_PATH + FILE_PATH + "/" + subdir, filenameID); // gets .mis files with with word filenameID in them
                                                                                                                    //string[] InitSubMissions = GetFilenamesFromDirectory(CLOD_PATH + FILE_PATH, filenameID); // gets .mis files with with word filenameID in them
                                                                                                                    //string[] array = Directory.GetFiles(FILE_PATH + @"Airfields\");

        //DebugAndLog("Debug: Loading " + InitSubMissions.Count + " missions to load. " + filenameID + " " + CLOD_PATH + FILE_PATH);
        Console.WriteLine("Debug: Loading " + InitSubMissions.Count + " missions to load. " + filenameID + " " + CLOD_PATH + FILE_PATH);
        foreach (string s in InitSubMissions)
        {
            //Distribute loading of initial sub-missions over the first timespread seconds
            //If you make each sub-mission small enough it will load without a noticeable stutter
            //If they are large & make a noticeable stutter, probably best to load them all very near the beginning of the mission
            //so that all the stutters happen at that point
            if ((timespread == 0) && (wait == 0))
            {
                GamePlay.gpPostMissionLoad(s);
                DebugAndLog(s.Replace(CLOD_PATH + FILE_PATH, "") + " file loaded");
                Console.WriteLine(s.Replace(CLOD_PATH + FILE_PATH, "") + " file loaded");
            }
            else
            {
                //if (timespread>2 && random.Next(1) == 1) continue; //TESTING, skip 50% of mission loads just to try it
                Timeout(wait + random.Next(timespread), () =>
                {

                    //string temp = @"missions\AirfieldSpawnTest\Airfields\" + Path.GetFileName(s);

                    GamePlay.gpPostMissionLoad(s);

                    //string s2=@"C:\Users\Brent Hugh.BRENT-DESKTOP\Documents\1C SoftClub\il-2 sturmovik cliffs of dover - MOD\missions\Multi\Fatal\TWC-initsubmission-stationary.mis";
                    //GamePlay.gpPostMissionLoad(s2);
                    //if (DEBUG)
                    //{
                    DebugAndLog(s.Replace(CLOD_PATH + FILE_PATH, "") + " file loaded");
                    Console.WriteLine(s.Replace(CLOD_PATH + FILE_PATH, "") + " file loaded");
                    //}
                });
            }
        }

        return InitSubMissions.Count;

    }

    /************************************************************
     * INIT
     * *********************************************************/

    //Listen to events of every mission
    public override void Init(maddox.game.ABattle battle, int missionNumber)
    {
        base.Init(battle, missionNumber);
        try
        {

            gpBattle = battle;
            Console.WriteLine("Loading -cover -stats -supply -airadar");
            gpBattle.creatingMissionScript(covermission, missionNumber + 1, "");  //TODO NOT SURE IF WE NEED TO INCLUDE A FILENAME HERE!??!?
            gpBattle.creatingMissionScript(statsmission, missionNumber + 2, "");
            gpBattle.creatingMissionScript(supplymission, missionNumber + 3, "");
            gpBattle.creatingMissionScript(airadarmission, missionNumber + 4, "");
            gpBattle.creatingMissionScript(landinggroundmission, missionNumber + 5, "");
            //gpBattle.creatingMissionScript(gvcmission, missionNumber + 5);
            //gvcmission = new GCV.GCVMission();


            MissionNumberListener = -1; //Listen to events of every mission
                                        //This is what allows you to catch all the OnTookOff, OnAircraftDamaged, and other similar events.  Vitally important to make this work!
                                        //If we load missions as sub-missions, as we often do, it is vital to have this in Init, not in "onbattlestarted" or some other place where it may never be detected or triggered if this sub-mission isn't loaded at the very start.
                                        //Initialize the mission objectives etc but wait until after initial submissions are loaded

            //This needs to be in Init (not Mission constructor) because it relies on some Battle. stuff that isn't initialized yet at Mission constructor
            //(For now this is unnecessary but in future we might load things in initial submissions & then mission_objectives potentially affected by them afterwards)
            //Timeout(30, () => { mission_objectives = new MissionObjectives(this); });
            //Timeout(1, () => { mission_objectives = new MissionObjectives(this); }); //testing


            //For testing
            /*
            Timeout(30, () => {MO_DestroyObjective("BTarget14R");
                MO_DestroyObjective("BTarget22R");
                MO_DestroyObjective("RTarget28R");
                MO_DestroyObjective("RTarget29R");


            });
            */

            for (int k = 1; k < 10; k++)
                {
                    //Console.WriteLine("BB: " + k.ToString());
                    Timeout(k * 15, () => { Console.WriteLine("Battle begins!"); }); //Helps the launcher64 startup program detect that launcher has started OK, if the first Battle begins! scrolls of the screen.  I hope.
                }


        }
        catch (Exception ex) { Console.WriteLine("MO_Destroy error3: " + ex.Message); };


    }

    List<List<string>> redBomberActions = new List<List<string>>() {
      new List<string>() {"RBomb1", "RBombCover1"},
      new List<string>() {"Jabored"},
      new List<string>() {"MQWest", "MQWestCover"},
      new List<string>() {"action4", "action4cover"},
      new List<string>() {"action6", "action6cover"},
      new List<string>() {"action14", "action14cover"},
      new List<string>() {"action16", "action16cover"},
      };

    List<List<string>> blueBomberActions = new List<List<string>>() {
      new List<string>() {"Bomb1", "BombCover1"},
      new List<string>() {"45mincover2", "45minraidCover", "45minraidB"},
      new List<string>() {"2hrraid", "2hrraidcover"},
      new List<string>() {"4hrraidcover2", "4hrraidcover", "4hrraid"},
      new List<string>() {"testbomber", "testcover1", "testcover2"},
      new List<string>() {"action5", "action5e"},
      new List<string>() {"action7", "action7e"},
      new List<string>() {"action13", "action13e", "action13c", "action13cc"},
      };

    static object balanceAILoad_locker = new object();
    public void balanceAILoad(object o)
    {
        if (Monitor.TryEnter(balanceAILoad_locker)) //lock the recursive/timer so that only one instance can run at a time

        {
            try
            {
                int numRedPlayers = Calcs.gpNumberOfPlayers(GamePlay, 1);
                int numBluePlayers = Calcs.gpNumberOfPlayers(GamePlay, 2);
                Console.WriteLine("balanceAILoad: Blue ac/players {0} {1} Red ac/players  {2} {3} " + DateTime.UtcNow.ToString("T"), numBlueAircraft, numBluePlayers, numRedAircraft, numRedPlayers);

                //return; //stop buggy behavior for now

                if (numBlueAircraft < 70 && numRedPlayers > 0)
                {
                    double wait = random.Next(0, 60);
                    Timeout(wait, () =>
                    {
                        int randIndex = random.Next(blueBomberActions.Count);
                        foreach (string act in blueBomberActions[randIndex])
                        {
                            execAction(act, "BalanceAILoad Blue");
                            Console.WriteLine("balanceAILoad: Loading " + act);
                        }
                    });

                }
                if (numRedAircraft < 70 & numBluePlayers > 0)
                {
                    double wait = random.Next(0, 60);
                    Timeout(wait, () =>
                    {
                        int randIndex = random.Next(redBomberActions.Count);
                        foreach (string act in redBomberActions[randIndex])
                        {
                            execAction(act, "BalanceAILoad Red");
                            Console.WriteLine("balanceAILoad: Loading " + act);
                        }
                    });
                }
            }
            catch (Exception ex) { Console.WriteLine("BalanceAILoad ERROR: " + ex.ToString()); }
            finally
            {
                Monitor.Exit(balanceAILoad_locker);
            }
        }
    }

    public System.Threading.Timer balanceAILoadTimer;

    public void balanceAILoadTimer_recurs()
    {
        Console.WriteLine("balanceAILoad: Starting timer! " + DateTime.UtcNow.ToString("T"));
        balanceAILoadTimer = new System.Threading.Timer(
            new TimerCallback(balanceAILoad),
            null,
            dueTime: 30000, //wait time @ startup
            period: 232453); //periodically call the callback at this interval, every 4-6 minutes say

    }

    IStatsMission TWCStatsMission;
    ISupplyMission TWCSupplyMission;
    IKnickebeinMission TWCKnickebeinMission;
    ICoverMission TWCCoverMission;
    IStbSaveIPlayerStat TWCSaveIPlayerStat;
    //GCV.GCVMission gvcmission;

    public override void OnMissionLoaded(int missionNumber)
    {
        base.OnMissionLoaded(missionNumber);

        //Console.WriteLine("-main.cs OnMissionLoaded {0} {1} ", missionNumber, MissionNumber);
        try
        {

            TWCStatsMission = TWCComms.Communicator.Instance.Stats;
            //if (TWCStatsMission != null) TWCSaveIPlayerStat = TWCStatsMission.stb_ISaveIPlayerStat;
            TWCSaveIPlayerStat = statsmission.stb_ISaveIPlayerStat;
            if (TWCComms.Communicator.Instance.stb_FullPath != null && TWCComms.Communicator.Instance.stb_FullPath.Length > 0) STATSCS_FULL_PATH = TWCComms.Communicator.Instance.stb_FullPath;
            //STATSCS_FULL_PATH = statsmission.stb_FullPath; //for some reason, this doesn't work correctly 2020/02/14
            TWCSupplyMission = TWCComms.Communicator.Instance.Supply;
            TWCKnickebeinMission = TWCComms.Communicator.Instance.Knickebein;
            TWCCoverMission = TWCComms.Communicator.Instance.Cover;

            




                //TWCStbSaveIPlayerStat = TWCComms.Communicator.Instance.Cover
                //TWCComms.Communicator.Instance.Main = this;
                //TWCMainMission = TWCComms.Communicator.Instance.Main;
                //TWCStatsMission = TWCComms.Communicator.Instance.Stats;
                //string s1= TWCComms.Communicator.Instance.string1;
                //Console.WriteLine("Statsstring: " + s1);
                //Console.WriteLine("GetType1: " + GetType().ToString());
                //Console.WriteLine("GetType2: " + s1.GetType().ToString());
                //Console.WriteLine("GetType3: " + TWCMainMission.GetType().ToString());
                //Console.WriteLine("GetType4: " + (TWCComms.Communicator.Instance.Stats == null).ToString());
                //Console.WriteLine("GetType5: " + (TWCComms.Communicator.Instance.Main.GetType().ToString()));
                //Console.WriteLine("GetType6: " + TWCStatsMission.stb_LocalMissionIniDirectory);
                //Console.WriteLine("GetType19: " + TWCStatsMission.stb_LocalMissionIniDirectory);
                //Console.WriteLine("GetType20: " + TWCStatsMission.ot_GetCivilianBombings("TWC_Flug"));

            //Assembly a = new Assembly();
            //Assembly assembly = typeof(maddox.game.AMission).Assembly;
            //Assembly assembly = Assembly.GetExecutingAssembly();
            //Assembly assembly = Assembly.GetCallingAssembly();
            //var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            //var namespaces = assembly.GetTypes().Select(t => t.Namespace).Distinct();
            /*
            foreach (var assembly in assemblies)
            {
                var namespaces = assembly.GetTypes();
                foreach (var n in namespaces)
                {
                    Console.WriteLine("NS " + n.ToString());

                }
            }*/
    //coord.Singleton.Instance.Main = this;


    //String executablePath = System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
    //Console.WriteLine("NS " + executablePath);

    //Mission m = Battle.missions[missionNumber];
    /* if (m.stb_StatsINIFilename !=null & m.stb_StatsINIFilename=="stats.ini")
    {
        TWCStatsMission = m;
        Console.WriteLine("StatsMission! " + m.stb_StatsINIFilename);
    }*/

    /* 
     * ban LOAD blacklist.txt
     * */
}
        catch (Exception ex) { Console.WriteLine("OnMission ERROR: " + ex.Message); };

    }

    /************************************************************
     * MENU SYSTEM
     * *********************************************************/

    bool dmgOn = false;
    bool EndMissionSelected = false;
    bool debugMenu = false;
    bool debugSave;
    int radar_realismSave;
    private void setMainMenu(Player player)
    {
        //GamePlay.gpSetOrderMissionMenu(player, true, 0, new string[] { "Server Options - Users" }, new bool[] { true });


        //{true/false bool array}: TRUE here indicates that the choice is a SUBMENU so that when it is selected the user menu will be shown.  If FALSE the user menu will disappear.  Also it affects the COLOR of the menu items, which seems to be designed to indicate whether the choice is going to DO SOMETHING IMMEDIATELY or TAKE YOU TO ANOTHER MENU

        GamePlay.gpSetOrderMissionMenu(player, true, 0, new string[] { "Enemy radar", "Friendly radar", "Enemy Activity Map Overview", "More...", "Objectives Complete", "Objectives Remaining", "Secondary Objectives", "Recon Photo Results with Coordinates", "Take Recon Photo" }, new bool[] { false, false, false, true, false, false, false, false, false });

    }

    private void setSubMenu1(Player player)
    {
        if (admin_privilege_level(player) >= 1)
        {

            string rollovertext = "(admin) End mission now/roll over to next mission";
            if (EndMissionSelected) rollovertext = "(admin) CANCEL End mission now command";
            if (admin_privilege_level(player) == 2)
                GamePlay.gpSetOrderMissionMenu(player, true, 2, new string[] { "(admin) Show detailed damage reports for all players (toggle)", "(admin) Toggle debug mode", "", rollovertext, "Return to User Menu" }, new bool[] { false, false, false, false, true });
            else GamePlay.gpSetOrderMissionMenu(player, true, 2, new string[] { "", "", "", rollovertext, "Return to User Menu" }, new bool[] { false, false, false, false, true });
        }
        else
        {
            setMainMenu(player);

        }
    }
    private void setSubMenu2(Player player)
    {
        if (admin_privilege_level(player) >= 1)
        {
            //ADMIN option is set to #9 for two reasons: #1. We can add or remove other options before it, up to 8 other options, without changing the Tab-4-4-9 admin access.  #2. To avoid accessing the admin menu (and it's often DANGEROUS options) by accident
            //{true/false bool array}: TRUE here indicates that the choice is a SUBMENU so that when it is selected the user menu will be shown.  If FALSE the user menu will disappear.  Also it affects the COLOR of the menu items, which seems to be designed to indicate whether the choice is going to DO SOMETHING IMMEDIATELY or TAKE YOU TO ANOTHER MENU
            GamePlay.gpSetOrderMissionMenu(player, true, 2, new string[] { "Your Career Summary", "Your Session Summary", "Netstats/All Player Summary", "More...", "Aerial Intcpt Radar", "Current Campaign Status", "Detail Campaign Team/Session", "Let AI take over 2nd Position", "Admin Options" }, new bool[] { false, false, false, true, false, false, false, false, true });
        }
        else
        {
            GamePlay.gpSetOrderMissionMenu(player, true, 2, new string[] { "Your Career Summary", "Your Session Summary", "Netstats/All Player Summary", "More...", "Aerial Intcpt Radar", "Current Campaign Status", "Detail Campaign Team/Session" }, new bool[] { false, false, false, true, true, false, false });
        }
    }
    private void setSubMenu3(Player player)
    {
        GamePlay.gpSetOrderMissionMenu(player, true, 3, new string[] { "Radar & airport damage summary", "Nearest friendly airport", "On friendly territory?", "More...", "Aircraft Supply", "Aircraft available to you", "Aircraft lost this mission", "Time left in mission" }, new bool[] { false, false, false, true, false, false, false, false });
    }

    bool covermis_listOn = false;
    
    
    private void setSubMenu4(Player player)
    {
        string cover_misListon_string = "(off)";
        if (covermission.isOn_Display_listPositionCurrentCoverAircraft(player)) cover_misListon_string = "(on)";
        string t= covermission.BAM_getPlayerBombAimMode_string(player);
        GamePlay.gpSetOrderMissionMenu(player, true, 4, new string[] { "Knickebein - On/Next", "Knickebein - Off", "Knickebein - Current KB Info", "Back...", "Knickebein - List", "Cover Targeting ["+ t + "]", "Cover - List available aircraft", "Cover - Aircraft position " + cover_misListon_string, "Cover - Release Aircraft to land" }, new bool[] { true, true, true, true, true, true, true, true, false });
    }


    //object plnameo= GamePlay.gpPlayer().Name();  
    //string plname= GamePlay.gpPlayer().Name() as string;
    public override void OnOrderMissionMenuSelected(Player player, int ID, int menuItemIndex)
    {
        //base.OnOrderMissionMenuSelected(player, ID, menuItemIndex); //2015/05/16 - not sure why this was missing previously? We'll see . . .

        AiAircraft aircraft = null;
        if (player.Place() as AiAircraft != null) aircraft = player.Place() as AiAircraft;

        /*****************************************************
         * 
         * ADMIN SUBMENU (2nd submenu, ID ==1, Tab-4-4-9)
         * 
         *****************************************************/
        if (ID == 1)
        { // main menu

            if (menuItemIndex == 0)
            {
                //setSubMenu1(player);
                setMainMenu(player);
            }

            //start/stop display a/c damage inflicted info/////////////////////////// 
            else if (menuItemIndex == 1)
            {
                if (admin_privilege_level(player) == 2)
                {
                    dmgOn = !dmgOn;
                    if (dmgOn)
                    {
                        GamePlay.gpHUDLogCenter("Will show damage on all aircraft");
                        twcLogServer(new Player[] { player }, "Detailed damage reports will be shown for all players", new object[] { });

                    }
                    else
                    {
                        GamePlay.gpHUDLogCenter("Will not show damage on all aircraft");
                        twcLogServer(new Player[] { player }, "Detailed damage reports turned off", new object[] { });
                    }
                }
                setMainMenu(player);
            }
            else if (menuItemIndex == 2)
            {
                if (admin_privilege_level(player) == 2)
                {
                    debugMenu = !debugMenu;
                    if (debugMenu)
                    {
                        twcLogServer(new Player[] { player }, "Debug & detailed radar ON for all users - extra debug messages & instant, detailed radar", new object[] { });
                        radar_realismSave = RADAR_REALISM;
                        DEBUG = true;
                        RADAR_REALISM = 0;

                    }
                    else
                    {
                        twcLogServer(new Player[] { player }, "Debug & detailed radar OFF", new object[] { });
                        RADAR_REALISM = radar_realismSave;
                        DEBUG = false;

                    }
                }

                setMainMenu(player);
            }

            //Display Stats
            //WritePlayerStat(player)
            /*
             * else if (menuItemIndex == 3)
            {
                if (admin_privilege_level(player) == 2)
                {
                    string str = WritePlayerStat(player);
                    //split msg into a few chunks as gplogserver doesn't like long msgs
                    int maxChunkSize = 100;
                    for (int i = 0; i < str.Length; i += maxChunkSize)
                        twcLogServer(new Player[] { player }, str.Substring(i, Math.Min(maxChunkSize, str.Length - i)), new object[] { });
                }

                setMainMenu(player);
            }
            */
            else if (menuItemIndex == 4)
            {
                if (admin_privilege_level(player) >= 1)
                {
                    if (EndMissionSelected == false)
                    {
                        EndMissionSelected = true;
                        twcLogServer(new Player[] { player }, "ENDING MISSION!! If you want to cancel the End Mission command, use Tab-4-4-9-4 again.  You have 30 seconds to cancel.", new object[] { });
                        Timeout(30, () =>
                        {
                            if (EndMissionSelected)
                            {
                                EndMission(0);
                            }
                            else
                            {
                                twcLogServer(new Player[] { player }, "End Mission CANCELLED; Mission continuing . . . ", new object[] { });
                                twcLogServer(new Player[] { player }, "If you want to end the mission, you can use the menu to select Mission End again now.", new object[] { });
                            }

                        });

                    }
                    else
                    {
                        twcLogServer(new Player[] { player }, "End Mission CANCELLED; Mission will continue", new object[] { });
                        EndMissionSelected = false;

                    }
                }
                setMainMenu(player);
            }
            else if (menuItemIndex == 5)
            {

                setMainMenu(player);
            }




            //Respawn/rearm   
            else if (menuItemIndex == 9)
            {
                twcLogServer(new Player[] { player }, "Re-spawn: This option not working yet", new object[] { });
                //Spawn in mission file with 1 copy of any/all needed aircraft included
                //copy the one matching the player's plane to the player's current spot or nearby
                //also copy existing plane's position, direction, location etc etc etc
                //move player to new a/c 
                //player.PlaceEnter(aircraft,0);
                //destroy old a/c
                setMainMenu(player);
            }
            else
            { //make sure there is a catch-all ELSE or ELSE menu screw-ups WILL occur
                setMainMenu(player);
            }

            /* else if( menuItemIndex == 2 ) {
                setSubMenu1( player );
                /* if ( player.Name().Substring(0,3) == @"TWC") {
                    setSubMenu2( player );
                  } else {
                    twcLogServer(new Player[] { player }, player.Name() + " is not authorized", new object[] { }); 
                    setSubMenu1( player );
                  }
                 */

            //}
        }

        /*****************************************************
        * 
        * USER SUBMENU (4th submenu, ID == 4, Tab-4-4-4-4)
        * 
        *****************************************************/
        //   GamePlay.gpSetOrderMissionMenu(player, true, 3, new string[] { "Knickebein - On/Next", "Knickebein - Off", "Knickebein - Current KB Info", "Back...", "Knickebein - List", "Cover - Auto-select cover aircraft", "Cover - List available aircraft", "Cover - Aircraft position", "Cover - Release Aircraft to land" }, new bool[] { true, false, false, true, false, false, false, false, false});
        else if (ID == 4)
        { // main menu

            if (menuItemIndex == 0)
            {
                setSubMenu3(player);
                //setMainMenu(player);
            }

            //Knickebein on/next
            else if (menuItemIndex == 1)
            {
                setSubMenu4(player);
                if (TWCKnickebeinMission != null)
                {
                    TWCKnickebeinMission.KniOnStartOrNext(player);
                }

                Timeout(2, () =>
                {
                    //Reminder due to recent change in Cover Bomber Aim
                    string msg6 = "!!!!!Remember to turn on Cover Bomber Aim Mode via Tab-4-4-4-4-6!!!!!!";
                    twcLogServer(new Player[] { player }, msg6, null);
                });


            }
            //Knickebein Off
            else if (menuItemIndex == 2)
            {
                if (TWCKnickebeinMission != null)
                {
                    TWCKnickebeinMission.KniStop(player);
                }
                setSubMenu4(player);
                //setMainMenu(player);
                
            }
            //Knickebein - current KB info
            else if (menuItemIndex == 3)
            {
                if (TWCKnickebeinMission != null)
                {
                    TWCKnickebeinMission.KniInfo(player);
                }
                setSubMenu4(player);
                //setMainMenu(player);
            }
            else if (menuItemIndex == 4)  //MORE (next) menu
            {
                setMainMenu(player);
            }
            //Knickebein - List
            else if (menuItemIndex == 5)
            {
                if (TWCKnickebeinMission != null)
                {
                    TWCKnickebeinMission.KniList(player);
                }
                setSubMenu4(player);
                //setMainMenu(player);

            }
            //Cover - select/start
            else if (menuItemIndex == 6)
            {
                if (covermission != null)
                {
                    //covermission.checkoutCoverAircraft(player, "");
                    covermission.BAM_toggleBombAimMode_withmessages(player);
                }

                //setMainMenu(player); 
                setSubMenu4(player); //stay on this menu so you can tap it repeatedly
            }
            //Cover - List available cover a/c
            else if (menuItemIndex == 7)
            {
                if (covermission != null)
                {
                    covermission.listCoverAircraftCurrentlyAvailable((ArmiesE)player.Army(), player);
                }
                setSubMenu4(player); //stay on this menu so you can tap it repeatedly
                //setMainMenu(player);

            }
            //Cover - Position of your cover a/c
            else if (menuItemIndex == 8)
            {
                if (covermission != null)
                {
                    //string res = TWCCoverMission.listPositionCurrentCoverAircraft(player);
                    //string res = covermission.listPositionCurrentCoverAircraft(player);
                    covermis_listOn = covermission.toggleregularDisplay_listPositionCurrentCoverAircraft(player);


                }
                //setMainMenu(player);
                setSubMenu4(player); //stay on this menu so you can tap it repeatedly
            }
            //Cover - CLand
            else if (menuItemIndex == 9)
            {
                if (covermission != null)
                {
                    covermission.landCoverAircraft(player);
                }
                setMainMenu(player); //This one resets to MAINMENU so as to prevent accidental double-taps of the "9" key from landing all the player's cover a/c.  But all the rest of the buttons on this menu just stay on Menu4
            }
            else
            { //make sure there is a catch-all ELSE or ELSE menu screw-ups WILL occur
                setMainMenu(player);
            }
        }

        /*****************************************************
         * 
         * USER SUBMENU (3rd submenu, ID == 3, Tab-4-4-4)
         * 
         *****************************************************/
        //   GamePlay.gpSetOrderMissionMenu( player, true, 2, new string[] { "Detailed Campaign Summary", "Radar & Airport damage summary", "Nearest friendly airport", "On friendly territory?","Back..."}, new bool[] { false, false, false, false, false } );
        else if (ID == 3)
        { // main menu

            if (menuItemIndex == 0)
            {
                setSubMenu2(player);
                //setMainMenu(player);
            }

            //Radar & Airport damage summary, same as <ap
            else if (menuItemIndex == 1)
            {
                //ListAirfieldTargetDamage(player, -1);//list damaged airport of both teams
                Task.Run(() => {
                    ListRadarTargetDamage(player, -1);
                    Timeout(2, () => { ListAirfieldTargetDamage(player, -1); });
                });
                setMainMenu(player);
            }
            //Directions to nearest friendly airport
            else if (menuItemIndex == 2)
            {
                Timeout(0.2, () =>
                {
                    string msg6 = "Checking your position via radar to find nearest friendly airport. Stand by . . . ";
                    twcLogServer(new Player[] { player }, msg6, null);
                });

                if (offRadar(player)) {
                    Timeout(6, () =>
                    {
                        string msg6 = "HQ has been unable to locate your position!  Sorry and good luck!";
                        twcLogServer(new Player[] { player }, msg6, null);
                    });

                } else {

                    Timeout(12, () =>
                    {

                        //double d = Calcs.distanceToNearestAirport(GamePlay, aircraft as AiActor);

                        AiAirport ap = Calcs.nearestAirport(GamePlay, aircraft as AiActor, player.Army());
                        AiActor a = ap as AiActor;

                        Point3d aPos = a.Pos();
                        double distanceToAirport_m = aircraft.Pos().distance(ref aPos);
                        double bearing_deg = Calcs.CalculateGradientAngle(aircraft.Pos(), a.Pos());
                        double bearing_deg10 = Calcs.GetDegreesIn10Step(bearing_deg);
                        string dis_string = (distanceToAirport_m / 1000).ToString("N0") + " km ";
                        if (player.Army() == 1) dis_string = (Calcs.meters2miles(distanceToAirport_m)).ToString("N0") + " mi ";

                        string message6 = dis_string + bearing_deg10.ToString("N0") + "° to the nearest friendly airport";
                        if (distanceToAirport_m < 2500) message6 = "You are AT the nearest friendly airport";
                        if (distanceToAirport_m > 100000000) message6 = "Nearest friendly airport not found";
                        twcLogServer(new Player[] { player }, message6, null);

                    });
                }
                setMainMenu(player);
            }
            //On Friendly or Enemy territory, same as <ter
            else if (menuItemIndex == 3)
            {
                if (player.Army() != null && aircraft != null)
                {

                    Timeout(0.2, () =>
                    {
                        string msg6 = "Checking your position via radar. Stand by . . . ";
                        twcLogServer(new Player[] { player }, msg6, null);
                    });

                    Timeout(12, () =>
                    {
                        int terr = GamePlay.gpFrontArmy(aircraft.Pos().x, aircraft.Pos().y);
                        string msg6 = "You are in ENEMY territory";
                        if (terr == 00) msg6 = "You are in NEUTRAL territory";
                        if (player.Army() == terr) msg6 = "You are in FRIENDLY territory";
                        twcLogServer(new Player[] { player }, msg6, null);
                    });

                }
                setMainMenu(player);
            }
            else if (menuItemIndex == 4)  //MORE (next) menu
            {
                setSubMenu4(player);
            }
            else if (menuItemIndex == 5)
            {
                if (TWCSupplyMission != null) TWCSupplyMission.DisplayNumberOfAvailablePlanes(player.Army(), player, true);
                setMainMenu(player);
            }
            else if (menuItemIndex == 6)
            {
                //public string Display_AircraftAvailable_ByName(Player player, bool nextAC = false, bool display = true, bool html = false)
                //if (TWCStatsMission != null)
                //{
                statsmission.Display_AircraftAvailable_ByName(player, nextAC: false, display: true, html: false);
                Timeout(2.1, () =>
                {
                    statsmission.Display_AircraftAvailable_ByName(player, nextAC: true, display: true, html: false);
                });
                Timeout(5.0, () =>
                {
                    twcLogServer(new Player[] { player }, "Note that fighter & bomber pilot careers are separate & aircraft actually available depends on the ace & rank levels in the relevant career for that aircraft", null);
                });


                //}
                setMainMenu(player);
            }

            else if (menuItemIndex == 7)
            {                
                setMainMenu(player);
                if (TWCSupplyMission != null) TWCSupplyMission.ListAircraftLost(player.Army(), player, true, false);

            }
            else if (menuItemIndex == 8)
            {
                setMainMenu(player);
                //int endsessiontick = Convert.ToInt32(ticksperminute*60*HOURS_PER_SESSION); //When to end/restart server session
                showTimeLeft(player);
                //Experiment to see if we could trigger chat commands this way; it didn't work
                //twcLogServer(new Player[] { player }, "<air", new object[] { });
                //twcLogServer(new Player[] { player }, "<ter", new object[] { });                            }

            }
            else
            { //make sure there is a catch-all ELSE or ELSE menu screw-ups WILL occur
                setMainMenu(player);
            }
        }

        /*****************************************************
         * 
         * USER SUBMENU (2nd submenu, ID ==2, Tab-4-4)
         * 
         *****************************************************/
        //   GamePlay.gpSetOrderMissionMenu( player, true, 2, new string[] { "Detailed Campaign Summary", "Airport damage summary", "Nearest friendly airport", "On friendly territory?","Back..."}, new bool[] { false, false, false, false, false } );
        else if (ID == 2)
        { // main menu

            if (menuItemIndex == 0)
            {
                setSubMenu1(player);
                //setMainMenu(player);
            }



            else if (menuItemIndex == 1)
            {
                /*
                 * Formerly <rank or <career for player
                 */
                setMainMenu(player);
                //if (TWCStatsMission != null) TWCStatsMission.Display_AceAndRank_ByName(player);
                //TWCStatsMission.Display_AceAndRank_ByName(player);
                statsmission.Display_AceAndRank_ByName(player);
            }
            else if (menuItemIndex == 2)
            {
                /*
                 * Formerly <session for player session stats
                 */
                setMainMenu(player);
                //if (TWCStatsMission != null) TWCStatsMission.Display_SessionStats(player);
                //TWCStatsMission.Display_SessionStats(player);
                statsmission.Display_SessionStats(player);
            }

            else if (menuItemIndex == 3)
            {
                /*
                 * Formerly <net for all player "netstats" 
                 */
                setMainMenu(player);
                //if (TWCStatsMission != null) TWCStatsMission.Display_SessionStatsAll(player, 0, true); //player, army (0=all), display or not
                //TWCStatsMission.Display_SessionStatsAll(player, 0, true, false); //player, army (0=all), display or not
                statsmission.Display_SessionStatsAll(player, 0, true, false); //player, army (0=all), display or not

            }
            else if (menuItemIndex == 4)  //MORE (next) menu
            {
                setSubMenu3(player);
            }
            else if (menuItemIndex == 5)
            {
                /*
                 * Aerial Interception Radar (in-plane radar)
                 */
                setMainMenu(player);
                //if (airadarmission != null) airadarmission.handleAIRadarRequest(player);
                if (airadarmission != null) airadarmission.handleAIRadarAuthenticArrayRequest(player, 5);
                //setSubMenu2(player); //KEEPS IT ON THE SAME MENU INSTEAD OF RETURN TO main menu

            }
            else if (menuItemIndex == 6)
            {
                /*
                 * Display Campaign Summary, same as <cam
                 */
                setMainMenu(player);
                Tuple<double, string> res = CalcMapMove("", false, false, player);
                double score = res.Item1 * 100;
                string mes = "Campaign score for this mission so far: ";
                if (score > 0) mes += "Red +" + score.ToString("n0");
                else if (score < 0) mes += "Blue +" + (-score).ToString("n0");
                else mes += "A tie!";
                twcLogServer(new Player[] { player }, mes, null);

                double newMapState = CampaignMapState + res.Item1 + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0;
                summarizeCurrentMapstate(newMapState, true, player);
            }
            else if (menuItemIndex == 7)
            {
                /*
                 * Detailed Campaign summary as in <camlong
                 */

                setMainMenu(player);

                Tuple<double, string> res = CalcMapMove("", false, true, player);
                //string outputmsg = res.Item2;
                //string msg = "";

                double newMapState = CampaignMapState + res.Item1 + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0;
                summarizeCurrentMapstate(newMapState, true, player);

            }
            else if (menuItemIndex == 8)
            {
                /*
                 * Let AI take over player's 2nd position - essential for 110, JU-87, etc
                 */

                letAiTake2ndPosition(player);
            }
            //ADMIN sub-menu
            else if (menuItemIndex == 9)
            {
                setSubMenu1(player);
            }

            else
            { //make sure there is a catch-all ELSE or ELSE menu screw-ups WILL occur
                setMainMenu(player);
            }



            /*****************************************************
            * 
            * USER SUBMENU (1st submenu, ID == 0, Tab-4)
            * 
            *****************************************************/
        }
        else if (ID == 0)
        { // sub menu

            if (menuItemIndex == 0)
            {
                //setSubMenu1(player);
                setMainMenu(player);
            }
            else if (menuItemIndex == 1)
            {
                setMainMenu(player);
                Player[] all = { player };
                Task.Run(() => listPositionAllAircraft(player, player.Army(), false, radar_realism: RADAR_REALISM)); //enemy a/c  
                if (DEBUG)
                {
                    DebugAndLog("Total number of AI aircraft groups currently active:");
                    if (GamePlay.gpAirGroups(1) != null && GamePlay.gpAirGroups(2) != null)
                    {

                        int totalAircraft = GamePlay.gpAirGroups(1).Length + GamePlay.gpAirGroups(2).Length;
                        DebugAndLog(totalAircraft.ToString());
                        //twcLogServer(GamePlay.gpRemotePlayers(), totalAircraft.ToString(), null);
                    }
                }
            }
            else if (menuItemIndex == 2)
            {
                setMainMenu(player);
                Player[] all = { player };
                Task.Run(() => listPositionAllAircraft(player, player.Army(), true, radar_realism: RADAR_REALISM)); //friendly a/c           
                if (DEBUG)
                {
                    DebugAndLog("Total number of AI aircraft groups currently active:");
                    if (GamePlay.gpAirGroups(1) != null && GamePlay.gpAirGroups(2) != null)
                    {

                        int totalAircraft = GamePlay.gpAirGroups(1).Length + GamePlay.gpAirGroups(2).Length;
                        DebugAndLog(totalAircraft.ToString());
                        //twcLogServer(GamePlay.gpRemotePlayers(), totalAircraft.ToString(), null);
                    }
                }
                //TIME REMAINING ETC//////////////////////////////////  
            }
            else if (menuItemIndex == 3)
            {
                Task.Run(() => showGiantSectorOverview(player, player.Army()));
                setMainMenu(player);

            }
            else if (menuItemIndex == 5)
            {
                /*
                 * Display objectives completed 
                 */
                setMainMenu(player);
                twcLogServer(new Player[] { player }, "Completed Red Objectives (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):", new object[] { });
                twcLogServer(new Player[] { player }, (MissionObjectivesCompletedString[ArmiesE.Red]), new object[] { });
                Timeout(2, () =>
                twcLogServer(new Player[] { player }, "Completed Blue Objectives (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):", new object[] { }));
                Timeout(3, () =>
                twcLogServer(new Player[] { player }, (MissionObjectivesCompletedString[ArmiesE.Blue]), new object[] { }));
                //stopAI();//for testing   

                MO_BRBumrushSituationReport(player: player, silentIfInactive: true);
            }
            else if (menuItemIndex == 6)
            {
                /*
                 * Display objectives remaining
                 */
                setMainMenu(player);
                Task.Run(() => MO_ListRemainingPrimaryObjectives(player, player.Army(), 24));
            }
            else if (menuItemIndex == 7)
            {
                /*
                 * Display Suggested Alternate Objectives
                 */

                //ListSuggestedObjectives(player, Player.army, 5);
                setMainMenu(player);
                Task.Run(() => MO_ListSuggestedObjectives(player, player.Army(), 5));
            }
            else if (menuItemIndex == 8)
            {
                /*
                 * List Scouted Objectives
                 */
                setMainMenu(player);
                Task.Run(() => MO_ListScoutedObjectives(player, player.Army()));

            }
            else if (menuItemIndex == 9)
            {
                /*
                 * Take Recon Photo
                 */
                setMainMenu(player);
                MO_TakeScoutPhoto(player, player.Army());
            }

            else if (menuItemIndex == 4)  //MORE (next) menu
            {
                setSubMenu2(player);
            }


            else
            { //make sure there is a catch-all ELSE or ELSE menu screw-ups WILL occur
                setMainMenu(player);
            }

            //immediate end of mission///////////////


        } //menu if   
    } // method


    /****************************************************************
     * 
     * ADMIN PRIVILEGE
     * 
     * Determine if player is an admin, and what level
     * 
     ****************************************************************/

    public int admin_privilege_level(Player player)
    {
        if (player == null || player.Name() == null) return 0;
        string name = player.Name();
        //name = "TWC_muggle"; //for testing
        if (admins_full.Contains(name)) return 2; //full admin - must be exact character match (CASE SENSITIVE) to the name in admins_full
        if (admins_basic.Any(name.Contains)) return 1; //basic admin - player's name must INCLUDE the exact (CASE SENSITIVE) stub listed in admins_basic somewhere--beginning, end, middle, doesn't matter
        return 0;

    }

    /************************************************************
    * END - MENU SYSTEM
    * *********************************************************/

    //INITIATING THE MENUS FOR THE PLAYER AT VARIOUS KEY POINTS
    public override void OnPlayerConnected(Player player)
    {
        string message;
        //Not starting it here due to Coop Start Mode
        //if (!MISSION_STARTED) DebugAndLog("First player connected; Mission timer starting");
        //MISSION_STARTED = true;        

        //MO_RecordPlayerScoutPhotos(player, false, true); //for testing

        if (MissionNumber > -1)
        {
            setMainMenu(player);

            twcLogServer(new Player[] { player }, "Welcome to " + CAMPAIGN_ID + ", " + player.Name(), new object[] { });
            //twcLogServer(null, "Mission loaded.", new object[] { });

            DateTime utcDate = DateTime.UtcNow;

            //utcDate.ToString(culture), utcDate.Kind
            //Write current time in UTC, what happened, player name
            message = utcDate.ToString("u") + " Connected " + player.Name();

            DebugAndLog(message);
            if (COOP_START_MODE)
            {
                Stb_Chat("CO-OP MISSION START MODE", null);
                Stb_Chat("CO-OP START: You can spawn on the ground and taxi but", null);
                Stb_Chat("DO NOT TAKE OFF OR AIR SPAWN until CO-OP mission start time", null);
            }
        }
    }

    //INITIATING THE MENUS FOR THE PLAYER AT VARIOUS KEY POINTS
    public override void OnPlayerDisconnected(Player player, string diagnostic)
    {
        MO_SpoilPlayerScoutPhotos(player);

        string message;
        if (MissionNumber > -1)
        {

            DateTime utcDate = DateTime.UtcNow;

            //utcDate.ToString(culture), utcDate.Kind
            //Write current time in UTC, what happened, player name
            message = utcDate.ToString("u") + " Disconnected " + player.Name() + " " + diagnostic;
            DebugAndLog(message);
        }
    }

    public override void OnPlayerArmy(Player player, int Army)
    {
        if (MissionNumber > -1)
        {
            /* AiAircraft aircraft = (player.Place() as AiAircraft);
                            string cs = ""; 
                            //int p = part.ParameterTypes.I_VelocityIAS; 
                            double ias = (double) aircraft.getParameter(part.ParameterTypes.I_VelocityIAS, -1);
                            twcLogServer(new Player[] { player }, "Plane: "  
                            + cs + " " + ias, new object[] { });
            */
            //We re-init menu & mission_started here bec. in some situations OnPlayerConnected never happens.  But, they
            //always must choose their army before entering the map, so this catches all players before entering the actual gameplay
            setMainMenu(player);
            if (!MISSION_STARTED) DebugAndLog("First player connected (OnPlayerArmy); Mission timer starting");
            MISSION_STARTED = true;
            //twcLogServer(new Player[] { player }, "Welcome " + player.Name(), new object[] { });
            twcLogServer(new Player[] { player }, "Welcome to " + CAMPAIGN_ID + ", " + player.Name(), new object[] { });
            //twcLogServer(null, "Mission loaded.", new object[] { });
        }
    }
    public override void Inited()
    {
        try
        {
            if (MissionNumber > -1)
            {

                setMainMenu(GamePlay.gpPlayer());
                twcLogServer(null, "Welcome to " + CAMPAIGN_ID, new object[] { });

            }
        }
        catch (Exception ex) { Console.WriteLine("MO_Destroy error3: " + ex.Message); };
    }





    /****************************************
    * END - CHAT COMMANDS
    * **************************************/

    /* public override void OnBattleStarted()
    {
        base.OnBattleStarted();

        if (GamePlay is GameDef)
        {
            (GamePlay as GameDef).EventChat += new GameDef.Chat(Mission_EventChat);
        }
    } */

    //The lines below implement the the chat parser.  See method  OnBattleInit() for how to initialize it.
    //
    //Note that to make this work, you need all (or maybe just most) of these:  
    //
    //  //$reference parts/core/Strategy.dll
    //  //$reference parts/core/gamePlay.dll
    //  using maddox.game;
    //  using maddox.game.world;
    //  using maddox.GP;
    //
    //PLUS you need lines like this in your conf.ini and confs.ini files:
    //
    //  [rts]
    //  scriptAppDomain=0 
    //  ;avoids the dreaded serialization runtime error when running server
    //  ;per http://forum.1cpublishing.eu/showthread.php?t=34797
    //
    // PLUS you need code like this in OnBattleInit() to get it initialized:
    //
    // if (GamePlay is GameDef) (GamePlay as GameDef).EventChat += new GameDef.Chat(Mission_EventChat);
    //
    // PLUS you need code like this in OnBattleStoped() to remove the chat parser when you're done with it:
    //
    // (GamePlay as GameDef).EventChat -= new GameDef.Chat(Mission_EventChat);
    //
    //If we don't remove the new EventChat when the battle is stopped
    //we tend to get several copies of it operating, if we're not careful
    //
    //BONUS: How to send a command to server:
    // public void Chat(string line, Player player)
    //{
    //  if (GamePlay is GameDef) (GamePlay as GameDef).gameInterface.CmdExec("chat " + line + " TO " + player.Name());
    //}
    //And, server commands (not all of them may work or be sensible to use from a script):
    /*
     ?         admin     alias     ban       channel   chat
   console   del       deny      difficulty exit     expel
   f         file      help      history   host      kick
   kick#     mp_dotrange param   sc        secure    set
   show      socket    timeout

   */

    private bool resetmission_requested = false;
    void Mission_EventChat(IPlayer from, string msg)
    {
        if (!msg.StartsWith("<")) return; //trying to stop parser from being such a CPU hog . . . 
        string msg_orig = msg;
        msg = msg.ToLower();
        Player player = from as Player;

        if (msg.StartsWith("<tl"))
        {
            showTimeLeft(from);
            //GamePlay.gp(, from);

        }
        else if (msg.StartsWith("<stock"))
        {
            string m = msg.Substring(6).Trim();
            if (admin_privilege_level(player) < 2)
            {
                if (TWCSupplyMission != null) TWCSupplyMission.DisplayNumberOfAvailablePlanes(player.Army(), player, true, false, m);
            }
            else
            {
                if (TWCSupplyMission != null) TWCSupplyMission.DisplayNumberOfAvailablePlanes(0, player, true, false, m);
            }
        }
        else if (msg.StartsWith("<lost"))
        {
            string m = msg.Substring(5).Trim();
            if (admin_privilege_level(player) < 2)
            {
                if (TWCSupplyMission != null) TWCSupplyMission.ListAircraftLost(player.Army(), player, true, false, m);
            }
            else
            {
                if (TWCSupplyMission != null) TWCSupplyMission.ListAircraftLost(0, player, true, false, m);
            }
        }

        else if (msg.StartsWith("<redstock") && admin_privilege_level(player) >= 2)
        {
            double md = redMultAdmin;
            string ms = msg.Substring(9).Trim();
            try { if (ms.Length > 0) md = Convert.ToDouble(ms); }
            catch (Exception ex) { }

            twcLogServer(new Player[] { player }, "RedStock admin multiplier set to " + md.ToString("n2") + ". Will add " + md.ToString("n2") + "X the regular mission aircraft stock increase at the end of this mission, plus any stock additions regularly due from mission success", null);
            twcLogServer(new Player[] { player }, "To change this value, just re-enter <redstock XX before the mission is over.", null);
            twcLogServer(new Player[] { player }, "To reset the value, enter <redstock 0", null);
            redMultAdmin = md;

        }
        else if (msg.StartsWith("<bluestock") && admin_privilege_level(player) >= 2)
        {
            double md = blueMultAdmin;
            string ms = msg.Substring(10).Trim();
            try { if (ms.Length > 0) md = Convert.ToDouble(ms); }
            catch (Exception ex) { }

            twcLogServer(new Player[] { player }, "BlueStock admin multiplier set to " + md.ToString("n2") + ". Will add " + md.ToString("n2") + "X the regular mission aircraft stock increase at the end of this mission, plus any stock additions regularly due from mission success", null);
            twcLogServer(new Player[] { player }, "To change this value, just re-enter <bluestock XX before the mission is over.", null);
            twcLogServer(new Player[] { player }, "To reset the value, enter <bluestock 0", null);
            blueMultAdmin = md;

        }
        else if (msg.StartsWith("<ai")) //let the player exit the secondary Place - needed for Stuka, 110, etc
        {
            letAiTake2ndPosition(player);
        }
        else if (msg.StartsWith("<obj"))
        {
            //only allow this for admins - mostly so that we can check these items via chat commands @ the console
            if (admin_privilege_level(player) >= 0) // >= 2 previously 
            {

                twcLogServer(new Player[] { player }, "***Please use Tab-4 menu for campaign status when possible", new object[] { });


                Timeout(0.2, () =>
                {

                    MO_ListRemainingPrimaryObjectives(player, player.Army());

                    //twcLogServer(new Player[] { player }, "Blue Primary Objectives: " + MissionObjectivesString[ArmiesE.Blue], new object[] { });
                    twcLogServer(new Player[] { player }, "Blue Objectives Completed (" + MissionObjectiveScore[ArmiesE.Blue].ToString("F0") + " points):" + MissionObjectivesCompletedString[ArmiesE.Blue], new object[] { });
                });

                Timeout(1.2, () =>
                  {

                      //if (player.Army() == 1) twcLogServer(new Player[] { player }, "Red Primary Objectives: " + MissionObjectivesString[ArmiesE.Red], new object[] { });                      

                      twcLogServer(new Player[] { player }, "Red Objectives Completed (" + MissionObjectiveScore[ArmiesE.Red].ToString("F0") + " points):" + MissionObjectivesCompletedString[ArmiesE.Red], new object[] { });
                  });
            }
            else
            {
                twcLogServer(new Player[] { player }, "Please use Tab-4 menu for campaign status", new object[] { });
            }

        }
        else if (msg.StartsWith("<camlong")) //show current campaign state (ie map we're on) and also the campaign results for this mission so far, longer & more detailed analysis
        {
            //only allow this for admins - mostly so that we can check these items via chat commands @ the console
            if (admin_privilege_level(player) >= 0) // >= 2 previously 
            {
                twcLogServer(new Player[] { player }, "***Please use Tab-4 menu for campaign status when possible", new object[] { });
                Tuple<double, string> res = CalcMapMove("", false, true, player);
                //string outputmsg = res.Item2;
                //string msg = "";

                double newMapState = CampaignMapState + res.Item1 + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0;
                summarizeCurrentMapstate(newMapState, true, player);


            }
            else
            {
                twcLogServer(new Player[] { player }, "Please use Tab-4 menu for campaign status", new object[] { });
            }


        }
        else if (msg.StartsWith("<cam")) //show current campaign state (ie map we're on) and also the campaign results for this mission so far
        {
            //only allow this for admins - mostly so that we can check these items via chat commands @ the console
            if (admin_privilege_level(player) >= 0) // >= 2 previously 
            {
                twcLogServer(new Player[] { player }, "***Please use Tab-4 menu for campaign status when possible", new object[] { });

                Tuple<double, string> res = CalcMapMove("", false, false, player);
                double score = res.Item1 * 100;
                string mes = "Campaign score for this mission so far: ";
                if (score > 0) mes += "Red +" + score.ToString("n0");
                else if (score < 0) mes += "Blue +" + (-score).ToString("n0");
                else mes += "A tie!";
                twcLogServer(new Player[] { player }, mes, null);

                double newMapState = CampaignMapState + res.Item1 + MissionObjectiveScore[ArmiesE.Red] / 100.0 - MissionObjectiveScore[ArmiesE.Blue] / 100.0;
                summarizeCurrentMapstate(newMapState, true, player);
            }
            else
            {
                twcLogServer(new Player[] { player }, "Please use Tab-4 menu for campaign status", new object[] { });
            }

        }
        else if (msg.StartsWith("<recon")) //take recon photo
        {
            twcLogServer(new Player[] { player }, "***Please use Tab-4-9 to take recon photos when possible", new object[] { });
            MO_TakeScoutPhoto(player, player.Army());
        }
        else if (msg.StartsWith("<record")) //record recon photo
        {
            MO_RecordPlayerScoutPhotos(player, check: true);
        }
        //landinggroundmission
        else if (msg.StartsWith("<makelg")) //try to make a temporary landing ground
        {
            landinggroundmission.createTempLandingGround(player);
        }
        else if (msg.StartsWith("<testmakelg") && admin_privilege_level(player) >= 1)
        {
            landinggroundmission.createTempLandingGround(player, testing: true);
        }
        else if (msg.StartsWith("<coop start") && admin_privilege_level(player) >= 1)
        {
            twcLogServer(new Player[] { player }, "HELP: Use command '<coop XXX' to change the co-op start time to add XXX more minutes", null);
            twcLogServer(new Player[] { player }, "HELP: Use command '<coop start' to start mission immediately", null);
            if (COOP_START_MODE)
            {

                COOP_MODE_TIME_SEC = 0;
                twcLogServer(new Player[] { player }, "CO-OP Mission will START NOW!", null);
            }
            else
            {
                twcLogServer(new Player[] { player }, "<coop start command works only during initial Co-op Start Mode period", null);
            }

        }

        else if (msg.StartsWith("<coop") && admin_privilege_level(player) >= 1)
        {
            twcLogServer(new Player[] { player }, "HELP: Use command '<coop XXX' to change the co-op start time to add XXX minutes", null);
            twcLogServer(new Player[] { player }, "HELP: Use command '<coop start' to start mission immediately", null);
            if (COOP_START_MODE)
            {
                double time_sec = 5 * 60;
                string time_str = msg.Substring(5).Trim();
                double time_min = Convert.ToDouble(time_str);
                if (time_min != 0 || time_str == "0") time_sec = time_min * 60;


                COOP_MODE_TIME_SEC += time_sec;
                double time_left_sec = COOP_TIME_LEFT_MIN * 60 + time_sec;


                twcLogServer(new Player[] { player }, "CO-OP MODE start time added " + ((double)time_sec / 60).ToString("n1") + " minutes; ", null);
                twcLogServer(new Player[] { player }, (COOP_MODE_TIME_SEC / 60).ToString("n1") + " min. total Co-Op start period; " + (time_left_sec / 60).ToString("n1") + " min. remaining", null);
                Stb_Chat("CO-OP START MODE EXTENDED: " + (time_left_sec / 60).ToString("n1") + " min. until co-op start", null);
            }
            else
            {
                twcLogServer(new Player[] { player }, "<coop command works only during initial Co-op Start Mode period", null);
            }

        }
        //
        else if (msg.StartsWith("<dist") && admin_privilege_level(player) >= 2)
        {
            /*
             * this checks if the plane is near or over enemy teritory
                GamePlay.GamePlay.gpFrontDistance(int army, double x, double y);
                returns a double that gives the distance to enemy front (if exist)
                it returns 0 if you are over enemy teritory or the area you specify.
                if you would know the distance to friendly teritory simply set for army the same army you are.
                Before you should check with GamePlay.gpFrontExist() (returns bool) if a front (frontmarkers) exist. 
            public override void OnTickGame()
                {
                //Point3d P = PlayerPlane.Pos();

                if (!OverEnemyTeritory && GamePlay.gpFrontDistance(1, PlayerPlane.Pos().x, PlayerPlane.Pos().y) <= 0)
                {
                GamePlay.gpHUDLogCenter("Sie befinden sich nun über Feindgebiet!");
                OverEnemyTeritory = true;
                }
                else
                {
                OverEnemyTeritory = false;
                }
            http://forum.1cpublishing.eu/showthread.php?t=26673
            If army==1 and you're in army 1 territory gpFrontDistance(1, will = 0. You would want gpFrontDistance(2, in that case
            */
            if (GamePlay == null) return;
            double playerFrontDistance_m = GamePlay.gpFrontDistance(player.Army(), player.Place().Pos().x, player.Place().Pos().y);
            double playerFrontDistance2_m = GamePlay.gpFrontDistance(3 - player.Army(), player.Place().Pos().x, player.Place().Pos().y);

            twcLogServer(new Player[] { player }, "Your distance from your front " + playerFrontDistance_m.ToString("N0") + " " + playerFrontDistance2_m.ToString("N0"), null);


        }
        else if (msg.StartsWith("<pos") && admin_privilege_level(player) >= 2)
        {
            //int saveRealism = RADAR_REALISM; //save the accurate radar contact lists
            //RADAR_REALISM = 0;
            listPositionAllAircraft(player, player.Army(), false, radar_realism: 0);

            Timeout(4, () =>
            {
                listPositionAllAircraft(player, player.Army(), true, radar_realism: 0);
            });
            //RADAR_REALISM = saveRealism;

        }
        else if (msg.StartsWith("<ps") && admin_privilege_level(player) >= 2)
        {
            listPositionAllAircraft(player, player.Army(), false, radar_realism: 1);

            Timeout(4, () =>
            {
                listPositionAllAircraft(player, player.Army(), true, radar_realism: 1);
            });

        }
        else if (msg.StartsWith("<gps") && admin_privilege_level(player) >= 2)
        {
            //Dictionary<AiAirGroup, AirGroupInfo> airGroupInfoDict = airGroupInfoCircArr.GetStack(0); //Most recent iteration of airgroup groupings

            Dictionary<AiAirGroup, AirGroupInfo> airGroupInfoDict;

            //so lock airGroupInfoCircArrf PLUS making a copy of airGroupInfoCircArr.Get(0) rather than just directly referencing it, SHOULD (?!?) make this thread safe?
            lock (airGroupInfoCircArr)
            {
                airGroupInfoDict = new Dictionary<AiAirGroup, AirGroupInfo>(airGroupInfoCircArr.Get(0)); //Most recent iteration of airgroup groupings            
            }

            foreach (AiAirGroup ag in airGroupInfoDict.Keys)
            {
                Console.WriteLine(airGroupInfoDict[ag].ToString());
            }

        }
        else if (msg.StartsWith("<rad") && admin_privilege_level(player) >= 2)
        {
            Task.Run(() => { listPositionAllAircraft(player, player.Army(), false, radar_realism: RADAR_REALISM); }); //enemy a/c   
        }
        else if (msg.StartsWith("<exit") && admin_privilege_level(player) >= 2)
        {
            EndMission(0); //end immediately/for testing
        }
        else if (msg.StartsWith("<rctest") && admin_privilege_level(player) >= 2)
        {
            Point3d? test = new Point3d(237074, 243644, 20000);
            //(69050,182277)
            //Point3d? test = new Point3d(69050, 182277, 15000);
            string[] words = msg_orig.Split(' ');
            if (words.Length >= 3 && words[1].Length > 0 && words[2].Length > 0)
            {
                double x = Convert.ToInt32(words[1]);
                double y = Convert.ToInt32(words[2]);
                double z = 60000;
                test = new Point3d(x, y, z);
            }
            MO_TakeScoutPhoto(player, player.Army(), 0, test);
        }
        else if (msg.StartsWith("<stattest") && admin_privilege_level(player) >= 2)
        {
            Point3d test = new Point3d(237074, 243644, 20000);
            //(69050,182277)
            //Point3d? test = new Point3d(69050, 182277, 15000);
            string[] words = msg_orig.Split(' ');
            if (words.Length >= 3 && words[1].Length > 0 && words[2].Length > 0)
            {
                double x = Convert.ToInt32(words[1]);
                double y = Convert.ToInt32(words[2]);
                double z = 60000;
                test = new Point3d(x, y, z);
            }
            Calcs.anyEnemyOrNeutralStationaries(GamePlay, test.x, test.y, 2000, player.Army());
        }

        else if (msg.StartsWith("<rcrecord") && admin_privilege_level(player) >= 2)
        {
            MO_RecordPlayerScoutPhotos(player, true, true);
        }
        else if (msg.StartsWith("<scoutlist") && admin_privilege_level(player) >= 2)
        {
            string l = MO_PlayersWhoScoutedObjectivesList("Red");
            Console.WriteLine(l);
            l = MO_PlayersWhoScoutedObjectivesList("Blue");
            Console.WriteLine(l);
        }
        /*
        else if (msg.StartsWith("<rcdest") && admin_privilege_level(player) >= 2)
        {
            MO_DestroyObjective("BTarget14R", true);
            //destroy a random airport
            Timeout(5, () =>
           {
               var apkeys = new List<AiAirport>(AirfieldTargets.Keys.Count);
               apkeys = AirfieldTargets.Keys.ToList();

               AiAirport ap = apkeys.ElementAt(random.Next(apkeys.Count));
               string Mission = AirfieldTargets[ap].Item2;

               twcLogServer(new Player[] { player }, "Destroying airport " + Mission, new object[] { });

               MO_DestroyObjective(Mission + "_spawn", true);
           });
        }
        */

        else if (msg.StartsWith("<brcount") && admin_privilege_level(player) >= 2)
        {
            bool resultbr = false;
            for (int i = Convert.ToInt32(MO_BRBumrushAirbaseOccupyDistance_m); i < Convert.ToInt32(MO_BRBumrushAirbaseClearPerimeterDistance_m * 2); i += 500)
            {
                //foreach (string s in MO_BRBumrushTargetAirfieldsList)
                {
                    //MissionObjective mo = MissionObjectivesList[s + "_spawn"];
                    MissionObjective mo = MO_BRCurrentBumrushMissionObjective();
                    //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, 1, AiGroundGroupType.Vehicle);
                    //int result1 = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, 2, AiGroundGroupType.Vehicle);
                    //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.BumrushObjective.Pos, 2500, army, AiGroundGroupType.Vehicle);
                    int redFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, matcharmy: 1, type: "Vehicle");
                    int redFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, matcharmy: 1, type: "Artillery");

                    int redFar = redFarArtillery + redFarVehicle;

                    int blueFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, matcharmy: 2, type: "Vehicle");
                    int blueFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, i, matcharmy: 2, type: "Artillery");

                    int blueFar = blueFarArtillery + blueFarVehicle;

                    if (redFar > 0 || blueFar > 0)
                    {
                        twcLogServer(new Player[] { player }, "Current convoy/artillery sitrep for " + mo.Name + " at " + i.ToString() + ": Red - " + redFarVehicle.ToString() + "," + redFarArtillery.ToString() + "  Blue - " + blueFarVehicle.ToString() + "," + redFarArtillery.ToString(), null);
                        //twcLogServer(new Player[] { player }, "Artillery: Red - " + redFarArtillery.ToString() + "  Blue - " + blueFarArtillery.ToString(), null);
                        resultbr = true;
                    }
                }
            }
            if (!resultbr) twcLogServer(new Player[] { player }, "Current BR sitrep: No Red or Blue Vehicles near the BR airfield", null);
        }

        else if (msg.StartsWith("<brremove") && admin_privilege_level(player) >= 2)
        {
            twcLogServer(new Player[] { player }, "Removing groundstationaries & ground actors from current Bumrush area...", null);
            if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus > 0) Calcs.removeArtilleryAAGroundVehicles(GamePlay, this, AllGroundDict, MO_BRBumrushInfo[(ArmiesE)1].BumrushObjective.Pos.x, MO_BRBumrushInfo[(ArmiesE)1].BumrushObjective.Pos.y, 4000);
            if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) Calcs.removeArtilleryAAGroundVehicles(GamePlay, this, AllGroundDict, MO_BRBumrushInfo[(ArmiesE)2].BumrushObjective.Pos.x, MO_BRBumrushInfo[(ArmiesE)2].BumrushObjective.Pos.y, 4000);
        }
        else if (msg.StartsWith("<obair") && admin_privilege_level(player) >= 2)
        {

            //foreach (string ID in MissionObjectivesList.Keys)
            //MO_TestObjectiveWithFlak(MissionObjectivesList[ID], 1, 1);
            //string[] words = msg_orig.Split(' ');
            string objective = msg_orig.Substring(6).Trim();

            if (MissionObjectivesList.ContainsKey(objective))
            {
                twcLogServer(new Player[] { player }, "Creating an airspawn above the objective {0} - {1}", new object[] { objective, MissionObjectivesList[objective].Name });
                ISectionFile f2 = GamePlay.gpCreateSectionFile();
                MissionObjective mo = MissionObjectivesList[objective];
                int maxLen = 13;
                if (mo.ID.Length < 13) maxLen = mo.ID.Length;
                string bname = mo.ID.Substring(0, maxLen) + "_airspawn" + random.Next(10, 99).ToString("F0"); //apparently birthplace names can't be too long?
                Point3d pos = mo.returnCurrentPosWithChief();
                f2 = Calcs.CreateBirthPlace(f2, bname, pos.x, pos.y, 1000, mo.AttackingArmy);
                GamePlay.gpPostMissionLoad(f2);
                f2.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/" + bname);
            }
            else
            {
                twcLogServer(new Player[] { player }, "Trying to create an airspawn above the objective ID {0} - but can't find that objective! You need to enter the objective ID.", new object[] { objective });
            }
        }
        else if (msg.StartsWith("<obflaktest") && admin_privilege_level(player) >= 2)
        {

            //foreach (string ID in MissionObjectivesList.Keys)
            //MO_TestObjectiveWithFlak(MissionObjectivesList[ID], 1, 1);
            string objective = msg_orig.Substring(12).Trim();
            twcLogServer(new Player[] { player }, "Places 4 flak guns near the objective, which will shoot/kill it.  Good for testing trigger-type objectives, or PointArea.  Combine with <bombtest ", new object[] { objective });
            twcLogServer(new Player[] { player }, "Objective ID & Name: {0} {1}", new object[] { objective, MissionObjectivesList[objective].Name });
            MO_TestObjectiveWithFlak(MissionObjectivesList[objective], 4, 4);

        }
        else if (msg.StartsWith("<obdest") && admin_privilege_level(player) >= 2)
        {
            //foreach (string ID in MissionObjectivesList.Keys)
            //MO_TestObjectiveWithFlak(MissionObjectivesList[ID], 1, 1);            
            string objective = msg_orig.Substring(7).Trim();
            //twcLogServer(new Player[] { player }, "0", new object[] { });
            twcLogServer(new Player[] { player }, "Calling destroy_objective sperroutine for {0}", new object[] { objective });
            //twcLogServer(new Player[] { player }, "1", new object[] {  });

            if (objective.ToLower() == "red" || objective.ToLower() == "blue")
            {
                //twcLogServer(new Player[] { player }, "2", new object[] { });
                int currArmy = 1;
                if (objective.ToLower() == "blue") currArmy = 2;

                foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
                {
                    //twcLogServer(new Player[] { player }, "3", new object[] { });
                    MissionObjective mo = entry.Value;
                    string moKey = entry.Key;
                    if (!MissionObjectivesList.ContainsKey(moKey))
                    {
                        twcLogServer(new Player[] { player }, "Couldn't find Objective ID: {0}", new object[] { moKey });
                        return;
                    }
                    //twcLogServer(new Player[] { player }, "4", new object[] { });

                    //if ((!mo.ObjectiveAchievedForPoints || !mo.Destroyed) && mo.AttackingArmy == currArmy && mo.IsPrimaryTarget)
                    if (mo.AttackingArmy == currArmy && mo.IsPrimaryTarget)
                    {
                        MO_DestroyObjective(moKey, true);
                    }
                }
            }
            else
            {
                twcLogServer(new Player[] { player }, "5", new object[] { });
                if (!MissionObjectivesList.ContainsKey(objective))
                {
                    twcLogServer(new Player[] { player }, "6", new object[] { });
                    twcLogServer(new Player[] { player }, "Couldn't find Objective ID: {0}", new object[] { objective });
                    return;
                }
                twcLogServer(new Player[] { player }, "7", new object[] { });
                twcLogServer(new Player[] { player }, "Objective ID & Name: {0} {1}", new object[] { objective, MissionObjectivesList[objective].Name });
                MO_DestroyObjective(objective, true);
            }

        }

        else if (msg.StartsWith("<bombtest") && admin_privilege_level(player) >= 2)
        {

            //foreach (string ID in MissionObjectivesList.Keys)
            //MO_TestObjectiveWithFlak(MissionObjectivesList[ID], 1, 1);
            /*
            string[] words = msg_orig.Split(' ');
            twcLogServer(new Player[] { player }, "Destroying all trigger-type objectives for {0} with enemy artillery.  Note that this will not drop bombs to test the non-trigger type objectives ", new object[] { words[1], MissionObjectivesList[words[1]].Name });
            MO_TestObjectiveWithFlak(MissionObjectivesList[words[1]], 4, 4);
            */
            //string[] words = msg_orig.Split(' ');

            string sub = msg_orig.Substring(9).Trim();

            MissionObjective mo = null;

            if (sub.Length > 1 && MissionObjectivesList.ContainsKey(sub)) mo = MissionObjectivesList[sub];
            else
            {
                twcLogServer(new Player[] { player }, "Couldn't find that one. Requested ID: {0}", new object[] { sub });
                return;
            }

            twcLogServer(new Player[] { player }, "Dropping bombs on {1}. Requested ID: {0}. Note: Only simulates counting up the results of bomb explosions within -main.cs.  Won't destroy statics or do anything else internal to CloD ", new object[] { sub, MissionObjectivesList[sub].Name });

            AiDamageInitiator initiator = new AiDamageInitiator(player.Place(), player.PersonPrimary(), player, new AiDamageTool(AiDamageToolType.Ordance, "BrentBomb"));

            int howmany = 60;

            if (Calcs.GetAircraftType(player.Place() as AiAircraft).Contains("Blenheim")) howmany = 15;

            for (int i = 1; i < howmany; i++)
            {
                Point3d pos = mo.Pos;
                pos.x += random.Next(600) - 300;
                pos.y += random.Next(600) - 300;
                OnBombExplosion_DoWork("Bombe", 500, pos, initiator, 1);
            }

        }
        else if (msg.StartsWith("<killtest") && admin_privilege_level(player) >= 2)
        {

            //foreach (string ID in MissionObjectivesList.Keys)
            //MO_TestObjectiveWithFlak(MissionObjectivesList[ID], 1, 1);
            /*
            string[] words = msg_orig.Split(' ');
            twcLogServer(new Player[] { player }, "Destroying all trigger-type objectives for {0} with enemy artillery.  Note that this will not drop bombs to test the non-trigger type objectives ", new object[] { words[1], MissionObjectivesList[words[1]].Name });
            MO_TestObjectiveWithFlak(MissionObjectivesList[words[1]], 4, 4);
            */
            //string[] words = msg_orig.Split(' ');

            string sub = msg_orig.Substring(9).Trim();

            MissionObjective mo = null;

            if (sub.Length > 1 && MissionObjectivesList.ContainsKey(sub)) mo = MissionObjectivesList[sub];
            else
            {
                twcLogServer(new Player[] { player }, "Couldn't find that one. Requested ID: {0}", new object[] { sub });
                return;
            }

            MissionObjective mo1 = MissionObjectivesList[sub];

            twcLogServer(new Player[] { player }, "Killing all actors we can find near {0} {1} and any actors anywhere with the 'Chief' name '{2}'.  This helps with testing trigger & pointarea type objectives. You may need to ALSO <bombtest <triggertest etc ", new object[] { sub, mo1.Name, mo1.ChiefName });

            int kabnm = 0;
            int kgan = 0;

            if (mo1.ChiefName.Length > 0) kabnm = Calcs.KillActorsByNameMatch(gpBattle, GamePlay, this, AllActorsDict, mo1.ChiefName);

            kgan = Calcs.KillGroundActorsNear(gpBattle, GamePlay, this, AllActorsDict, mo1.returnCurrentPosWithChief(), 3000);

            twcLogServer(new Player[] { player }, "Killed {0} actors by match with name {1} and {2} actors near the objectives {3} ", new object[] { kabnm, mo1.ChiefName, kgan, mo1.Name });


        }



        else if (msg.StartsWith("<resetmission") && admin_privilege_level(player) >= 2)
        {
            if (!resetmission_requested)
            {
                resetmission_requested = true;
                Timeout(30, () => { resetmission_requested = false; });
                twcLogServer(new Player[] { player }, "CONFIRMATION REQUIRED!!!!!! To reset all current mission objectives for both sides, objectives scouted, re-read mission objectives afresh, current team scores, enter <resetmission again within 30 seconds", new object[] { });
                return;

            }

            twcLogServer(new Player[] { player }, "RESETTING ALL mission objectives, objectives scouted, re-read mission objectives afresh, current team scores", new object[] { });

            try
            {
                MO_BRStopBumrushPhase(1);
            }
            catch { }
            try
            {
                MO_BRStopBumrushPhase(2);
            }
            catch { }

            MissionObjectivesList = new Dictionary<string, MissionObjective>();  //zero out the mission objectives list (otherwise when we run the routine below they will ADD to anything already there)
            mission_objectives.RadarPositionTriggersSetup();
            mission_objectives.MissionObjectiveTriggersSetup();
            twc_tobruk_campaign_mission_objectives.RadarPositionTriggersSetup();
            twc_tobruk_campaign_mission_objectives.MissionObjectiveTriggersSetup();
            MO_MissionObjectiveAirfieldsSetup(this, GamePlay, addNewOnly: false); //must do this after the Radar & Triggers setup, as it uses info from those objectives  
            twc_tobruk_campaign_mission_objectives.MissionObjectiveAirfieldFocusBumrushSetup(); //must always be done right AFTER MO_MissionObjectiveAirfieldsSetup as it tweaks the airfields setup
            MO_SelectPrimaryObjectives(1, 0, fresh: true);
            MO_SelectPrimaryObjectives(2, 0, fresh: true);
            mission_objectives.SelectSuggestedObjectives(ArmiesE.Blue);
            mission_objectives.SelectSuggestedObjectives(ArmiesE.Red);
            MissionObjectiveScore[ArmiesE.Red] = 0;
            MissionObjectiveScore[ArmiesE.Blue] = 0;
            MissionObjectivesCompletedString[ArmiesE.Red] = "";
            MissionObjectivesCompletedString[ArmiesE.Blue] = "";

            //MO_HandleGeneralStaffPlacement(); //Gen'l staff is already placed & this will double place it
            //MO_LoadAllPrimaryObjectiveFlak(mission_objectives.FlakMissions);  //loading double flak won't be good
            //MO_InitializeAllObjectives(); //this will double-load autoflak, any statics.  So just have to re-start server to make any changes
        }


        else if (msg.StartsWith("<testturnred") && admin_privilege_level(player) >= 2)
        {
            //MO_CheckObjectivesComplete(TestingOverrideArmy: 1);
            //MO_MissionObjectiveRollingWinnersReward(ArmiesE.Red);
            MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Red);
        }
        else if (msg.StartsWith("<testturnblue") && admin_privilege_level(player) >= 2)
        {
            //MO_CheckObjectivesComplete(TestingOverrideArmy: 2);
            MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Blue);
        }
        //MO_BRBumrushCheck,
        //new Tuple<int, MissionObjective>(army, mo),
        //army,
        //new Tuple<int, bool, int>(army, false, 0),
        else if (msg.StartsWith("<testbumwinblue") && admin_privilege_level(player) >= 2)
        {
            twcLogServer(new Player[] { player }, "Testing BLUE win of current bumrush battle now", new object[] { });
            MO_BRBumrushCheck(new Tuple<int, bool, int>(MO_BRCurrentBumrushArmy, true, 2));

        }
        else if (msg.StartsWith("<testbumwinred") && admin_privilege_level(player) >= 2)
        {
            twcLogServer(new Player[] { player }, "Testing RED win of current bumrush battle now", new object[] { });
            MO_BRBumrushCheck(new Tuple<int, bool, int>(MO_BRCurrentBumrushArmy, true, 1));

        }
        else if (msg.StartsWith("<testbumadvance") && admin_privilege_level(player) >= 2)
        {
            twcLogServer(new Player[] { player }, "Advancing bumrush to next phase NOW", new object[] { });
            MO_BRAdvanceBumrushPhase(new Tuple<int, bool>(MO_BRCurrentBumrushArmy, true));
        }
        //MO_BRAdvanceBumrushPhase(new Tuple<int, bool>(army, true)); }
        //removeSmokeFireCraters(Point3d p, double radius_m)
        else if (msg.StartsWith("<testclean") && admin_privilege_level(player) >= 2)
        {
            Point3d p = new Point3d(284703, 125257, 0);
            double r = 9000;

            string[] words = msg_orig.Split(' ');
            if (words.Length > 1)
            {
                p = new Point3d(Convert.ToDouble(words[1]), Convert.ToDouble(words[2]), 0);
                r = Convert.ToDouble(words[3]);

            }
            removeSmokeFireCraters(p, r);
        }
        else if (msg.StartsWith("<testlist") && admin_privilege_level(player) >= 2)
        {
            Point3d p = new Point3d(284703, 125257, 0);
            double r = 9000;

            string[] words = msg_orig.Split(' ');

            Calcs.listStatics(GamePlay, new List<string>() { "smoke", "fire", "crater", "jerry" });
        }


        else if (msg.StartsWith("<smoke") && admin_privilege_level(player) >= 2)
        {
            Point3d pos = new Point3d(10000, 100000, 0);
            if (player.Place() != null) pos = player.Place().Pos();
            Calcs.loadSmokeOrFire(GamePlay, this, pos.x + random.Next(100) + 10, pos.y + random.Next(100) + 10, 0, "BuildingFireBig", duration_s: 6 * 3600);
            Calcs.loadSmokeOrFire(GamePlay, this, pos.x + random.Next(100) + 10, pos.y + random.Next(100) + 10, 0, "BuildingFireSmall", duration_s: 6 * 3600);
            Calcs.loadSmokeOrFire(GamePlay, this, pos.x + random.Next(100) + 10, pos.y + random.Next(100) + 10, 0, "Smoke1", duration_s: 6 * 3600);
        }
        else if (msg.StartsWith("<apdest") && admin_privilege_level(player) >= 2)
        {
            AiAirport ap = Calcs.nearestAirport(GamePlay, player.Place().Pos(), player.Army());
            AirfieldDisable(ap, 1);

        }
        //string firetype = "BuildingFireSmall"; //small-ish
        //if (mass_kg > 200) firetype = "BigSitySmoke_1"; //500lb bomb or larger  //REALLY huge
        //if (mass_kg > 200) firetype = "Smoke1"; //500lb bomb or larger //larger


        else if (msg.StartsWith("<pad"))
        {

            if (admin_privilege_level(player) >= 2)
            {
                showGiantSectorOverview(player, 2);  //Blue enemies
                showGiantSectorOverview(player, 1); //Red enemies
                showGiantSectorOverview(player, 0); //all
            }
            else showGiantSectorOverview(player, player.Army()); //enemies of current player
            /*
            Timeout(0.1, () => twcLogServer(new Player[] { player }, "***Schematic Map Overview of Enemy Activity***", null));
            Timeout(0.1, () => twcLogServer(new Player[] { player }, "Airgroups:Aircraft in each Large Map Keypad area", null));
            Timeout(0.1, () => twcLogServer(new Player[] { player }, "For more details, ask your Commander or Radar Operator to consult the Contact Plotting Table: ", null));          
            //Console.WriteLine("Giant: " + GiantSectorOverview.ToString());
            Timeout(0.1, () =>
            {
                for (int i = 2; i > -1; i--)
                {

                    twcLogServer(new Player[] { player }, "{0:D3}:{1:D3} {2:D3}:{3:D3} {4:D3}:{5:D3} ", new object[] {
                    GiantSectorOverview[player.Army()][i*3+1, 0], GiantSectorOverview[player.Army()][i*3+1, 1],
                    GiantSectorOverview[player.Army()][i*3+2, 0], GiantSectorOverview[player.Army()][i*3+2, 1],
                    GiantSectorOverview[player.Army()][i*3+3, 0], GiantSectorOverview[player.Army()][i*3+3, 1]

                });
                }
            });
            */
        }
        else if (msg.StartsWith("<apall") && admin_privilege_level(player) >= 2)
        {
            ListAirfieldTargetDamage(player, -1, true);//list ALL airports, damaged or not, of both teams
        }
        else if (msg.StartsWith("<ap"))
        {
            //only allow this for admins - mostly so that we can check these items via chat commands @ the console
            if (admin_privilege_level(player) >= 2)
            {

                //ListAirfieldTargetDamage(player, -1); //list damaged airport of both teams
                ListRadarTargetDamage(player, -1);
                Timeout(2, () => { ListAirfieldTargetDamage(player, -1); });
            }
            else
            {
                twcLogServer(new Player[] { player }, "Please use Tab-4 menu to check airport status", new object[] { });
            }
        }
        else if (msg.StartsWith("<server") && admin_privilege_level(player) >= 2)
        {
            string tr = msg_orig.Substring(7).Trim();
            SERVER_ID_SHORT = tr;
            twcLogServer(new Player[] { player }, "Server renamed to " + tr + " for the remainder of this session.", new object[] { });

        }
        else if (msg.StartsWith("<trigger") && admin_privilege_level(player) >= 2)
        {


            string tr = msg_orig.Substring(8).Trim();

            twcLogServer(new Player[] { player }, "Trying to activate trigger " + tr, new object[] { });

            if (GamePlay.gpGetTrigger(tr) != null)
            {
                GamePlay.gpGetTrigger(tr).Enable = true;
                //GamePlay.gpGetTrigger(tr).Active = true;
                twcLogServer(new Player[] { player }, "Enabled trigger " + tr, new object[] { });
            }

            //this.OnTrigger(1, tr, true);

            Battle.OnEventGame(GameEventId.Trigger, tr, true, 1);

            /*
            AiAction action = GamePlay.gpGetAction("action1");

            if (action != null)
            {
                action.Do();
            }
            */
        }
        else if (msg.StartsWith("<action") && admin_privilege_level(player) >= 2)
        {


            string tr = msg_orig.Substring(7).Trim();

            AiAction action = GamePlay.gpGetAction(tr);

            if (action != null)
            {
                action.Do();
                twcLogServer(new Player[] { player }, "Activating action " + tr, new object[] { });
            }
            else
            {
                twcLogServer(new Player[] { player }, "Didn't find action " + tr + "! No action taken.", new object[] { });
            }



        }
        else if (msg.StartsWith("<nalt") && admin_privilege_level(player) >= 2)
        {
            double zAlt_m = (player.Place() as AiAircraft).getParameter(part.ParameterTypes.Z_AltitudeAGL, 0); // I THINK (?) that Z_AltitudeAGL is in meters?
            double alt = Calcs.AltitudeAGL_m(player.Place().Pos());
            double elev = twcLandscape.HQ(player.Place().Pos().x, player.Place().Pos().y);
            twcLogServer(new Player[] { player }, "Altitude: " + zAlt_m.ToString() + " " + alt.ToString() + " " + elev.ToString(), new object[] { });

        }

        else if (msg.StartsWith("<nump") && admin_privilege_level(player) >= 2)
        {
            int nump = Calcs.gpNumberOfPlayers(GamePlay);
            twcLogServer(new Player[] { player }, "stopAI: " + nump.ToString() + " players currently online", new object[] { });

        }
        else if (msg.StartsWith("<warp") && admin_privilege_level(player) >= 2)
        {

            TWCComms.Communicator.Instance.WARP_CHECK = !TWCComms.Communicator.Instance.WARP_CHECK;
            twcLogServer(new Player[] { player }, "WARP_CHECK is set to " + TWCComms.Communicator.Instance.WARP_CHECK.ToString(), new object[] { });

        }

        else if (msg.StartsWith("<testend") && admin_privilege_level(player) >= 2)
        {

            SaveMapState("", false); //here is where we save progress/winners towards moving the map & front one way or the other; also saves the Supply State

            CheckStatsData(); //Save campaign/map state just before final exit.  This is important because when we do (GamePlay as GameDef).gameInterface.CmdExec("exit"); to exit, the -stats.cs will read the CampaignSummary.txt file we write here as the final status for the mission in the team stats.
                              //(TWCStatsMission as AMission).OnBattleStoped();  This works but we don't want to do it, everything breaks afterwards!
            MapStateSaved = false; //fooling it, this will mess with the campaign status etc, but for testing . . . 
            twcLogServer(new Player[] { player }, "End test complete savemapstate", new object[] { });

        }
        else if (msg.StartsWith("<debugon") && admin_privilege_level(player) >= 2)
        {

            DEBUG = true;
            twcLogServer(new Player[] { player }, "Debug is on", new object[] { });

        }

        else if (msg.StartsWith("<debugoff") && admin_privilege_level(player) >= 2)
        {

            DEBUG = false;
            twcLogServer(new Player[] { player }, "Debug is off", new object[] { });

        }
        else if (msg.StartsWith("<logon") && admin_privilege_level(player) >= 2)
        {

            LOG = true;
            twcLogServer(new Player[] { player }, "Log is on", new object[] { });

        }
        else if (msg.StartsWith("<logoff") && admin_privilege_level(player) >= 2)
        {

            LOG = false;
            twcLogServer(new Player[] { player }, "Log is off", new object[] { });

        }
        else if (msg.StartsWith("<endm") && admin_privilege_level(player) >= 2)
        {
            if (EndMissionSelected == false)
            {
                EndMissionSelected = true;
                twcLogServer(new Player[] { player }, "ENDING MISSION!! If you want to cancel the End Mission command, use <endm again.  You have 10 seconds to cancel.", new object[] { });
                Timeout(10, () =>
                {
                    if (EndMissionSelected)
                    {
                        EndMission(0);
                    }
                    else
                    {
                        twcLogServer(new Player[] { player }, "End Mission CANCELLED; Mission continuing . . . ", new object[] { });
                        twcLogServer(new Player[] { player }, "If you want to end the mission, you can use the menu to select Mission End again now.", new object[] { });
                    }

                });

            }
            else
            {
                twcLogServer(new Player[] { player }, "End Mission CANCELLED; Mission will continue", new object[] { });
                EndMissionSelected = false;

            }
        }

        else if (msg.StartsWith("<test") && admin_privilege_level(player) >= 2)
        {
            var radar_messages = new Dictionary<string, string> {
                {  "1", "YOU TYPED <TEST a;dslfkaj;ldkf ja;ldfj a;slf ja;slfjjfeifjeij aij fiajf iasjf iajdf iajf aisjfd aisdfj aisfdj asidfj asifdj aisf jaisfj " },
                {  "2", "a;dslfkaj;ldkf ja;ldfj a;slf ja;slfjjfeifjeij aij fiajf iasjf iajdf iajf aisjfd aisdfj aisfdj asidfj asifdj aisf jaisfj " },
                {  "3", "a;dslfkaj;ldkf ja;ldfj a;slf ja;slfjjfeifjeij aij fiajf iasjf iajdf iajf aisjfd aisdfj aisfdj asidfj asifdj aisf jaisfj " },
                {  "4", "a;dslfkaj;ldkf ja;ldfj a;slf ja;slfjjfeifjeij aij fiajf iasjf iajdf iajf aisjfd aisdfj aisfdj asidfj asifdj aisf jaisfj " },
                {  "5", "a;dslfkaj;ldkf ja;ldfj a;slf ja;slfjjfeifjeij aij fiajf iasjf iajdf iajf aisjfd aisdfj aisfdj asidfj asifdj aisf jaisfj " }
                };
            double delay = 0.05;
            foreach (var mess in radar_messages)
            {
                delay += 0.05;
                Timeout(delay, () =>
                {
                    gpLogServerAndLog(new Player[] { player }, mess.Value, null);
                });

            }
        }
        else if (msg.StartsWith("<admin") && admin_privilege_level(player) >= 2)
        {

            twcLogServer(new Player[] { player }, "Admin commands: <stock <lost <bluestock <redstock <coop <trigger <action <debugon <debugoff <logon <logoff <endmission", new object[] { });
            twcLogServer(new Player[] { player }, "<resetmission", new object[] { });
            twcLogServer(new Player[] { player }, "Server test commands: <rctest 100000 100000 - instant recon of that point, <rcrecord record all rctest recon photos, ", new object[] { });
            twcLogServer(new Player[] { player }, "<testturnred, <testturnblue, <obair objectiveID (make airspawn above OBJ), <obflaktest objectiveID (place flak guns to kill objective), <killtest ID (kill all actors @ objective)", new object[] { });
            twcLogServer(new Player[] { player }, "Server test commands: <bombtest ID bomb an ap <apdest disable an airfield, <testturnred <testturnblue", new object[] { });
            twcLogServer(new Player[] { player }, "Server test commands: <obdest ID - destroy an objective or <obdest red, <obdest blue, <brcount Bumrush current count, <brremove remove current Bumrush", new object[] { });
            //"<testbumwinblue"
            twcLogServer(new Player[] { player }, "<testbumwinblue <testbumwinred - in the Bumrush phase, test one side winning @ that point; <testbumadvance - advance bumrush phase now", new object[] { });

        }
        else if ((msg.StartsWith("<help") || msg.StartsWith("<")) &&
            //Don't give our help when any of these typical -stats.cs chat commands are entered
            !(msg.StartsWith("<car") || msg.StartsWith("<ses") || msg.StartsWith("<rank") || msg.StartsWith("<rr")
            || msg.StartsWith("<ter") || msg.StartsWith("<air") || msg.StartsWith("<ac") || msg.StartsWith("<nextac")
            || msg.StartsWith("<net") || msg.StartsWith("<k") || msg.StartsWith("<cov"))

            )
        {
            Timeout(0.1, () =>
            {
                string m = "Commands: <tl Time Left; <rr Rearm/reload; <ai let AI take over gunner position; <recon take recon photo; <record send recon photos to HQ";
                if (admin_privilege_level(player) >= 2) m += "; <admin";
                twcLogServer(new Player[] { player }, m, new object[] { });
                //twcLogServer(new Player[] { player }, "<ap & <apall Airport condition", new object[] { });
                //twcLogServer(new Player[] { player }, "<coop Use Co-Op start mode only @ beginning of mission", new object[] { });
                //GamePlay.gp(, from);
            });
        }
    }


    /****************************************
    * END - CHAT COMMANDS
    * **************************************/

    ////////////////////////////////////////////////////////////////////////////////////////////////////

    // destroys aircraft abandoned by a player.
    private bool isAiControlledPlane(AiAircraft aircraft)
    {
        if (aircraft == null)
        {
            return false;
        }

        Player[] players = GamePlay.gpRemotePlayers();
        foreach (Player p in players)
        {
            if (p != null && (p.Place() is AiAircraft) && (p.Place() as AiAircraft) == aircraft)
            {
                return false;
            }
        }

        return true;
    }

    private void destroyPlane(AiAircraft aircraft)
    {
        if (aircraft != null)
        {
            aircraft.Destroy();
        }
    }

    private void explodeFuelTank(AiAircraft aircraft)
    {
        if (aircraft != null)
        {
            aircraft.hitNamed(part.NamedDamageTypes.FuelTank0Exploded);
        }
    }

    private void destroyAiControlledPlane(AiAircraft aircraft)
    {
        if (isAiControlledPlane2(aircraft))
        {
            destroyPlane(aircraft);
        }
    }

    private void damageAiControlledPlane(AiActor actor)
    {
        if (actor == null || !(actor is AiAircraft))
        {
            return;
        }

        AiAircraft aircraft = (actor as AiAircraft);

        if (!isAiControlledPlane2(aircraft))
        {
            return;
        }

        if (aircraft == null)
        {
            return;
        }

        aircraft.hitNamed(part.NamedDamageTypes.ControlsElevatorDisabled);
        aircraft.hitNamed(part.NamedDamageTypes.ControlsAileronsDisabled);
        aircraft.hitNamed(part.NamedDamageTypes.ControlsRudderDisabled);
        aircraft.hitNamed(part.NamedDamageTypes.FuelPumpFailure);
        aircraft.hitNamed(part.NamedDamageTypes.Eng0TotalFailure);
        aircraft.hitNamed(part.NamedDamageTypes.ElecPrimaryFailure);
        aircraft.hitNamed(part.NamedDamageTypes.ElecBatteryFailure);

        aircraft.hitLimb(part.LimbNames.WingL1, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL2, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL3, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL4, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL5, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL6, -0.5);
        aircraft.hitLimb(part.LimbNames.WingL7, -0.5);

        int iNumOfEngines = (aircraft.Group() as AiAirGroup).aircraftEnginesNum();
        for (int i = 0; i < iNumOfEngines; i++)
        {
            aircraft.hitNamed((part.NamedDamageTypes)Enum.Parse(typeof(part.NamedDamageTypes), "Eng" + i.ToString() + "TotalFailure"));
        }

        /***Timeout (240, () =>
                {explodeFuelTank (aircraft);}
            );
         * ***/

        Timeout(300, () =>
        { destroyPlane(aircraft); }
            );
    }

    public string updateTimeAndWeather (string missionFile, string desiredString)
    {
        RegexOptions ro = RegexOptions.IgnoreCase | RegexOptions.Multiline;
        missionFile = Regex.Replace(missionFile, @"^\s*TIME\s*\d*\.?\d*\s*$", desiredString, ro);//looks for a line with something like <spaces> TIME <spaces> 34.234 .. Case irrelevant = replaces it
        
        string desiredCloudsHeightString = "  CloudsHeight " + random.Next(500, 1500).ToString("F0"); //seems limited to 500-1500 meters.  See https://www.aircombatgroup.co.uk/forum/viewtopic.php?f=5&t=8360
        //Also MAYBE for cumulous clouds (and perhaps others ???) the cloudsheight here must be higher than the bottom of the cloud deck as given in those weather systems.  Yikes!
        //UPDATE: It's not that the cumulous cloud deck must be lower than the cloudsheight, just that it can't be too high in general.  Maybe less than 1200 meters?

        missionFile = Regex.Replace(missionFile, @"^\s*CloudsHeight\s*\d*\.?\d*\s*$", desiredCloudsHeightString, ro);//looks for a line with something like <spaces> XXXXXX <spaces> 34.234 .. Case irrelevant = replaces it

        int WeatherIndex = 1; //Can be 0=clear, 1 = light clouds, 2 = medium clouds
        if (random.NextDouble() > .96) WeatherIndex = 2;//rarely, make it medium clouds
        if (random.NextDouble() > .80) WeatherIndex = 0;//more commonly, make it clear
        string desiredWeatherIndexString = "  WeatherIndex " + WeatherIndex.ToString("F0");
        missionFile = Regex.Replace(missionFile, @"^\s*WeatherIndex\s*\d*\.?\d*\s*$", desiredWeatherIndexString, ro);//looks for a line with something like <spaces> XXXXX <spaces> 34.234 .. Case irrelevant = replaces it
        return missionFile;
    }

    //Bombers to be exchanged out in the .mis file.  The # is weight - how often to use that bomber relative to the others
    //Dictionary<string, int> RedBombers = new Dictionary<string, int>() { { "WellingtonMkIc", 20 }, { "BlenheimMkIV", 10 }, { "BlenheimMkIV_Late", 10 }, { "BlenheimMkI", 10 }, { "SunderlandMkI", 1 }, { "HurricaneMkI_FB", 2 } };
    //Dictionary<string, int> BlueBombers = new Dictionary<string, int>() { { "BR-20M", 10 }, { "He-111H-2", 10 }, { "He-111P-2", 10 }, { "Ju-87B-2", 10 }, { "Ju-88A-1", 1 }, { "Do-17Z-2", 10 } };

        
    //And it turns out we can only replace/changes bombers IF their weapons setup string exactly matches.  So the switchouts are NOT very exciting. Oh well.
    static Dictionary<string, int> RedBombers = new Dictionary<string, int>() { { "BlenheimMkIV", 10 }, { "BlenheimMkIV_Late", 10 } };
    static Dictionary<string, int> BlueBombers = new Dictionary<string, int>() { { "He-111H-2", 10 }, { "He-111P-2", 10 }};
    static Dictionary<string, int> BlueDO215_BR20 = new Dictionary<string, int>() { { "Do-215B-1", 10 }, { "BR-20M", 10 } }; //Both need to be WEAPONS 1 1 1 2 
    static Dictionary<string, int> BlueE4s = new Dictionary<string, int>() { { "Bf-109E-4N_Late", 1 }, { "Bf-109E-4N", 1 },
    { "Bf-109E-4_Late", 1 },
        { "Bf-109E-4", 4 },
        { "Bf-109E-3", 15 },
        { "Bf-109E-1", 30 } };

    

    static Dictionary<string, int> Blue110s = new Dictionary<string, int>() { { "Bf-110C-2", 10 }, { "Bf-110C-4", 10 },
    { "Bf-110C-4-NJG", 10 },
        { "Bf-110C-6", 5 },
        { "Bf-110C-4N", 8 },
    };

    static Dictionary<string, int> RedBlenheimFs = new Dictionary<string, int>() { { "BlenheimMkIF", 10 }, { "BlenheimMkINF", 10 },
    { "BlenheimMkIVF", 10 },
        { "BlenheimMkIVNF", 10 },
        { "BlenheimMkIVF_Late", 10 },
        { "BlenheimMkIVNF_Late", 10 } };
    
    static Dictionary<string, int> RedFighters = new Dictionary<string, int>() { { "HurricaneMkI_100oct-NF", 20 }, { "HurricaneMkI_100oct", 20 },
        { "HurricaneMkI", 15 },
        { "HurricaneMkI_dH5-20_100oct", 15 },
        { "HurricaneMkI_dH5-20", 10 },
        { "SpitfireMkIa_100oct", 10 },
        { "SpitfireMkIa", 15 },        
        { "SpitfireMkI", 10 },
        { "SpitfireMkI_100oct", 15 },
        { "SpitfireMkIIa", 5 },
    };
    

    List<Dictionary<string, int>> PlaneReplacementDictionarys = new List<Dictionary<string, int>>() { RedBombers, BlueBombers, BlueDO215_BR20, BlueE4s, Blue110s, RedBlenheimFs, RedFighters };   

    public string updatePlanesFromDictionaryMatch(string missionFile, Dictionary<string,string> replacements)
    {
        RegexOptions ro = RegexOptions.IgnoreCase | RegexOptions.Multiline;

        //var pattern = @"^\s*Class Aircraft\..?$";
        //var pattern = @"^\s*Class Aircraft\..*$";
        /*
        var pattern = @"  Class Aircraft.*";
        var stringVariableMatches = Regex.Replace(missionFile, pattern,
        m => replacements.ContainsKey(m.Value) ? replacements[m.Value] : m.Value, ro);
        */
        string newline = "\n";
        missionFile = missionFile.Replace("\r\n", "\n").Replace('\r', '\n'); //change all newlines to \n
        //missionFile = missionFile.Replace("HUNTING", "PUNTING");
        foreach (string key in replacements.Keys)
        {
            missionFile = missionFile.Replace(key + newline, replacements[key] + newline);
            Console.WriteLine("Replacing: {0} : {1}", key, replacements[key]);
        }

        return missionFile;
    }

    public Dictionary<string, string> makePlaneExchangeDictionary (Dictionary<string, int> dict, string prefix = "Class Aircraft." )
    {
        var ret = new Dictionary<string, string>();
        var chooseList = new List<string>();
        var chosenList = new HashSet<string>();

        //Build up the list to choose from. We weight it by the value given by simply adding that item to the list repeatedly
        foreach (string ap in dict.Keys)
        {
            chooseList.AddRange(Enumerable.Repeat(ap, dict[ap]));
        }
        foreach (string ap in dict.Keys) {

            //We want to avoid assigning the two different aircraft in the current .mis file to the same aircraft in the result .mis.  If we do that repeatedly pretty soon all bombers will all be the same.
            //So we make sure the assignmnent dictionary is unique in that same way.
            int count = 0;

            string choice = Calcs.randSTR(chooseList);
            while (chosenList.Contains(choice) && count < 2000) { choice = Calcs.randSTR(chooseList); count++; }
            chosenList.Add(choice);

            ret[prefix + ap] = prefix + choice;
            Console.WriteLine("D: " + prefix + ap + " : " + prefix + choice);
        }
        return ret;
    }

    public string updatePlanes(string missionFile)
    {
        //missionFile = updatePlanesFromDictionaryMatch(missionFile, makePlaneExchangeDictionary(RedBombers));
        //missionFile = updatePlanesFromDictionaryMatch(missionFile, makePlaneExchangeDictionary(BlueBombers));
        //missionFile = updatePlanesFromDictionaryMatch(missionFile, makePlaneExchangeDictionary(RedFighters));
        //missionFile = updatePlanesFromDictionaryMatch(missionFile, makePlaneExchangeDictionary(BlueFighters));

        foreach (var prd in PlaneReplacementDictionarys)
        {
            missionFile = updatePlanesFromDictionaryMatch(missionFile, makePlaneExchangeDictionary(prd));
        }
        return missionFile;
    }

    public string getSection(string missionFile, string pattern = @"\[AirGroups\].*\[Stationary\]")
    {
        RegexOptions ro = RegexOptions.IgnoreCase | RegexOptions.Singleline; //Singleline makes .* match EOL characters; ie the entire string is one single line, not broken up into many small lines

        var stringVariableMatches = Regex.Match(missionFile, pattern, ro);

        return stringVariableMatches.Value; //Note - returns first match found only.
    }
    public string replaceSection(string missionFile, string replacement, string pattern = @"\[AirGroups\].*\[Stationary\]")
    {
        RegexOptions ro = RegexOptions.IgnoreCase | RegexOptions.Singleline; //Singleline makes .* match EOL characters; ie the entire string is one single line, not broken up into many small lines

        var stringVariableMatches = Regex.Replace(missionFile, pattern, replacement, ro);

        return stringVariableMatches; //Note - returns first match found only.
    }


    public string getReplacementAirgroupAndTriggerFile(string fileID = "randsubmission", string subdir = "")
    {
        List<string> RandomMissions = GetFilenamesFromDirectory(CLOD_PATH + FILE_PATH + "/" + subdir, fileID); // Gets all files with with text MISSION_ID-fileID (like "M001-randsubmissionREDBOMBER") in the filename and ending with .mi
        string RandomMission = RandomMissions[random.Next(RandomMissions.Count)]; //chooses one of them randomly
        Console.WriteLine("Replacement Airgroup and Triggers: Using file " + RandomMission);
        string ret = null;
        if (File.Exists(RandomMission))
        {
            ret = File.ReadAllText(RandomMission);
        }
        return ret;
    }


    //Takes the airgroup & trigger/action sections from replacementfile (randomly chosen from .mis files like Tobruk_Campaign-airgroup-B.mis & plops them into missionfile
    //So . . . airgroup/trigger/action portions must be in files named something like "Tobruk_Campaign-airgroup-XXXX.mis".  Then the airgroups, actions, & triggers from those files will be put in
    //place of the same sectdions in the current .mis file.
    //
    //The weather files must be in a subdirectory /Weather/Tobruk_Campaign-randsubmission-weather-XXXXXX.mis"
    //Then anything between [WeatherFront] and [splines] in the main .mis file will be replaced by the same sections in the Tobruk_Campaign-randsubmission-weather-XXXXXX.mis file.
    //Note that main.mis MUST include [splines] but weather-XXXXX.mis should NOT include [splines]
    public string updateAirgroup_Trigger_WeatherFront_Sections(string missionFile)
    {
        string saveMissionFile = missionFile;
        try
        {            
            string replacementFile = getReplacementAirgroupAndTriggerFile(MISSION_ID + "-airgroup-");
            string weatherReplacementFile = getReplacementAirgroupAndTriggerFile(MISSION_ID + "-randsubmission-weather-", "Weather");

            string airgroupssec = @"\[AirGroups\].*\[Stationary\]";
            string triggerssec = @"\[Trigger\].*\[Birthplace\]";
            string replacementFile_airgroups = getSection(replacementFile, airgroupssec);
            string replacementFile_triggers = getSection(replacementFile, triggerssec);

            string weatherSUBMISSIONsec = @"\[WeatherFront\].*";
            string weatherMAINMISSIONsec = @"\[WeatherFront\].*\[splines\]";
            string replacementFile_weather = getSection(weatherReplacementFile, weatherSUBMISSIONsec) + Environment.NewLine + "[splines]";

            //TOBRUK - the aircraft replacements are causing problems due to new aircraft names
            //missionFile = replaceSection(missionFile, replacementFile_airgroups, airgroupssec);
            //missionFile = replaceSection(missionFile, replacementFile_triggers, triggerssec);
            missionFile = replaceSection(missionFile, replacementFile_weather, weatherMAINMISSIONsec);
            return missionFile;
        }
        catch (Exception ex)
        {
            Console.WriteLine("updateAirgroup_Trigger_WeatherFront_Sections ERROR: " + ex.Message);
            return saveMissionFile;
        };
    }


    //changes start time of mission
    //Also changes cloud deck height (500-1500m) and WeatherIndex (cloud type) - mostly light but occasionally medium or clear on 1/3 restarts
    //TODO . . . we could probably used built-in maddox.game.ISectionFile functions to edit & update the sectionfile.  get, set, delete, save, etc
    public void CheckAndChangeStartTimeAndWeather()
    {
        //rem out the following line to make it: testing, don't skip
        //if (ON_TESTSERVER  && !DISABLE_TESTING_MODS) return; //if running on test server, just keep time unchanged
        bool ret = true;
        double lastMissionCurrentTime_hr = 0;
        //MO_WriteMissionObject(GamePlay.gpTimeofDay(), "MissionCurrentTime", wait);
        object mo = MO_ReadMissionObject(lastMissionCurrentTime_hr, "MissionCurrentTime");
        if (mo != null) Console.WriteLine("Read " + mo.GetType().ToString());
        else Console.WriteLine("No read of " + "MissionCurrentTime");
        if (mo != null) ret = double.TryParse(mo.ToString(), out lastMissionCurrentTime_hr); //var d = double.TryParse(o.ToString(), out d); 
        else ret = false;

        double currTime = GamePlay.gpTimeofDay();
        double desiredStartTime_hrs = EARLIEST_MISSION_START_TIME_HRS;

        twcLogServer(null, String.Format("CheckStartTime: curr/desired start time: {0:F3} {1:F3} ", currTime, desiredStartTime_hrs));
        //if the last saved mission time is a long ways from the current mission time, AND there is still more than 5 hrs
        //left before the preferred end mission time, 
        //AND the last save mission time is later than the earliest allowed mission start time,
        //THEN we'll restart the mission at/near our last desired start time
        //Otherwise stick with EARLIEST_MISSION_START_TIME
        if (ret && Math.Abs(lastMissionCurrentTime_hr - currTime) < 30 && END_MISSION_TIME_HRS - lastMissionCurrentTime_hr > 5
            && lastMissionCurrentTime_hr >= EARLIEST_MISSION_START_TIME_HRS)
            desiredStartTime_hrs = lastMissionCurrentTime_hr;
        twcLogServer(null, String.Format("CheckStartTime: curr/desired start time: {0:F3} {1:F3} ", currTime, desiredStartTime_hrs));

        //So once in a while we restart the mission simply to change the weather, aircraft, etc.  This will change cloudsheight & weatherindex, AI aircraft types.
        //bool restartToChangeWeather = false;   
        //if (random.NextDouble() < 0.333) restartToChangeWeather = true;

        //rem out the following line to make it: testing, do it always
        //if (Math.Abs(desiredStartTime_hrs - currTime) < 0.5 && !restartToChangeWeather) return; //0.5 == 30 minutes, 1/2 hour

        string desiredString = "  TIME " + desiredStartTime_hrs.ToString("F5");

        //twcLogServer(null, String.Format("CheckStartTime: curr/desired start time: {0:F3} {1:F3}; Changing to {2}. Restart to change weather? {3}", currTime, desiredStartTime_hrs, desiredString, restartToChangeWeather));
        twcLogServer(null, String.Format("CheckStartTime: curr/desired start time: {0:F3} {1:F3}; Changing to {2}. ", currTime, desiredStartTime_hrs, desiredString));

        string filepath_mis = stb_FullPath + @"/" + MISSION_ID + ".mis";
        string filepath_mis_save = stb_FullPath + @"/" + MISSION_ID + ".mis_save";
        var backPath = STATSCS_FULL_PATH + CAMPAIGN_ID + @" campaign backups/";
        DateTime dt = DateTime.UtcNow;
        string filepath_misback_date = backPath + MISSION_ID + ".mis-" + dt.ToString("yyyy-MM-dd-HHmmss");

        try
        {
            Console.WriteLine("MO_Write MIS #1a " + filepath_mis + " " + filepath_mis_save);
            if (File.Exists(filepath_mis_save)) { File.Delete(filepath_mis_save); }
            File.Copy(filepath_mis, filepath_mis_save); //We could use File.Move here if we want to eliminate the previous .ini file before writing new data to it, thus creating an entirely new .ini.  But perhaps better to just delete specific sections as we do below.
            
        }
        catch (Exception ex) { Console.WriteLine("MO_Copy MIS Inner ERROR: " + ex.ToString()); return; }

        string missionFile = File.ReadAllText(filepath_mis);

        missionFile = updateTimeAndWeather(missionFile, desiredString);

        //TOBRUK skipping these bits for now.  The updatePlanes seems to cause problems due to new plane names interfering with some of the replacements.
        //missionFile = updateAirgroup_Trigger_WeatherFront_Sections(missionFile);

        //missionFile = updatePlanes(missionFile);
        //Console.WriteLine(missionFile);   

        //  TIME 4.50000011501834

        try
        {
            bool result = MO_WriteMissionObject(desiredStartTime_hrs, "MissionCurrentTime", true); //if we don't write this out here we get into a race condition!  This will set our expected time on restart, and that will match the actual running time, and everyone is happy

            if (!result) return; //if we can't write this file successfully we'll just get into a bad reboot loop, so best to just quit instead.

        }
        catch (Exception ex) { Console.WriteLine("MO_Move MIS currTime 1.5 ERROR: " + ex.ToString()); return; }

        try
        {
            if (File.Exists(filepath_misback_date)) { File.Delete(filepath_misback_date); } //shouldn't exist, but just in case
            File.Move(filepath_mis, filepath_misback_date); //Move currently active copy to the backups folder
            Console.WriteLine("MO_Write MIS #2a");
        }
        catch (Exception ex) { Console.WriteLine("MO_Move MIS Inner2 ERROR: " + ex.ToString()); return; }

        try
        {
            File.WriteAllText(filepath_mis, missionFile, Encoding.UTF8);
            Console.WriteLine("MO_Write MIS #3a");
        }
        catch (Exception ex)
        {
            Console.WriteLine("MO_Write MIS Inner3 ERROR: " + ex.ToString());
            try
            {
                if (File.Exists(filepath_mis)) { File.Delete(filepath_mis); }//We're assuming this is screwed up somehow, so delete it
                File.Copy(filepath_mis_save, filepath_mis); //Move back the copy we made
                Console.WriteLine("MO_Write MIS #3b");
            }
            catch (Exception ex1) { Console.WriteLine("MO_CheckAndChangeStartTime !!!!!!!!!!!!!!!!!!!!SERIOUS ERROR!!!!!!!!!!!!!!!!!!!!!!!!!!!! rewrite of .mis file failed and couldn't copy the backup to replace it!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! " + Environment.NewLine + ex1.ToString()); return; }
            return; //give up
        }
        //OK, new .mis file with new time is in place, now restart & run it!


        //TOBRUK:!!!!!! We are just re-writing the .mis file to change the time around, and possible weather. But we don't re-start, we just save it to use on next restart.
        /*

        //We are NOT saving any mission state here, we MUST only run this routine at the very beginning of the mission, before anything has happened.
        twcLogServer(null, "Restarting Mission to change start time of day . . . ", new object[] { });
        GamePlay.gpHUDLogCenter("Restarting Mission to change start time of day . . . ");
        DebugAndLog("Restarting Mission to change start time of day to " + desiredString);
        Console.WriteLine("Restarting Mission to change start time of day to " + desiredString);

        //OK, trying this for smoother exit (save stats etc)
        //(TWCStatsMission as AMission).OnBattleStoped();//This really horchs things up, basically things won't run after this.  So save until v-e-r-y last.
        //OK, we don't need to do the OnBattleStoped because it is called when you do CmdExec("exit") below.  And, if you run it 2X it actually causes problems the 2nd time.
        //Here we DON"T want a smooth exit saving everything.  Saving everything messes everything up. Just quit.
        */
        /*if (GamePlay is GameDef)
        {
            (GamePlay as GameDef).gameInterface.CmdExec("exit");
        }*/
        /*
        //Process.GetCurrentProcess().Kill();
        Thread.Sleep(2075); //allow messages to show up/be logged?
        //Environment.Exit(0);
        Process.GetCurrentProcess().Kill();
        System.Environment.Exit(1);
        */
    }
    //Ranges 0 to 1.  0= just started, 1=full mission time complete
    public double calcProportionTimeComplete()
    {
        //double tickSinceStarted = Time.tickCounter() - START_MISSION_TICK;
        double timeSinceStarted_hrs = GamePlay.gpTimeofDay() - START_MISSION_TIME_HRS;
        //double perc = tickSinceStarted / ((double)MISSION_LENGTH_HRS);
        double perc = timeSinceStarted_hrs / ((double)MISSION_LENGTH_HRS);


        if (perc < 0) perc = 0;
        if (perc > 1) perc = 1;
        return perc;
    }

    //returns true if there is enough time left (possibly after the adjustment)
    //false if NOT enough time left
    //If true & not enough time left, adjusts the end mission time to accommodate the extra time requested exactly.
    //TODO: Can use values for latest allowed time etc to figure out if we can do it or not
    //We have to change/adjust two things here: 
    // - time left in mission (MISSION_LENGTH_HRS)
    // - latest time mission is allowed to run (ie, sunset or whatever) (END_MISSION_TIME_HRS)
    public bool adjustTimeLeft(double timeNeeded_min=10, double cutoff_min = 70, bool force = false)
    {
        int timeLeft_min = calcTimeLeft_min();
        double extraTimeNeeded_min = timeNeeded_min - timeLeft_min;
        //END_MISSION_TIME_HRS

        double timeLeft_EMT_hr = END_MISSION_TIME_HRS - GamePlay.gpTimeofDay(); //End_Mission_Time is the last time of day allowed.
        double timeLeft_EMT_min = timeLeft_EMT_hr * 60.0;


        if (extraTimeNeeded_min <= 0 && timeNeeded_min <= timeLeft_EMT_min) return true;
        if ((extraTimeNeeded_min >= cutoff_min || timeNeeded_min > timeLeft_EMT_min ) && !force) return false;

        //Tick_Mission_Time =  - ;
        if (extraTimeNeeded_min > 0 ) MISSION_LENGTH_HRS = MISSION_LENGTH_HRS + extraTimeNeeded_min / 60.0; ; //2000 ticks/min - see note below

        //double timeLeft_EMT_hr = END_MISSION_TIME_HRS - GamePlay.gpTimeofDay();

        if (timeNeeded_min > timeLeft_EMT_min) END_MISSION_TIME_HRS = GamePlay.gpTimeofDay() + timeNeeded_min / 60.0;

        Console.WriteLine("Extended mission time left to {0:N0} from now, {1:N0} extra minutes", timeNeeded_min, extraTimeNeeded_min);
        return true;
    }

    //Calcs minutes left as an int
    public int calcTimeLeft_min()
    {

        double Mission_Timeleft_hrs = MISSION_LENGTH_HRS - (GamePlay.gpTimeofDay() - START_MISSION_TIME_HRS);
        double Mission_Timeleft_min = Mission_Timeleft_hrs * 60;
        //var Mission_Time_TF = Time.TicksToSecs(Tick_Mission_Time)/60;

        //Console.WriteLine("tick/sec" + Time.SecsToTicks(1) + " /2000 method: {0:N2} TF method: {1:N2}", Mission_Time, Mission_Time_TF);
        //So it appears that the server always SHOOTS FOR 33 tick/sec or 2000 ticks/min.  But, if things are slow etc sometimes it doesn't quite meet that.
        //If y ou use the Time.TicksToSecs it will return the aCTUAL CURRENT VALUE of ticks/sec, which usually is NOT what you want.  If the server happens to be in the middle of slowdown it will suddentlyi switch 
        //from 33 to 23 to 16 to 6 or whatever.  So any calculations you do with it will be WACKY.
        //We need to switch all this to just just normal time instead of ticks.  IN the meanwhile, use constant value 2000 ticks/minute or 33.33 ticks/second.  ///DONE 2020/09/26

        TimeSpan Mission_Timeleft_ts = TimeSpan.FromMinutes(Mission_Timeleft_min);
        //string Time_Remaining = string.Format("{0:D2}:{1:D2}:{2:D2}", Convert_Ticks_min.Hours, Convert_Ticks_min.Minutes, Convert_Ticks_min.Seconds);

        //Method #2 - if our last allowed time in the evening is earlier than this, then we go with that instead
        double timeLeft_tilsunset_hrs = END_MISSION_TIME_HRS - GamePlay.gpTimeofDay();
        TimeSpan timeLeft_tilsunset_ts = TimeSpan.FromHours(timeLeft_tilsunset_hrs);

        if (timeLeft_tilsunset_ts.CompareTo(Mission_Timeleft_ts) <= 0) return Convert.ToInt32(timeLeft_tilsunset_ts.TotalMinutes);  //whichever happens **soonest** we return
        else return Convert.ToInt32(Mission_Timeleft_ts.TotalMinutes);
    }

    //Calcs minutes left & returns it as a string
    public string calcTimeLeft()
    {

        int timeLeft_min = calcTimeLeft_min();
        TimeSpan timeLeft_ts = TimeSpan.FromMinutes(timeLeft_min);
        string Time_Remaining_hours_str = string.Format("{0:D2}hr {1:D2}min    ", timeLeft_ts.Hours, timeLeft_ts.Minutes);

        return Time_Remaining_hours_str;
    }



    public int month = -1;
    public int day = -1;

    //Displays time left to player & also returns the time left message as a string & DateTime
    //Calling with (null, false) will just return the message rather than displaying it
    public Tuple<string, DateTime> showTimeLeft(Player player = null, bool showMessage = true)
    {
        if (month == -1) month = random.Next(7, 10);
        if (day == -1) day = random.Next(10, 30);

        TimeSpan diff_ts = DateTime.UtcNow - MODERN_CAMPAIGN_START_DATE;
        int diff_days = diff_ts.Days;
        diff_days = Math.Abs(diff_days % HISTORIC_CAMPAIGN_LENGTH_DAYS);  //After the # of days in the historic campaign has elapsed, we roll over & restart with day 0.  Thus, we always have a historic 
                                                                          //date within the range of the actual historic campaign
                                                                          //% can be negative, so Abs() of result needed.  ie -5 % 4 = -1
        DateTime inGameTime_dt = HISTORIC_CAMPAIGN_START_DATE.AddDays(diff_days);

        string missiontimeleft = calcTimeLeft();
        //double inGameTime = GameWorld.ITime.current();

        //int igt_hour =Convert.ToInt32( Math.Floor(inGameTime));

        //int igt_minute = Convert.ToInt32(Math.Floor((double)(60.0 * (inGameTime - igt_hour))));
        //double igt_minute = (double)(60.0 * inGameTime - igt_hour);
        double inGameTime_hours = GamePlay.gpTimeofDay();

        inGameTime_dt = inGameTime_dt.AddHours(inGameTime_hours);

        //DateTime inGameTime_dt = new DateTime(1940, month, day, igt_hour, igt_minute, 0);

        //string msg = "It's currently " + inGameTime_dt.ToString ("d'.'MM'.'yy', 'HHmm' hours'.") + " Time left in mission " + MISSION_ID + ": " + missiontimeleft;

        string msg = "It's currently " + inGameTime_dt.ToString("d' 'MMMM' 'yyyy', 'HHmm' hours'.") + " Time remaining until end of operations: " + missiontimeleft;

        /*
         *        
        if (!MISSION_STARTED) msg = "Mission " + MISSION_ID + " not yet started - waiting for first player to enter.";
        else if (COOP_START_MODE) msg = "Mission " + MISSION_ID + " not yet started - waiting for Co-op Start.";
        */

        if (showMessage && player != null) twcLogServer(new Player[] { player }, msg, new object[] { });
        return new Tuple<string, DateTime>(msg, inGameTime_dt);
    }

    public void gpToArmyLogServer(int army, string msg, object[] parms)
    {   // Purpose: Send specified chat message to all players in specified army.
        // Use: GamePlay.sendChatMessageTo(); 
        //Source: Salmo, https://theairtacticalassaultgroup.com/forum/showthread.php?t=23542&highlight=salmo+extension
        List<Player> Players = new List<Player>();
        // on Dedi the server:
        if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army || army == -1)
                Players.Add(GamePlay.gpPlayer());
        } //rest of the crowd
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            foreach (Player p in GamePlay.gpRemotePlayers())
            {
                if (p.Army() == army || army == -1)
                    Players.Add(p);
            }
        }
        if (Players != null && Players.Count > 0)
            GamePlay.gpLogServer(Players.ToArray(), msg, parms);
    }

    public Player[] AllPlayersInArmyArray(int army)
    {   // Purpose: Get full list of players in army, to (for example) send specified chat message to all players in specified army.

        List<Player> Players = new List<Player>();
        // on Dedi the server:
        if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army || army == -1)
                Players.Add(GamePlay.gpPlayer());
        } //rest of the crowd
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            foreach (Player p in GamePlay.gpRemotePlayers())
            {
                if (p.Army() == army || army == -1)
                    Players.Add(p);
            }
        }
        return Players.ToArray();
    }




    public void logToFile(object data, string messageLogPath)
    {
        try
        {
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX3 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
            FileInfo fi = new FileInfo(messageLogPath);
            StreamWriter sw;
            if (fi.Exists) { sw = new StreamWriter(messageLogPath, true, System.Text.Encoding.UTF8); }
            else { sw = new StreamWriter(messageLogPath, false, System.Text.Encoding.UTF8); }
            sw.WriteLine((string)data);
            sw.Flush();
            sw.Close();
        }
        catch (Exception ex) { Console.WriteLine(ex.Message); };
    }

    public void logMessage(object data)
    {
        Task.Run(() => logToFile(data, MESSAGE_FULL_PATH));
        //logToFile(data, MESSAGE_FULL_PATH);
    }

    public void logStats(object data)
    {
        //logToFile(data, STATS_FULL_PATH);
        Task.Run(() => logToFile(data, STATS_FULL_PATH));

    }

    public void DebugAndLog(object data)
    {
        if (DEBUG) twcLogServer(null, (string)data, new object[] { });
        if (!DEBUG && LOG) Console.WriteLine((string)data); //We're using the regular logs.txt as the logfile now logToFile (data, LOG_FULL_PATH); 
    }
    public void gpLogServerAndLog(Player[] to, object data, object[] third)
    {
        //this is already logged to logs.txt so no need for this: if (LOG) logToFile (data, LOG_FULL_PATH);
        twcLogServer(to, (string)data, third);

    }

    public Int64 lastGpLogServerMsg_tick = 0;
    public Int64 GpLogServerMsgDelay_tick = 1000000; //1 mill ticks or 0.1 second
    public Int64 GpLogServerMsgOffset_tick = 500000; //Different modules or submissions can use a different offset to preclude sending gplogservermessages @ the same moment; 500K ticks or 0.05 second    


    //Should replace ALL twcLogServer usage with twcLogServer instead to avoid line overflow etc.
    //wrapper for twcLogServer so that we can do things to it, like log it, suppress all output, delay successive messages etc.
    public void twcLogServer(Player[] to, object data, object[] third = null)
    {
        //this is already logged to logs.txt so no need for this: if (LOG) logToFile (data, LOG_FULL_PATH);
        //gpLogServerWithDelay(to, (string)data, third);

        //gplogserver chokes on long chat messages, so we will break them up into chunks . . . 
        string str = (string)data;
        int maxChunkSize = 200;

        IEnumerable<string> lines = Calcs.SplitToLines(str, maxChunkSize);
        //for (int i = 0; i < str.Length; i += maxChunkSize)
        //for (int i=0; i<lines.GetLength(); i++) gpLogServerWithDelay(to, lines[i], third);
        double delay = 0.01;
        //foreach (string line in lines) gpLogServerWithDelay(to, line, third);
        foreach (string line in lines)
        {
            Timeout(delay, () =>
           {
               GamePlay.gpLogServer(to, line, third);
           });
            delay += 0.01;
        }


    }
    //This is designed to space out gplogserver calls, as (say) 5-10 of these in a row will cause a very noticeable stutter
    //It's sort of a stack for gplogserver messages
    public void gpLogServerWithDelay(Player[] to, object data, object[] third = null)
    {
        //defined above:
        //public Int64 lastGpLogServerMsg_tick = 0;
        //public Int64 GpLogServerMsgDelay_tick = 1000000; //1 mill ticks or 0.1 second
        //public Int64 GpLogServerMsgOffset_tick = 500000; //Different modules or submissions can use a different offset to preclude sending gplogservermessages @ the same moment; 500K ticks or 0.05 second
        DateTime currentDate = DateTime.UtcNow;
        //currentDate.Ticks
        Int64 nextMsg_tick = Math.Max(currentDate.Ticks, lastGpLogServerMsg_tick + GpLogServerMsgDelay_tick);
        Int64 remainder;
        Int64 roundTo = 500000; //round nextMsg_tick UP to the next 1/10 second.  This is to allow different missions/modules to output at different portions of the 0.1 second interval, with the objective of avoiding stutters when messages from different .mis files or modules pile up
        nextMsg_tick = (Math.DivRem(nextMsg_tick - 1, roundTo, out remainder) + 1) * roundTo; // -1 handles the specific but common situation where we want a 0.1 sec delay but it always rounds it up to 0.2 sec.  This makes it round up for anything greater than roundTo, rather than greater than OR EQUAL TO roundTo.
        double nextMsgDelay_sec = (double)(nextMsg_tick - currentDate.Ticks) / 10000000;
        //string msg = (string)data + "(Delayed: " + nextMsgDelay_sec.ToString("0.00") + ")"; //for testing
        string msg = (string)data;
        //twcLogServer(null, nextMsg_tick.ToString() + " " + nextMsgDelay_sec.ToString("0.00"), null); //for debugging
        Timeout(nextMsgDelay_sec, () => { twcLogServer(to, msg, third); });
        lastGpLogServerMsg_tick = nextMsg_tick; //Save the time_tick that this message will be displayed; next message will be at least GpLogServerMsgDelay_tick after this

    }

    //Save all actors - air & ground - that come in.
    //Note that some actors don't come through this routine!  Like trailers or loads of ground vehicles, maybe some aircraft if their callsign is higher than 50 or some other unknown reasons?
    //https://theairtacticalassaultgroup.com/forum/archive/index.php/t-24127.html
    //
    public HashSet<string> AllActorsName = new HashSet<string>();
    public Dictionary<string, AiActor> AllActorsDict = new Dictionary<string, AiActor>();
    public Dictionary<string, AiActor> AllAircraftDict = new Dictionary<string, AiActor>();
    public Dictionary<string, AiActor> AllGroundDict = new Dictionary<string, AiActor>();

    //Aargh, little kludge to allow sub-class to access Calcs.GetActorsByNameMatch.  Arrgh.
    public List<AiActor> GetActorsByNameMatch(string name = "", int matcharmy = 0, string type = "", bool onlyArtilleryAndVehicles = false)
    {
        try { 
            return Calcs.GetActorsByNameMatch(GamePlay, this, AllActorsDict, name, matcharmy, type, onlyArtilleryAndVehicles: onlyArtilleryAndVehicles);
        } catch (Exception ex) { Console.WriteLine("main.GetActorsByNameMatch ERROR: " + ex.ToString());
            return new List<AiActor>() { };
        }
    }


    /*****************************************************
     * ONACTORCREATED
     * ***************************************************/

    //Kill off AI aircraft after a pre-set length of time.  Stops AI aircraft from hanging around too long after they have
    //crashlanded, landed in the water, wandered off the map, etc
    //You can CHANGE the amount of time here depending on the type of AI aircraft you plan to use in your missions
    //Reason for this is #1. CloD tends to leave a/c hanging around for a long time after they really should be gone (crashed, landed, off map, whatever)
    //#2. AI aircraft tend to become useless after a certain amount of time anyway, they will just fly straight, be completely unresponsive, etc
    //#3. You should use a variety of strategies to eliminate AI aircraft when their useful life is done (check when they are crashed and de-spawn, fly them off the 
    //map at the end of their mission and then de-spawn them, etc) but this is sort of a last resort if all other methods fail

    public override void OnActorCreated(int missionNumber, string shortName, AiActor actor)
    {
        //base.OnActorCreated(missionNumber, shortName, actor);       
        
        AiAircraft a = actor as AiAircraft;        
        AiGroundActor g = actor as AiGroundActor;

        try
        {
            bool add = true;
            string ID = actor.Name();

            if (AllActorsName.Contains(ID) && AllActorsDict[ID] == actor) add = false;

            if (!AllActorsName.Contains(ID)) AllActorsName.Add(ID);
            else
            {
                if (add)
                {
                    for (int i = 1; i <= 1500; i++)
                    {
                        if (!AllActorsName.Contains(ID + i.ToString()))
                        {
                            ID = ID + i.ToString();

                            break;
                        }
                        if (i == 1500) ID = ID + random.Next(10000, 100000000).ToString(); //failsafe
                    }
                    AllActorsName.Add(ID);
                    //Console.WriteLine("OnActorCreated: New actor {0} {1} {2} {3} {4}", new object[] { ID, actor.Pos().x, actor.Pos().y, actor.Army(), actor.Tag});
                    //so, it's creating like 74 actors with name 'NONAME'.  No idea why ...
                }
            }
            if (add)
            {
                //Console.WriteLine("OnActorCreated: New actor " + shortName + " " + actor.Name() + " " + ID);
                //Console.WriteLine("0");
                AllActorsDict.Add(ID, actor);
                //Console.WriteLine("1");
                //AI Aircraft will be destroyed after airspawn minutes (set above)
                //lesson learned: For some reason if the Callsign of a group is high (higher than 50 or so?) then that object is not sent through this routine.  ??!!
                //eg, 12, 22, 32, 45 all work, but not 91 or 88.  They just never come
                //to OnActorCreated at all . . . But they are in fact created

                //Console.WriteLine("2");

                if (a != null) AllAircraftDict.Add(ID, actor);

                if (g != null) AllGroundDict.Add(ID, actor);

                if (!actor.Name().Contains("Static")) for (int i = 1; i < 11; i++)
                    {
                        //Console.WriteLine("3");
                        string name = actor.Name() + i.ToString();
                        //Console.WriteLine("4");
                        AiActor temp = GamePlay.gpActorByName(name);
                        //Console.WriteLine("5");
                        if (temp != null)
                        {
                            //Console.WriteLine("6");
                            if (!AllActorsDict.ContainsKey(ID))
                            {
                                AllActorsDict.Add(ID, temp);
                                //Console.WriteLine("OnActorCreated: New sub-actor " + temp.Name());
                            }
                            //Console.WriteLine("7");
                            if (temp as AiAircraft != null && !AllAircraftDict.ContainsKey(ID)) AllAircraftDict.Add(ID, temp);
                            //Console.WriteLine("8");
                            if (temp as AiGroundActor != null && !AllGroundDict.ContainsKey(ID)) AllGroundDict.Add(ID, temp);

                        }

                        //Console.WriteLine("9");

                    }
            }
        }
        catch (Exception ex) { Console.WriteLine("ERROR OnActorCreated save! " + ex.ToString()); }


        //Console.WriteLine("3");
        int destroyminutes = 180;//Destroy AI a/c this many minutes after they are spawned in.
        //Note that MoveBombTarget-.cs takes care of destroying aircraft when their task is set to "LANDING" and no live players
        //are nearby.  Plus, a/c are destroyed when they fly off the map & MoveBombTarget-.cs will make them do that at 
        //the end of any planned WAYPOINTS they have been given.
        //So this 120 min. destruction thing here is a bit of a safety valve in case random a/c are still hanging about after all the above failed.
        //a/c in the server too long tend to be useless, out of fuel, etc plus slow the server down.  Sometimes they are actually downed but still just sitting 
        //on the ground or whatever


        Timeout(1.0, () => // wait 1 second for human to load into plane
        {
            /* if (DEBUG) twcLogServer(null, "DEBUGC: Airgroup: " + a.AirGroup() + " " 

              + a.Type() + " " 
              + a.TypedName() + " " 
              +  a.AirGroup().ID(), new object[] { });
            */
            if (a == null) return;
            bool iACP = isAiControlledPlane2(a);  //Both #1. IS airplane, #2 is AI controlled
            if (!iACP)
            {
                //Timeout(35.232, () => { skincheckmission.DeleteLargeSkinFiles(); });

                //Timeout(600.732, () => { skincheckmission.DeleteLargeSkinFiles(); });
                //Timeout(1800.732, () => { skincheckmission.DeleteLargeSkinFiles(); });
                if (a as AiAircraft == null) return;
                string type = Calcs.GetAircraftType(a as AiAircraft);
                if (type.Contains("110") || type.Contains("Ju-87"))
                {
                    Player[] ps = playersInPlane(a as AiAircraft).ToArray();
                    Timeout(1.732, () => { twcLogServer(ps, "JU-87 & 110 PILOTS: Use Tab-4-4-8 or chat command <ai to let AI take over your second position.");
                        //Console.WriteLine("Use Tab-4-4-8 or chat command <ai to let AI take over your second position.");
                    });
                }
            }

            else //AI controlled aircraft
            {


                int ot = (destroyminutes) * 60 - 10; //de-spawns 10 seconds before new sub-mission spawns in.
                                                     //int brk=(int)Math.Round(19/20);


                /* if (DEBUG) twcLogServer(null, "DEBUGD: Airgroup: " + a.AirGroup() + " " 

                  + a.Type() + " " 
                  + a.TypedName() + " " 
                  +  a.AirGroup().ID() + " timeout: " + ot, new object[] { });
                */

                Timeout(ot - 60, () =>  //message 60 seconds before de-spawning.
                {
                    if (actor != null && isAiControlledPlane2(actor as AiAircraft))
                    {
                        //GamePlay.gpHUDLogCenter("(Some) Old AI Aircraft de-spawning in 60 seconds");
                    }

                }
                );

                Timeout(ot - 5, () =>
                {
                    if (actor != null && isAiControlledPlane2(actor as AiAircraft))
                    {
                        //GamePlay.gpHUDLogCenter("(Some) Old AI Aircraft de-spawning now!");  
                    }
                }
                              );

                //Timeout(75, () =>  //75 sec - 1.5 minutes for testing
                Timeout(ot, () =>  //960 sec - 16 minutes for real use
                {
                    Console.WriteLine("DEBUG: Removing old spawned-in aircraft: " + a.AirGroup() + " "
                        + a.Type() + " "
                        + a.TypedName() + " "
                        + a.AirGroup().ID() + " timeout: " + ot);
                    if (actor != null && isAiControlledPlane2(actor as AiAircraft))
                    { (actor as AiAircraft).Destroy(); }
                }
                );
            }
        });




    }

    /*****************************************************
     * END - ONACTORCREATED
     * ***************************************************/


    #region 
    //Returns whether aircraft is an Ai plane (no humans in any seats)
    //And to be true, MUST be an aircraft, not any other type of actor
    public bool isAiControlledPlane2(AiAircraft aircraft)

    { // returns true if specified aircraft is AI controlled with no humans aboard, otherwise false
        if (aircraft == null) return false;
        //check if a player is in any of the "places"
        for (int i = 0; i < aircraft.Places(); i++)
        {
            if (aircraft.Player(i) != null) return false;
        }
        return true;
    }
    #endregion

    public HashSet<Player> playersInPlane(AiAircraft aircraft)

    { // returns list of players in the aircraft (unique list - no duplicates)
        HashSet<Player> players = new HashSet<Player>();
        if (aircraft == null) return players;

        //check if a player is in any of the "places"
        for (int i = 0; i < aircraft.Places(); i++)
        {
            if (aircraft.Player(i) != null) players.Add(aircraft.Player(i));
        }
        return players;
    }

    public void letAiTake2ndPosition(Player player)
    {
        if (player == null || player.Place() == null) return;
        //Console.WriteLine("lAT2P: {0} {1}", player.PlaceSecondary(), player.PlacePrimary());
        //Console.WriteLine("lAT2P: {0} {1} {2} ", player.PersonPrimary().Place(), player.PlaceSecondary(), player.PlacePrimary());
        //Console.WriteLine("lAT2P: {0} {1} {2} {3}", player.PersonSecondary().Place(), player.PersonPrimary().Place(), player.PlaceSecondary(), player.PlacePrimary());
        //Console.WriteLine("lAT2P: {0} {1} {2} {3}", player.PersonSecondary().Place(), player.PersonPrimary().Place(), player.PlaceSecondary(), player.PlacePrimary());
        //whichever place they are NOT currently in, remove them from
        //if (player.PersonSecondary() != null && player.Place() != (player.PersonSecondary()).Place()) player.PlaceLeave((player.PersonSecondary()).Place());
        //else if (player.PersonPrimary() != null && player.Place() != (player.PersonPrimary()).Place()) player.PlaceLeave((player.PersonPrimary()).Place());

        //Ok, that didn't work.  Just leave them in the pilot's seat always.
        //if ((player.Place() as AiCart).Player(0) == player) player.PlaceEnter(player.Place(), 1); //This should ensure they are in the pilot's seat as primary, not the gunner as primary.  Maybe, I hope?
        //However, if someone else is in the pilot's place it won't kick that person out & replace them with this player
        //As long as there is only one player in the aircraft, I **believe** that placeprimary is always the pilot seat.  Placesecondary is whatever other 
        //seat they might be in.  So leaving PlaceSecondary will empty out the second position (gunner or bombadier or whatever) and leave the player in the pilot
        //seat only.  AI will take over the functions of the other seat.
        //Now, you don't want to do this in reverse--remove player from PlacePrimary & leave them in PlaceSecondary.
        //Reason is, now AI will take over the pilot's seat and fly the aircraft. Not what we want!
        //What happens with more than one player in the aircraft, I can't really say for certain.
        player.PlaceLeave(player.PlaceSecondary()); //Now they're kicked from the secondary, which  should leave them in the pilot's seat.
        twcLogServer(new Player[] { player }, "AI has taken over your gunner position.", null);


    }



    //Removes AIAircraft if they are off the map. Convenient way to get rid of
    //old a/c - just send them off the map
    //This is called via Task.Run so don't need to implement that here.
    public void RemoveOffMapAIAircraft()
    {
        int numremoved = 0;
        //The map parameters - if an ai a/c goes outside of these, it will be de-spawned.  You need to just figure these out based on the map you are using.  Set up some airgroups in yoru mission file along the n, s, e & w boundaries of the map & note where the waypoints are.
        //This should match the values in your .mis file, like
        //BattleArea 10000 10000 360000 310000 10000
        //UPDATE TOBRUK!!!!! 10000 10000 370000 370000 10000
        //TODO: There is probably some way to access the size of the battle area programmatically
        //The size below is expanded just slightly from that, as the map shown to players and on the radar map is just slightly larger.
        //Also below a "grace area" of approx 1 square off the map is added
        if (GamePlay == null) return;
        double minX = 6666;
        double minY = 6666;
        double maxX = 362000;
        double maxY = 362000;
        //////////////Comment this out as we don`t have Your Debug mode  
        //DebugAndLog("Checking for AI Aircraft off map OR stopped on ground, to despawn");
        if (GamePlay != null && GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
        {
            foreach (int army in GamePlay.gpArmies())
            {
                if (GamePlay.gpAirGroups(army) != null && GamePlay.gpAirGroups(army).Length > 0)
                    foreach (AiAirGroup airGroup in GamePlay.gpAirGroups(army))
                    {
                        if (airGroup != null && airGroup.GetItems() != null && airGroup.GetItems().Length > 0)
                        {
                            //if (DEBUG) DebugAndLog ("DEBUG: Army, # in airgroup:" + army.ToString() + " " + airGroup.GetItems().Length.ToString());            
                            if (airGroup.GetItems().Length > 0) foreach (AiActor actor in airGroup.GetItems())
                                {
                                    if (actor != null && actor is AiAircraft)
                                    {
                                        AiAircraft a = actor as AiAircraft;
                                        /* if (DEBUG) DebugAndLog ("DEBUG: Checking for off map: " + Calcs.GetAircraftType (a) + " "                                            
                                           //+ a.Type() + " " 
                                           //+ a.TypedName() + " " 
                                           +  a.AirGroup().ID() + " Pos: " + a.Pos().x.ToString("F0") + "," + a.Pos().y.ToString("F0")
                                          );
                                        */

                                        //for testing
                                        //string name = actor.Name();
                                        //if (actor.Army() == 1 && !name.Contains("gb01") && isAiControlledPlane2(a)) a.Destroy();
                                        //for testing


                                        if (a != null && isAiControlledPlane2(a)) {

                                            double Z_AltitudeAGL = a.getParameter(part.ParameterTypes.Z_AltitudeAGL, 0);
                                            double Z_VelocityTAS = a.getParameter(part.ParameterTypes.Z_VelocityTAS, 0);
                                            AiAirGroupTask aagt = airGroup.getTask();

                                            //so, lots of ai aircraft velicity is negative.  For some reason.  So if checking for stopped, must make it ==0 or maybe >-5 <5 or whatever
                                            /*if (Z_VelocityTAS < 0) 
                                                Console.WriteLine("DEBUG: Off Map or landed/Checking: " + Calcs.GetAircraftType(a) + " "                                                    
                                                    + a.Type() + " "
                                                    + a.TypedName() + " "
                                                    + a.AirGroup().ID() + " Pos: " + a.Pos().x.ToString("F0") + "," + a.Pos().y.ToString("F0") + " {0:N0} {1:N0} {2} ",
                                                    Z_AltitudeAGL, Z_VelocityTAS, aagt
                                                   );
                                                   */

                                            if
                                          (
                                            (Z_AltitudeAGL < 5 && Z_VelocityTAS < 10 && Z_VelocityTAS > -1 && aagt != AiAirGroupTask.TAKEOFF) ||  //is stopped on ground //not sure why we get negative velocity sometimes?  AND not landing
                                            a.Pos().x <= minX - 12500 ||  //Same as players, 12500 'grace area', this is set in statsmission Stb_RemoveOffMapPlayers()
                                            a.Pos().x >= maxX + 12500 ||
                                            a.Pos().y <= minY - 12500 ||
                                            a.Pos().y >= maxY + 12500
                                          )
                                            // ai aircraft only
                                            {
                                                Console.WriteLine("DEBUG: Off Map or landed/Destroying: " + Calcs.GetAircraftType(a) + " "
                                                + a.Type() + " "
                                                + a.TypedName() + " "
                                                + a.AirGroup().ID() + " Pos: " + a.Pos().x.ToString("F0") + "," + a.Pos().y.ToString("F0") + " {0:N0} {1:N0} {2} ",
                                                Z_AltitudeAGL, Z_VelocityTAS, aagt
                                               ); 
                                                numremoved++;
                                                Timeout(numremoved * 10, () => { a.Destroy(); }); //Destroy the a/c, but space it out a bit so there is no giant stutter 

                                            }
                                        }


                                    }
                                }


                        }
                    }

            }
        }
        // if (DEBUG && numremoved >= 1) DebugAndLog (numremoved.ToString() + " AI Aircraft were off the map and de-spawned");
    } //method removeoffmapaiaircraft


    //Put a player into a certain place of a certain plane.
    private bool putPlayerIntoAircraftPosition(Player player, AiActor actor, int place)
    {
        if (player != null && actor != null && (actor as AiAircraft != null))
        {
            AiAircraft aircraft = actor as AiAircraft;
            player.PlaceEnter(aircraft, place);
            return true;
        }
        return false;
    }

    private void Stb_DestroyPlaneUnsafe(AiAircraft aircraft)
    {
        try
        {
            if (aircraft != null)
            {
                //Console.WriteLine("Destroying aircraft -stats.cs DPU");
                aircraft.Destroy();
            }
        }
        catch (Exception ex) { Console.WriteLine(ex.ToString()); }
    }

    private void Stb_RemovePlayerFromCart(AiCart cart, Player player = null) //removes a certain player from any aircraft, artillery, vehicle, ship, or whatever actor/cart the player is in.  Removes from ALL places.
                                                                             //if player = null then remove ALL players from ALL positions
    {
        try
        {

            if (cart == null)
                return;

            //check if the player is in any of the "places" - if so remove
            for (int i = 0; i < cart.Places(); i++)
            {
                if (cart.Player(i) == null) continue;
                if (player != null)
                {
                    if (cart.Player(i).Name() == player.Name()) player.PlaceLeave(i); //we tell if they are the same player by their username.  Not sure if there is a better way.
                }
                else
                {
                    cart.Player(i).PlaceLeave(i);
                }
            }

        }
        catch (Exception ex) { Console.WriteLine(ex.ToString()); }
    }
    //First removes the player from the aircraft (after 1 second), ALL POSITIONS, then removes any other players from the aircraft, then destroys the aircraft itself (IF it is AI controlled), after 3 more seconds
    private void Stb_RemoveAllPlayersFromAircraftandDestroy(AiAircraft aircraft, Player player, double timeToRemove_sec = 1.0, double timetoDestroy_sec = 3.0)
    {
        Timeout(timeToRemove_sec, () =>
        {

            //player.PlaceLeave(0);
            Stb_RemovePlayerFromCart(aircraft as AiCart, player); //remove the primary player
            Stb_RemoveAllPlayersFromAircraft(aircraft, 0); //remove any other players
            Timeout(timetoDestroy_sec, () =>
        {
            if (isAiControlledPlane(aircraft)) Stb_DestroyPlaneUnsafe(aircraft);  //destroy if AI controlled, which SHOULD be the case all of the time now
        }); //Destroy it a bit later
        });
    }

    //Removes ALL players from an a/c after a specified period of time (seconds)
    private void Stb_RemoveAllPlayersFromAircraft(AiAircraft aircraft, double timeToRemove_sec = 1.0)
    {
        Timeout(timeToRemove_sec, () =>
        {

            //player.PlaceLeave(0);

            for (int place = 0; place < aircraft.Places(); place++)
            {
                if (aircraft.Player(place) != null)
                {
                    //Stb_RemovePlayerFromCart(aircraft as AiCart, aircraft.Player(place));
                    Stb_RemovePlayerFromCart(aircraft as AiCart); //BEC. we're removing ALL players from this a/c we don't care about matching by name.  This can cause problems if the player is ie in a bomber in two different places, so better just to remove ALL no matter what.
                }
            }

        });
    }
    //returns distance to nearest friendly airport to actor, in meters. Count all friendly airports, alive or not.
    //Includes airports AND spawnpoints
    private double Stb_distanceToNearestAirport(AiActor actor)
    {
        double d2 = 10000000000000000; //we compare distanceSQUARED so this must be the square of some super-large distance in meters && we'll return anything closer than this.  Also if we don't find anything we return the sqrt of this number, which we would like to be a large number to show there is nothing nearby.  If say d2 = 1000000 then sqrt (d2) = 1000 meters which probably not too helpful.
        if (GamePlay == null ) return d2;
        double d2Min = d2;
        if (actor == null) return d2Min;
        Point3d pd = actor.Pos();
        int n = GamePlay.gpAirports().Length;
        //AiActor[] aMinSaves = new AiActor[n + 1];
        //int j = 0;
        //twcLogServer(null, "Checking distance to nearest airport", new object[] { });
        for (int i = 0; i < n; i++)
        {
            AiActor a = (AiActor)GamePlay.gpAirports()[i];
            if (a == null) continue;
            //if (actor.Army() != a.Army()) continue; //only count friendly airports
            //if (actor.Army() != (a.Pos().x, a.Pos().y)
            //OK, so the a.Army() thing doesn't seem to be working, so we are going to try just checking whether or not it is on the territory of the Army the actor belongs to.  For some reason, airports always (or almost always?) list the army = 0.

            //twcLogServer(null, "Checking airport " + a.Name() + " " + GamePlay.gpFrontArmy(a.Pos().x, a.Pos().y) + " " + a.Pos().x.ToString ("N0") + " " + a.Pos().y.ToString ("N0") , new object[] { });

            if (GamePlay.gpFrontArmy(a.Pos().x, a.Pos().y) != actor.Army()) continue;


            //if (!a.IsAlive()) continue;


            Point3d pp;
            pp = a.Pos();
            pd.z = pp.z;
            d2 = pd.distanceSquared(ref pp);
            if (d2 < d2Min)
            {
                d2Min = d2;
                //twcLogServer(null, "Checking airport / added to short list" + a.Name() + " army: " + a.Army().ToString(), new object[] { });
            }

        }

        foreach (AiBirthPlace a in GamePlay.gpBirthPlaces())
        {
            if (a.Army() != actor.Army()) continue;


            //if (!a.IsAlive()) continue;


            Point3d pp;
            pp = a.Pos();
            pd.z = pp.z;
            d2 = pd.distanceSquared(ref pp);
            if (d2 < d2Min)
            {
                d2Min = d2;
                //twcLogServer(null, "Checking airport / added to short list" + a.Name() + " army: " + a.Army().ToString() + " distance " + d2.ToString("n0"), new object[] { });
            }

        }
        //twcLogServer(null, "Distance:" + Math.Sqrt(d2Min).ToString(), new object[] { });
        return Math.Sqrt(d2Min);
    }

    //This is broken (broadcasts to everyone, not just the Player) but has one BIG advantage:
    //the messages can be seen on the lobby/map screen
    public void Stb_Chat(string line, Player player)
    {
        string to = " TO ";
        if (player != null && player.Name() != null) to += player.Name();
        if (GamePlay is GameDef)
        {
            (GamePlay as GameDef).gameInterface.CmdExec("chat " + line + to);
        }
    }



    /*******************************************************************************
     ******************************************************************************* 
     * METHODS DIFFERENT FOR DIFFERENT CAMPAIGNS
     * 
     * Below we're collecting the methods that are wildly different between different TWC
     * campaigns so that we can more easily use comparison tools on the similar portions above.
     * 
     * *******************************************************************************
     * *****************************************************************************/



    /******************************************************************************************************************** 
     * MISSION OBJECTIVES CLASSES & METHODS
     * 
     * Methods & classes for dealing with objectives, messages & other results of destroying objectives, awarding points, dealing with disabled radar, etc
     * 
     * All Mission Objectives should be listed & handled here, then a simple routine below can be called from OnTrigger, OnBombExploded, etc
     * rather than having code & variables related to objectives scattered hither & yon across the entire file
     * 
     * ******************************************************************************************************************/

    /*   points to turn map**********************************************
    public double InitialBlueObjectiveCount = 0;
    public double InitialRedObjectiveCount = 0;
    public string Objective_Total_Blue = "";
    public string Objective_Total_Red = "";
    osk_BlueObjDescription
    */

    //was InitialBlueObjectiveCount
    Dictionary<ArmiesE, double> MissionObjectiveScore = new Dictionary<ArmiesE, double>()
    {    {ArmiesE.Red, 0 },
         {ArmiesE.Blue, 0 }
    };  //reference as MissionObjectiveScore[ArmiesE.Red] MissionObjectiveScore[ArmiesE.Blue]

    //was Objective_Total_Blue
    Dictionary<ArmiesE, string> MissionObjectivesCompletedString = new Dictionary<ArmiesE, string>()
    {    {ArmiesE.Red, "" },
         {ArmiesE.Blue, "" }
    };

    /*  NO LONGER NEEDED!  Replaced by MO_ListRemainingPrimaryObjectives(player, player.Army()); which is better & also does the sector/recon/exact position thing
    //was osk_BlueObjDescription
    Dictionary<ArmiesE, string> MissionObjectivesString = new Dictionary<ArmiesE, string>()
    {    {ArmiesE.Red, "" },
         {ArmiesE.Blue, "" }
    };
    */

    /*********************************************************************************************************************
     * VALUES BELOW WILL BE OVERRIDEN BY Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs
     * 
     * 
     * 
     * 
     * */

    //What percent of primary targets is actually required ot turn the map
    //If you make it 100% you have to get them all, but if some are difficult or impossible then that army will be stuck
    public Dictionary<ArmiesE, double> MO_PercentPrimaryTargetsRequired = new Dictionary<ArmiesE, double>() {
        {ArmiesE.Red, 80 },
        {ArmiesE.Blue, 80 }
    };

    //TODO: Use similar scheme for total points, objectives completed list, objectives completed
    //Points required, assuming they are doing it entirely with Primary Targets; ie, secondary or other targets do not count towards this total
    //at all
    public Dictionary<ArmiesE, double> MO_PointsRequiredToTurnMap = new Dictionary<ArmiesE, double>() {
        {ArmiesE.Red, 120 },
        {ArmiesE.Blue, 120 }
    };

    public class MO_BRBumrushInfoType
    {
        public double PointsRequiredToBeginBumrush;

        //So 0 is no bumrush launched.
        //1 is the attackers have launched their bumrush.  2 is that has ended & defenders have launched theirs.  3 is the attackers have re-attacked, 4 the defenders re-attacked etc.
        public int BumrushStatus;
        public string BumrushObjectiveName;
        public string BumrushAirportName;

        public MissionObjective BumrushObjective; //The objective we're using as the focus of the bumrush; probably an airport

    }

    //Note that these are (or CAN BE) over-written by Tobruk_Campaign\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs
    //and then also Tobruk_Campaign\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesBattles.cs
    //and Tobruk_Campaign\Fresh Input File\Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesPosXXX.cs or Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectivesNegXXX.cs in turn
    public Dictionary<ArmiesE, MO_BRBumrushInfoType> MO_BRBumrushInfo = new Dictionary<ArmiesE, MO_BRBumrushInfoType>() {
        {ArmiesE.Red, new MO_BRBumrushInfoType() {
            PointsRequiredToBeginBumrush= 60,
            BumrushStatus= 0,
            BumrushObjective = null,
             }
        },
        { ArmiesE.Blue, new MO_BRBumrushInfoType() {
            PointsRequiredToBeginBumrush= 60,
            BumrushStatus= 0,
            BumrushObjective = null,
             }
        },
    };
      
    /*
     *
     *
     *
     *
     *
     * VALUES ABOVE OVERRIDEN BY Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs
     ************************************************************************************************************************************/



    //Blank MO_BRBumrushInfo where we can restore data from disk/save @ end of mission
    public Dictionary<ArmiesE, MO_BRBumrushInfoType> MO_BRBumrushInfoRestored = new Dictionary<ArmiesE, MO_BRBumrushInfoType>();

    /*
    public Dictionary<ArmiesE, double> MO_PointsRequiredToBeginBumRush = new Dictionary<ArmiesE, double>() {
        {ArmiesE.Red, 60 },
        {ArmiesE.Blue, 60 }
    };
    */

    //So 0 is no bumrush launched.
    //1 is the attackers have launched their bumrush.  2 is that has ended & defenders have launched theirs.  3 is the attackers have re-attacked, 4 the defenders re-attacked etc.
    //
    //We're tracking this separately for Red & Blue as FOR NOW only one side can have a bumrush situation going.  BUT . . . in the future maybe if
    //both sides complete their initial objective we could have TWO bumrush situations going on simultaneously
    /*
     * This is MO_BRBumrushInfo now
    public Dictionary<ArmiesE, int> MO_BRBumRushStatus = new Dictionary<ArmiesE, int>() {
        {ArmiesE.Red, 0 },
        {ArmiesE.Blue, 0 }
    };
    */

    //////////////////////******************************************/////////////////////////////
    //Amount of points require in case percent of primary is less than 100% but more than MO_PercentPrimaryTargetsRequired
    //This allows mission to be turned in case one objective is malfunctioning or super-difficult - by hitting some other alternate targets
    //So this is like a consolation prize.  You couldn't take out all primary targets?  OK, you can just take out a few MORE alternates
    //Generally thise should be more than MO_PointsRequired
    //If it's less than MO_PointsRequired then the MO_PercentPrimaryTargetsRequired becomes more the operative factor in determining the map turn
    public Dictionary<ArmiesE, double> MO_PointsRequiredWithMissingPrimary = new Dictionary<ArmiesE, double>() {
        {ArmiesE.Red, 75 },
        {ArmiesE.Blue, 75 }
    };

    public Dictionary<ArmiesE, string> MO_IntelligenceLeakNearMissionEnd = new Dictionary<ArmiesE, string>() {
        {ArmiesE.Red, "" },  //the leak FOR red army (about something Blue is doing)
        {ArmiesE.Blue, "" }  //the leak FOR blue army (about something Red is doing)
    };

    //Dictionary<string, IMissionObjective> MissionObjectivesList = new Dictionary<string, IMissionObjective>();
    Dictionary<ArmiesE, List<MissionObjective>> DestroyedObjectives = new Dictionary<ArmiesE, List<MissionObjective>>() {
        {ArmiesE.Red, new List<MissionObjective>() },
        {ArmiesE.Blue, new List<MissionObjective>() }
    };  //reference as DestroyedObjectives[ArmiesE.Red] DestroyedRadar[ArmiesE.Blue]

    Dictionary<ArmiesE, List<MissionObjective>> DestroyedRadar = new Dictionary<ArmiesE, List<MissionObjective>>() {
        {ArmiesE.Red, new List<MissionObjective>() },
        {ArmiesE.Blue, new List<MissionObjective>() }
    };  //reference as DestroyedRadar[ArmiesE.Red] DestroyedRadar[ArmiesE.Blue]

    Dictionary<ArmiesE, List<String>> MissionObjectivesSuggested = new Dictionary<ArmiesE, List<String>>() {
        {ArmiesE.Red, new List<String>() },
        {ArmiesE.Blue, new List<String>() }
    };

    //Generic place to store various dates/times needed for missions/objectives etc.  Can save/restore to disk.  Example: Time when repair crews go home.
    Dictionary<ArmiesE, Dictionary<string,DateTime>> MissionObjectivesTimes = new Dictionary<ArmiesE, Dictionary<string, DateTime>>() {
        {ArmiesE.Red, new Dictionary<string,DateTime>() },
        {ArmiesE.Blue, new Dictionary<string,DateTime>() }
    };

    public enum MO_TriggerType { Trigger, Static, Airfield, PointArea, TemporaryLandingGround };
    public enum MO_ObjectiveType { Radar, AA, Ship, Building, Fuel, Airfield, Aircraft, Vehicles, Convoy, Bridge, Dam, Dock, RRYard, Railroad, Road, AirfieldComplex, FactoryComplex, ArmyBase, IndustrialArea, MilitaryArea, ProductionFacility, StorageFacility, AttackColumn, TemporaryLandingGround }; //Production facility is the type of thing that produces something needed for the war that will affect players, such as planes, gas, ammo, etc.  If destroyed it will cause
                                                                                                                                                                                                                                                             // a shortage of those items. Similarly if a StorageFacility is destroyed it will cause an immediate loss of some of the existing supply of (say) aircraft of that type.  NOT IMPLEMENTED YET!!!
                                                                                                                                                                                                                                                             //type Airfield is the auto-entered list of airfield objectives (every active airport in the game) whereas AirfieldComplex could be an additional specific target on or near an airfield
    public enum MO_ProducerOrStorageType { None, Beaufighter, SpitfireII, SpitfireIa, Spitfire, Blenheim, Wellington, Hurricane, BF109_3, BF109_1, BF109_4, BF109, BF110, HE111, G50, JU88, JU87, fighter, bomber, fuel, bullets_shells, bombs };

    public enum MO_MobileObjectiveType { None, ArmyEncampment, MobileRadar1, MobileRadar2, DesertRadar, CamoGroup, SmallArmourGroup, LargeArmourGroup, SecretAirbaseGB, SecretAirbaseDE, SecretAircraftResearchGB, SecretAircraftResearchDE };
    public enum MO_MobileObjectiveThings { Humans, Items, Trucks, Tents, Tables, Buildings, Radar, Small_Radar, Sentry, Trenches, Sandbags, Armor_Tanks, Cars, Jerrycans, GBFighters, GBBombers, DEFighters, DEBombers, Hedgehogs, Misc, Camo, Detritus };


    [DataContract()]
    public class MissionObjective : IMissionObjective
    {
        //public string TriggerName { get; set; }
        //NOTE!!!! If you ADD in a new variable here, you should also check public void updateMissionObjectivesListOnReload(MissionObjectives m_os) to make sure it is transferred over 
        //to the new MissionObjectivesList on mission re-load!  Only selected variables are transferred over & they are (or can be) massaged in various ways, etc
        //
        [DataMember] public string ID { get; set; } //unique name, often the Triggername or static name; note that this can be different from the MissionObjectivesList KEY for various reasons
        [DataMember] public string Name { get; set; } //Name the will be displayed to the [DataMember] public in messages etc
        [DataMember] public int AttackingArmy { get; set; } // Army this is an objective for (ie, whose task is to destroy it); can be 1=red, 2=blue,0=none
        [DataMember] public int OwnerArmy { get; set; } // Army that owns this object (ie, is harmed if it is destroyed)
        [DataMember] public string FlakID { get; set; } //Flak area associated with this objective.  Flak area codes & associated .mis files are identified in FlakMissions dictionary defined below
        [DataMember] public string InitSubmissionName { get; set; } //(optional) Name (& possible subdirectory) of the .mis file to load when this objective is active.
        [DataMember] public string ChiefName { get; set; } //(optional) Name of the "Chief" associated with this objective, like 1009_Chief. If provided it allows the detection of the actual location of the _Chief on recon flights.  So when reconned, it will tell the actual location of the ship or convoy at the time of recon, not just the starting point of the _Chief's route.
        [DataMember] public bool AutoFlakIfPrimary { get; set; } //Automatically place flak batteries near this objective, but only if it is chosen as a primary
        [DataMember] public bool AutoFlak { get; set; } //Automatically place flak batteries near this objective
        [DataMember] public int NumFlakBatteries { get; set; }
        [DataMember] public int NumInFlakBattery { get; set; }

        [DataMember] public bool IsEnabled { get; set; } //TODO: This is only partially implemented. But a certain % of objectives are marked disabled @ the start of each session; this has the effective of making them disappear (entirely in some cases, or just as objectives on the list in others)
        [DataMember] public bool CanBeDisabled { get; set; } //Many objectives can be disabled/moved/out of commission/whatever.  But some like large industrial areas, airports, etc just can't be disabled like that.
        [DataMember] public Mission.MO_ObjectiveType MOObjectiveType { get; set; }
        [DataMember] public Mission.MO_ProducerOrStorageType MOProducerOrStorageType { get; set; } //NOT IMPLEMENTED YET!
        [DataMember] public double MO_ProductionCut_pct { get; set; } //production cut caused by the loss of this item, percent 0-1 (= 0-100% or perhaps more than 100% possible? Or less, to cause an increase in production for that item?)
        [DataMember] public double MO_StorageCut_pct { get; set; } //percent of storage of this item cut/eliminated/destroyed caused by the loss of this item, percent 0-1 (= 0-100% or perhaps more than 100% possible? Or less, to cause an increase in production for that item?)
        [DataMember] public Point3d MO_ProductionStorageCutRadius_m { get; set; } //x,y point & radius (Point3d.z) within which this percent of storage or production of this item cut/eliminated/destroyed caused by the loss of this item will happen.  So you could for example have a shortage of spitfires or fuel in one area of the map that is serviced by this production or storage plant. The production cut will continue until the item is undestroyed.  The storage cut will be one-time when the item is destroyed.  NOT IMPLEMENTED!!!!!

        [DataMember] public Mission.MO_TriggerType MOTriggerType { get; set; }
        [DataMember] public bool IsPrimaryTarget { get; set; } //One of the primary/required targets for this mission?
        [DataMember] public double PrimaryTargetWeight { get; set; } //If we select primary targets randomly etc, is this one that could be selected? Percentage weight 0-100, 0 means never chosen.  Update: Now 0-200.  2020-01.
        [DataMember] public bool IsFocus { get; set; } //The focus airport/objective for this campaign/mission?

        [DataMember] public double Points { get; set; } //How many points are awarded to the side that destroys this objective
        [DataMember] public double TimetoRepairIfDestroyed_hr { get; set; } //hours needed to repair this objective if it is destroyed, per 100%.  Ie if 200% destroyed it will take 2X this long.
        [DataMember] public bool Destroyed { get; set; }
        [DataMember] public double DestroyedPercent { get; set; } //some items can potentially be partially destroyed, it 50% = 0.5, 100%=1.0; also higher numbers possible such as 200% = 2.0;
        [DataMember] public bool ObjectiveAchievedForPoints { get; set; } //We set this when one side destroys an objective & gets the points for it.  We can then remove this when that side
                                                                          //turns the map so that they have a clean slate of new objectives.  But the points is independent of whether
                                                                          //it is actually still destroyed or not.
        [DataMember] public HashSet<string> PlayersWhoContributedNames { get; set; } //list of any players who have contributed to destroying this objective                                                                           
        [DataMember] public DateTime? TimeToUndestroy_UTC { get; set; } //if destroyed, what time UTC is the d/t it should be undestroyed/repaired.  This is in real time, ie if item destroyed 10pm, Tues Jan 24, 2022 UTC for 24 hours then it will be repaired at 10pm Wed Jan 25, 2022.
                                                                        //NOTE!!!! That Airfields use this slightly differently from other objectives.  When they are damaged they start registering a time to undestroy, even if they are not 100% destroyed.  This is the time when all damage should be repaired, removed. 
        [DataMember] public DateTime? LastHitTime_UTC { get; set; } //Last time target attacked/hit

        [DataMember] public bool Scouted { get; set; } //whether or not it has been scouted or reconnoitered by the enemy; if so they can get access to exact coordinates etc
        //public Dictionary<Player,int> PlayersWhoScouted { get; set; } //list of any players who have scouted this objective //Player is not serializable, alas.
        [DataMember] public Dictionary<string, int> PlayersWhoScoutedNames { get; set; } //list of any players who have scouted this objective
        [DataMember] public Point3d lastScoutedPos { get; set; } //where this objective was, at the time it was last scouted.  Note that x,y (meters) and ELEVATION ASL z (meters OR feet above SEA LEVEL) are inherited from Pos.
        [DataMember] public String lastScoutedSector { get; set; } //where this objective was, at the time it was last scouted
        [DataMember] public int numTimesScouted { get; set; } //how many times this objective has been scouted (since map turned/scouted objectives cleared)
        [DataMember] public DateTime? lastTimeScouted_dt { get; set; } //last Date/time this objective was scouted, in historical date/time terms (ie a 1940s ydt:hms)


        [DataMember] public bool hasGeneralStaff { get; set; } //one of the objectives for each side will have one of the top generals/staff/staff car nearby ONE of their primary objectives

        [DataMember] public Point3d Pos { get; set; } //x,y is the map position of the objectives in meters,meters - corresponds to coordinates used by CloD for location.  Pos.z is the elevation/altitude ASL (above sea level) of the objective above sea level.  If attacking army is Blue/2 this is in meters, if attacking army is Red/1 it is in FEET.
        [DataMember] public double radius { get; set; } //extent of the object, ie, for airfields, how far center to the perimeter.  This is more FYI as info about the object, although it can be used to determine whether hits to a certain object are effective, or how effective (as we do with airfields)

        [DataMember] public string Sector { get; set; }
        [DataMember] public string bigSector { get; set; } //a block of several sectors, somewhat randomly selected, and the target is somewhere within it
        [DataMember] public string HUDMessage { get; set; }
        [DataMember] public string LOGMessage { get; set; }
        [DataMember] public string SuccessSubmissionName { get; set; } //submission to launch when objective reached; if blank nothing launched
        [DataMember] public double RadarEffectiveRadius { get; set; }

        [DataMember] public string TriggerName { get; set; }
        [DataMember] public string TriggerType { get; set; }
        [DataMember] public double TriggerPercent { get; set; }
        [DataMember] public double TriggerDestroyRadius { get; set; } //What is set in the .mis file as the effective radius for this trigger object.  This is slightly different from "radius" in that it is a number used only internally to determine if the destroy objects are within the effective area of the trigger.

        [DataMember] public double OrdnanceRequiredToTrigger_kg { get; set; } //For type PointArea
        [DataMember] public double OrdnanceOnTarget_kg { get; set; } //For PointArea & similar - how many KG ordnance have hit this target already
        [DataMember] public double ObjectsRequiredToTrigger_num { get; set; } ////For type JerryCanArea: buildings, static objects, etc within the given radius required to trigger it.  Using actual number instead of percent, because I don't think we cna get the listing of now many buildings etc in a given area. 
        [DataMember] public double ObjectsDestroyed_num { get; set; } //how many objects have been destroyed so far. 

        [DataMember] public double AirfieldDamagePoints { get; set; } //For airfields, how many destruction points have been received by that airport
        [DataMember] public double AirfieldPointsRequired { get; set; } //For airfields, how many damage points required to close it/ 100% damage
        public AiAirport aiairport { get; set; } //CloD internal airport object.  Can't save as [DataMember] due to it being in an external assembly etc
        [DataMember] public string AirfieldName { get; set; } //The ID is generally set to "internal airfieldname_spawn" and name is something like "internal airfieldname Airfield" (unless the actual name already includes "airfield" or "airbase" or similar).  This saves the actual/original airfield name incase we need to find it again.

        [DataMember] public HashSet<string> BirthplaceACTypes { get; set; } //For a Landing Ground Objective, which types of aircraft are included in the spawn area/birthplace 

        [DataMember] public List<string> StaticNames { get; set; } //for static targets, the list of static names that will determine if the target is destroyed
        [DataMember] public double StaticPercentageRequired { get; set; } //what percentage of those static targets must be destroyed to eliminate the objective
        [DataMember] public List<string> StaticRemoveNames { get; set; } //what statics to remove when the object is destroyed (allows eg dams to be breached by removal of certain portions)
        [DataMember] public Point3d[] StaticRemovalPoint_Radius_m { get; set; } //OR you can specify a list of points & corresponding radii to remove ALL statics within that radius from the point
                                                                                //Point3d.x & y are the point, .z is the radius.  TODO: This is not working yet        
        [DataMember] public double StaticRemoveDelay_sec { get; set; } //how long to wait after target destruction before removing static objects in list
        [DataMember] public double StaticRemoveSpread_sec { get; set; } //how long to spread out the static target destruction

        [DataMember] public MO_MobileObjectiveType MOMobileObjectiveType { get; set; } //MO_MobileOBjectiveType.None if it's not mobile/movable
        [DataMember] public double MobileMoveTime_hrs { get; set; } //Time between moves of this objective (hours)
        [DataMember] public DateTime? MobileNextMoveTime_dt { get; set; } //Next date/time this mobile objective should be moved;
        [DataMember] public double MobileMaxMoveDist_km { get; set; } //Minimum distance to move (km)
        [DataMember] public double MobileMinMoveDist_km { get; set; } //Maximum distance to move (km)
        [DataMember] public Point3d MobileSWPoint { get; set; } //area the MobileObjectiveType can roam is defined by a rectangle; these two points give the SW & NE corners of the rect
        [DataMember] public Point3d MobileNEPoint { get; set; }


        [DataMember] public string Comment { get; set; } //PRIVATE comment, ie for developers, internal notes, etc, not for display to end users
        public Mission msn;

        //for serialization we must  have a paramterless constructor.  So if we serialize things in we'll have to add the Mission msn value later;
        //after loading the data back in & unserializing it.
        public MissionObjective()
        {
        }

        public MissionObjective(Mission m)
        {
            msn = m;
        }
        //RADAR TRIGGER initiator ; does EITHER trigger OR PointArea, depending on parameters/trigger type given
        public MissionObjective(Mission m, string objectiveKey, string objectiveName, string flak, int ownerarmy, double pts, double repairdays, string mission_trigger_type, double trigger_percent, double x, double y, double trigger_destroy_radius, double radar_effective_radius, bool is_primary_target, double primary_target_weight, string comment, MO_ObjectiveType MObjType = MO_ObjectiveType.Radar, MO_TriggerType MOTrigType = MO_TriggerType.Trigger, string initSub = "", double orttkg = 100, double orttn = 2, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "")
        {

            msn = m;
            Pos = new Point3d(x, y, 0); //See below for z value added - elevation ASL in feet OR meters

            MOObjectiveType = MObjType;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MOTrigType;
            TriggerName = objectiveKey;
            ID = objectiveKey;
            Name = objectiveName;
            ChiefName = chief_name; //Name of the chief used in teh mission or submission file, like 1009_Chief.  We can use this to find the exact location of that _Chief during recon flights etc.
            FlakID = flak;
            AutoFlakIfPrimary = true;
            AutoFlak = true;
            NumFlakBatteries = 3;
            NumInFlakBattery = 4;

            MOMobileObjectiveType = MO_MobileObjectiveType.None;
            MobileMoveTime_hrs = 0; //Time after which the mobile objective should move to a different location. 0 means never.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.
            MobileMaxMoveDist_km = 0;
            MobileMinMoveDist_km = 0;
            MobileSWPoint = Pos;
            MobileNEPoint = Pos;

            //NumFlakBatteries = 3;
            //NumInFlakBattery = 4;

            IsEnabled = true;
            CanBeDisabled = false;  //Radar is mostly fixed installations; if it's there it's there.

            TimetoRepairIfDestroyed_hr = repairdays * 24;
            OwnerArmy = ownerarmy;
            AttackingArmy = 3 - ownerarmy;
            if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;

            //double z = twcLandscape.HQ(Pos.x, Pos.y); 
            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);

            if (AttackingArmy != 0)
            {
                HUDMessage = ArmiesL[AttackingArmy] + " destroyed " + Name;
                LOGMessage = "Heavy damage to " + Name + " - out of action about " + this.TimetoRepairIfDestroyed_hr.ToString("F0") + " hours. Good job " + ArmiesL[AttackingArmy] + "!!!";
            }
            else
            {
                HUDMessage = Name + " was destroyed";
                LOGMessage = Name + " was destroyed, " + this.TimetoRepairIfDestroyed_hr.ToString("F1") + " hours to repair. " + pts + " awarded " + ArmiesL[AttackingArmy];
            }

            Points = pts;
            TriggerType = mission_trigger_type; //the name/string of the trigger type from the .mis file.  Just FYI, not using it for anything at present.
            TriggerPercent = trigger_percent;

            /* string keyp = Calcs.doubleKeypad(Pos);
            Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);
            TriggerDestroyRadius = trigger_destroy_radius;
            RadarEffectiveRadius = radar_effective_radius;

            radius = trigger_destroy_radius;

            OrdnanceRequiredToTrigger_kg = orttkg;
            OrdnanceOnTarget_kg = 0; //stores how much ordinance has been piled on this target
            ObjectsRequiredToTrigger_num = orttn;
            ObjectsDestroyed_num = 0;


            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;


            IsPrimaryTarget = is_primary_target;
            PrimaryTargetWeight = primary_target_weight;
            Comment = comment;
        }


        //AIRFIELD initiator
        //public Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>> AirfieldTargets = new Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>>();
        //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, double airfield radius, Point3d airfield center (position)
        public MissionObjective(Mission m, double pts, double ptp, AiAirport airport, int ownerarmy, Tuple<bool, string, double, double, DateTime, double, Point3d> tup, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, bool is_focus = false, string chief_name = "")
        //            string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, int ptp, string comment, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None)
        //IsFocus is whether or not this AP is one of the special ones--one from each side--that must be knocked out before other certain things happen.  (Tobruk campaign, 2020/08)
        {

            msn = m;
            MOObjectiveType = MO_ObjectiveType.Airfield;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MO_TriggerType.Airfield;
            ID = tup.Item2 + "_spawn";
            Console.WriteLine("Creating NEW MissionObjective airport: " + ID);
            Name = tup.Item2;

            //If the airport name doesn't include a word like "airport" then add it to the end (just for clarify)
            Regex r = new Regex("Airfield|Airbase|Flughafen|Airport|Aerodrome|Airdrome|Fliegerhorst|Luftstützpukt|Flugstation|Luftwaffenstützpunkt|LG|Landing Ground", RegexOptions.IgnoreCase);
            if (!r.IsMatch(Name)) Name += " Airfield";

            AirfieldDamagePoints = tup.Item4;  //For airfields, how many destruction points have been received by that airport
            AirfieldPointsRequired = tup.Item3; //For airfields, how many damage points required to close it/ 100% damage
            AiAirport aiairport = airport; //CloD internal airport object.  Can't save as [DataMember] due to it being in an external assembly etc
            AirfieldName = tup.Item2;//The ID is generally set to "internal airfieldname_spawn" and name is ""internal airfieldname Airfield" (unless the original name includes a word like "Airfield" or "Airbase" or similar.  This saves the actual/original/exact airfield name incase we need to find it again.

            ChiefName = chief_name; //Name of the chief used in teh mission or submission file, like 1009_Chief.  We can use this to find the exact location of that _Chief during recon flights etc.

            FlakID = ""; //no flak files for airports . . . yet
            AutoFlakIfPrimary = true;
            AutoFlak = false;
            NumFlakBatteries = 3;
            NumInFlakBattery = 3;
            //for testing
            //NumFlakBatteries = 3;
            //NumInFlakBattery = 4;


            Pos = tup.Item7;

            MOMobileObjectiveType = MO_MobileObjectiveType.None;
            MobileMoveTime_hrs = 0; //Time after which the mobile objective should move to a different location. 0 means never.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.
            MobileMaxMoveDist_km = 0;
            MobileMinMoveDist_km = 0;
            MobileSWPoint = Pos;
            MobileNEPoint = Pos;

            IsEnabled = true;
            CanBeDisabled = false;  //Airfields are mostly fixed installations; if it's there it's there.


            //OwnerArmy = airport.Army(); OK, this doesn't work as all .Army() for airports is set to 0        
            OwnerArmy = ownerarmy;
            AttackingArmy = 3 - OwnerArmy;
            if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;


            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);

            HUDMessage = null;//hud/log messages are handled by the handle airport bombing routine
            LOGMessage = null;

            Points = pts;
            string keyp = Calcs.doubleKeypad(Pos);
            /* Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma     */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);

            radius = tup.Item6; //

            TimetoRepairIfDestroyed_hr = 200 * 20 / 60; //Airfields have their own routines for figuring this out, but we are still setting this here as the typical/average value
                                                        //Formula is points taken * 20 = minutes to repair.  So 200 pts require to take out an airfield means 200*20/60 hours.
            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;

            IsPrimaryTarget = false;
            PrimaryTargetWeight = ptp;
            IsFocus = is_focus;
            Comment = "Auto-generated from in-game airports list";
        }

        //TEMPORARY LANDING GROUND initiator
        
        public MissionObjective(Mission m, string objective_id, string name, Point3d pos, double radius_m, double objective_points, double primaryobjective_weight, double timeToRemainActive_hrs, string flak_file, int ownerarmy, bool auto_flak = true, bool auto_flak_ifprimary = true, int flak_numbatteries = 7, int flak_numberinbattery = 8, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "")

        {

            msn = m;
            MOObjectiveType = MO_ObjectiveType.TemporaryLandingGround;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MO_TriggerType.TemporaryLandingGround;
            ID = objective_id;
            Console.WriteLine("Creating NEW MissionObjective Temporary Landing Ground: " + ID);
            Name = name;

            AirfieldName = name;//The ID is generally set to "internal airfieldname_spawn" and name is ""internal airfieldname Airfield" (unless the original name includes a word like "Airfield" or "Airbase" or similar.  This saves the actual/original/exact airfield name incase we need to find it again.

            BirthplaceACTypes = new HashSet<string>(); //For a Landing Ground Objective, which types of aircraft are included in the spawn area/birthplace 

            ChiefName = chief_name; //Name of the chief used in the mission or submission file, like 1009_Chief.  We can use this to find the exact location of that _Chief during recon flights etc.

            FlakID = flak_file; //no flak files for airports . . . yet
            AutoFlakIfPrimary = true;
            AutoFlak = true;
            NumFlakBatteries = 2;
            NumInFlakBattery = 2;
            //for testing
            //NumFlakBatteries = 3;
            //NumInFlakBattery = 4;


            Pos = pos;

            MOMobileObjectiveType = MO_MobileObjectiveType.None;
            MobileMoveTime_hrs = 0; //Time after which the mobile objective should move to a different location. 0 means never.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.
            MobileMaxMoveDist_km = 0;
            MobileMinMoveDist_km = 0;
            MobileSWPoint = Pos;
            MobileNEPoint = Pos;

            IsEnabled = true;
            CanBeDisabled = false;  //Airfields are mostly fixed installations; if it's there it's there.


            //OwnerArmy = airport.Army(); OK, this doesn't work as all .Army() for airports is set to 0        
            OwnerArmy = ownerarmy; //This is a bit confused as this target needn't be "attacked".  
            AttackingArmy = ownerarmy; //Attacked in this case means "army that needs to complete or accomplish this task."
            //if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;


            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);            

            Points = objective_points;
            string keyp = Calcs.doubleKeypad(Pos);
            /* Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma     */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);

            radius = radius_m; //

            TimetoRepairIfDestroyed_hr = timeToRemainActive_hrs; //Another strange one; we're reversing the "destroyed" system - this is how long it stays active once established

            HUDMessage = ArmiesL[AttackingArmy] + " created a Landing Ground - " + Name;
            LOGMessage = "New Landing Ground " + Name + " created by " + ArmiesL[AttackingArmy] + " - active for " + (this.TimetoRepairIfDestroyed_hr / 24.0).ToString("F1") + " days.";

            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;

            IsPrimaryTarget = false;
            PrimaryTargetWeight = primaryobjective_weight;
            IsFocus = false;
        }

        //TRIGGER initiator (for all trigger types except RADAR & AIRFIELD & POINTAREA)
        public MissionObjective(Mission m, MO_ObjectiveType mot, string tn, string n, string flak, string init_submission_filename, string chief_name, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, double ptp, double ttr_hr, string comment, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None)
        {

            Console.WriteLine("Initiating Trigger objective " + tn + " submission file: " + init_submission_filename);
            msn = m;
            Pos = new Point3d(x, y, 0);

            MOObjectiveType = mot;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MO_TriggerType.Trigger;
            TriggerName = tn; //Objective ID ALSO ***MUST BE*** the exact triggername as used in the .mis file
            ID = tn;
            Name = n;
            FlakID = flak;
            InitSubmissionName = init_submission_filename;
            ChiefName = chief_name; //Name of the chief used in teh mission or submission file, like 1009_Chief.  We can use this to find the exact location of that _Chief during recon flights etc.
            AutoFlakIfPrimary = true;
            AutoFlak = false;
            //NumFlakBatteries = 4;
            //NumInFlakBattery = 10;
            //for testing
            NumFlakBatteries = 2;
            NumInFlakBattery = 6;

            MOMobileObjectiveType = MO_MobileObjectiveType.None;
            MobileMoveTime_hrs = 0; //Time after which the mobile objective should move to a different location. 0 means never.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.
            MobileMaxMoveDist_km = 0;
            MobileMinMoveDist_km = 0;
            MobileSWPoint = Pos;
            MobileNEPoint = Pos;

            IsEnabled = true;
            CanBeDisabled = false;  //Mostly these rely on fixed/existing buildings etc that can't be removed

            OwnerArmy = ownerarmy;
            AttackingArmy = 3 - ownerarmy;
            if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;

            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);

            if (AttackingArmy != 0)
            {
                HUDMessage = ArmiesL[AttackingArmy] + " destroyed " + Name;
                LOGMessage = "Heavy damage to " + Name + " - good job " + ArmiesL[AttackingArmy] + "!!!";
            }
            else
            {
                HUDMessage = Name + " was destroyed";
                LOGMessage = Name + " was destroyed";
            }

            Points = pts;
            TriggerType = t;
            TriggerPercent = p;

            string keyp = Calcs.doubleKeypad(Pos);
            /* Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma     */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);

            radius = 75;

            TriggerDestroyRadius = d;
            TimetoRepairIfDestroyed_hr = ttr_hr;
            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;

            IsPrimaryTarget = pt;
            PrimaryTargetWeight = ptp;
            Comment = comment;
        }

        //POINTAREA initiator.  An area which is designated by a map coordinate and radius.  
        //You can designate EITHER kg tonnage of ordnance dropped in that area to destroy it, OR a certain number of objects (static objects, actors, buildings, etc) that must be killed within that radius (the buildings part working depends on TF getting the onbuildingdestroyed routine working again).
        //OR you can choose BOTH and in that case the players will have to drop the certain tonnage on the area AND kill the certain number of objects
        public MissionObjective(Mission m, MO_ObjectiveType objective_type, string objective_ID, string objective_name, string flak, string init_submission_filename, int ownerarmy, double points, double x, double y, double rad, double trigrad, double orttkg, double orttn, double primary_target_weight, double ttr_hr, bool auto_flak, bool auto_flak_ifprimary, int num_flakbatteries, int num_in_eachbattery, string comment, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "")
        {

            Console.WriteLine("Initiating PointArea objective " + objective_ID);
            msn = m;
            Pos = new Point3d(x, y, 0);

            MOObjectiveType = objective_type;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MO_TriggerType.PointArea;
            TriggerName = objective_ID;
            ID = objective_ID;
            Name = objective_name;
            FlakID = flak;
            InitSubmissionName = init_submission_filename;
            AutoFlakIfPrimary = auto_flak_ifprimary;
            AutoFlak = auto_flak;
            //These are big wide open easy bombing targets, but thye are heavily defended, must come in high.  Is the idea.
            NumFlakBatteries = num_flakbatteries;
            NumInFlakBattery = num_in_eachbattery;
            ChiefName = chief_name;


            //for testing
            //NumFlakBatteries = 1;
            //NumInFlakBattery = 10;

            MOMobileObjectiveType = MO_MobileObjectiveType.None;
            MobileMoveTime_hrs = 0; //Time after which the mobile objective should move to a different location. 0 means never.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.
            MobileMaxMoveDist_km = 0;
            MobileMinMoveDist_km = 0;
            MobileSWPoint = Pos;
            MobileNEPoint = Pos;

            IsEnabled = true;
            CanBeDisabled = true;
            if (Name.ToUpper().Contains("AREA")) CanBeDisabled = false;  //Can't disable area objectives, they are too large, complicated, etc.

            OwnerArmy = ownerarmy;
            AttackingArmy = 3 - ownerarmy;
            if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;

            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);

            if (AttackingArmy != 0)
            {
                HUDMessage = ArmiesL[AttackingArmy] + " destroyed " + Name;
                LOGMessage = "Heavy damage to " + Name + " - good job " + ArmiesL[AttackingArmy] + "!!!";
            }
            else
            {
                HUDMessage = Name + " was destroyed";
                LOGMessage = Name + " was destroyed";
            }

            Points = points;
            TriggerType = ""; //used for CLoD internal triggers, which have a name like TGroundtarget
            TriggerPercent = 0; //we're not using this here, it is only for CloD built-in triggers
            Pos = new Point3d(x, y, 0);
            string keyp = Calcs.doubleKeypad(Pos);
            /* Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma     */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);

            radius = rad;

            TriggerDestroyRadius = trigrad;

            OrdnanceRequiredToTrigger_kg = orttkg;
            OrdnanceOnTarget_kg = 0; //stores how much ordinance has been piled on this target
            ObjectsRequiredToTrigger_num = orttn;
            ObjectsDestroyed_num = 0;

            TimetoRepairIfDestroyed_hr = ttr_hr;
            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;

            IsPrimaryTarget = false;
            PrimaryTargetWeight = primary_target_weight;
            Comment = comment;


        }

        //POINTAREA ***AND*** MOBILE OBJECTIVE initiator.  An area which is designated by a map coordinate and radius ***AND*** which moves around within a designated rectangle every time a new session starts or whenever
        //You can designate EITHER kg tonnage of ordnance dropped in that area to destroy it, OR a certain number of objects (static objects, actors, buildings, etc) that must be killed within that radius (the buildings part working depends on TF getting the onbuildingdestroyed routine working again).  There is a failsafe so if oneside or the other is achieved over 200% it starts to count towards the other side (typically, KG-age, which will start to count towards objects killed, but it could be the other way, too)
        //OR you can choose BOTH and in that case the players will have to drop the certain tonnage on the area AND kill the certain number of objects
        public MissionObjective(Mission m, MO_ObjectiveType objective_type, string objective_ID, string objective_name, string flak, int ownerarmy,
            double points, double x, double y, double rad, double trigrad, double orttkg, double orttn, double primary_target_weight, double ttr_hr, bool auto_flak, bool auto_flak_ifprimary,
            int num_flakbatteries, int num_in_eachbattery,
            MO_MobileObjectiveType mobile_objective_type,
            double mobile_hours_between_moves,
            Point3d mobile_SW_point,
            Point3d mobile_NE_point,
            double min_move_dist_km,
            double max_move_dist_km,
            MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None,
            string comment = "", double radar_effective_radius_m = 20000,
            string chief_name = "")

        {

            Console.WriteLine("Initiating PointArea/Mobile objective " + objective_ID);
            msn = m;
            Pos = new Point3d(x, y, 0);

            MOObjectiveType = objective_type;
            MOProducerOrStorageType = MOProdStorType;
            MOTriggerType = MO_TriggerType.PointArea;
            TriggerName = objective_ID;
            ID = objective_ID;
            Name = objective_name;
            FlakID = flak;
            InitSubmissionName = null; //can't really figure out how an initsubmission file would be helpful for these mobile objectives?
            AutoFlakIfPrimary = auto_flak_ifprimary;
            AutoFlak = auto_flak;
            //These are big wide open easy bombing targets, but thye are heavily defended, must come in high.  Is the idea.
            NumFlakBatteries = num_flakbatteries;
            NumInFlakBattery = num_in_eachbattery;

            ChiefName = chief_name; //Name of the chief used in teh mission or submission file, like 1009_Chief.  We can use this to find the exact location of that _Chief during recon flights etc.

            //for testing
            //NumFlakBatteries = 1;
            //NumInFlakBattery = 10;

            MOMobileObjectiveType = mobile_objective_type;
            MobileMoveTime_hrs = mobile_hours_between_moves; //Time after which the mobile objective should move to a different location.
            MobileNextMoveTime_dt = null; //The next date/time when this mobile objective should be moved.  If null the objective will be placed @ start of mission, and then the MoveTime_dt will be set
            MobileMinMoveDist_km = min_move_dist_km;
            MobileMaxMoveDist_km = max_move_dist_km;
            MobileSWPoint = mobile_SW_point;//Best be sure they really are teh SW & NE points & not mixed up somehow.  Though it just MIGHT work regardless.
            MobileNEPoint = mobile_NE_point;

            IsEnabled = true;
            CanBeDisabled = true;  //It's mobile; it can disappear

            OwnerArmy = ownerarmy;
            AttackingArmy = 3 - ownerarmy;
            if (AttackingArmy > 2 || AttackingArmy < 1) AttackingArmy = 0;

            double z = Calcs.LandElevation_m(Pos); //saving altitude/elevation of the objective.
            if (AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
            Pos = new Point3d(Pos.x, Pos.y, z);

            if (AttackingArmy != 0)
            {
                HUDMessage = ArmiesL[AttackingArmy] + " destroyed " + Name;
                LOGMessage = "Heavy damage to " + Name + " - good job " + ArmiesL[AttackingArmy] + "!!!";
            }
            else
            {
                HUDMessage = Name + " was destroyed";
                LOGMessage = Name + " was destroyed";
            }

            Points = points;
            TriggerType = ""; //used for CLoD internal triggers, which have a name like TGroundtarget
            TriggerPercent = 0; //we're not using this here, it is only for CloD built-in triggers
            Pos = new Point3d(x, y, 0);
            string keyp = Calcs.doubleKeypad(Pos);
            /* Sector = msn.GamePlay.gpSectorName(x, y).ToString() + "." + keyp;
            Sector = Sector.Replace(",", ""); // remove the comma     */
            Sector = Calcs.correctedSectorNameDoubleKeypad(msn, Pos);
            bigSector = Calcs.makeBigSector(msn, Pos);

            radius = rad;

            TriggerDestroyRadius = trigrad;

            RadarEffectiveRadius = radar_effective_radius_m;

            OrdnanceRequiredToTrigger_kg = orttkg;
            OrdnanceOnTarget_kg = 0; //stores how much ordinance has been piled on this target
            ObjectsRequiredToTrigger_num = orttn;
            ObjectsDestroyed_num = 0;

            TimetoRepairIfDestroyed_hr = ttr_hr;
            Destroyed = false;
            DestroyedPercent = 0;
            ObjectiveAchievedForPoints = false;
            TimeToUndestroy_UTC = null;
            LastHitTime_UTC = null;

            Scouted = false;
            lastScoutedPos = Pos;
            lastScoutedSector = Sector;
            PlayersWhoScoutedNames = new Dictionary<string, int>();
            PlayersWhoContributedNames = new HashSet<string>();

            hasGeneralStaff = false;

            IsPrimaryTarget = false;
            PrimaryTargetWeight = primary_target_weight;
            Comment = comment;


        }
        public bool hasChief()
        {
            if (ChiefName != null && ChiefName.Length > 0) return true;
            return false;
        }

        //If the objective has an associated Chief then we can use that to find it's actual position for scouting/recon purposes
        public Point3d returnCurrentPosWithChief()
        {
            try
            {
                Point3d pos = Pos; //Some objectives move now, possibly every time the mission restarts, so this records & savesthe current position/sector at the time scouted.  It will report this until re-scouted

                //Now see if it is a _chief type (mobile) objective and if so, update recon position according to that.
                if (ChiefName != null && ChiefName.Length > 0)
                {
                    List<AiActor> actorList = msn.GetActorsByNameMatch(ChiefName);
                    if (actorList != null && actorList.Count > 0) foreach (AiActor a in actorList)
                        {
                            if ((a as AiActor) != null)
                            {
                                pos = a.Pos();
                                //Console.Write("MO: Got Objective pos by CHIEF {0:N0} {1:N0}", pos.x, pos.y);
                                break;
                            }
                        }
                }

                return pos;

            } catch (Exception ex) { Console.WriteLine("returnCurrentPosWithChief ERROR: " + ex.ToString()); return Pos; }
        }

        //Elevation is an estimate, rounded, gets closer as the more times scouted
        //Elevation is in meters for Blue, feet for Red.  Confusing.
        private void estimateElevationXnumtimesScouted()
        {
            double elev = lastScoutedPos.z;
            Point3d tempPos = lastScoutedPos;
            int remainder;
            int roundTo = 85 - numTimesScouted * 20;
            if (OwnerArmy == 1) roundTo *= 3; //meters to feet, but want to stick with round #s
            if (roundTo < 0) return;

            elev = Math.DivRem(Convert.ToInt32(elev), roundTo, out remainder ) * roundTo;            
            tempPos.z = elev;
            lastScoutedPos = tempPos;
        }

        //If the objective has an associated Chief then we can use that to find it's actual position for scouting/recon purposes
        public void updateCurrentReconPosWithChief()
        {
            lastScoutedPos = Pos; //Some objectives move now, possibly every time the mission restarts, so this records & savesthe current position/sector at the time scouted.  It will report this until re-scouted
            lastScoutedSector = Sector;

            try
            {
                //Now see if it is a _chief type (mobile) objective and if so, update recon position according to that.
                if (ChiefName.Length > 0)
                {
                    List<AiActor> actorList = msn.GetActorsByNameMatch(ChiefName);
                    Console.WriteLine("update recon pos: {0} {1}", ChiefName, actorList.Count);
                    if (actorList.Count == 0)
                    {
                        //lastScoutedPos = new Point3d(-1, -1, -1);
                        string addStr = " <Unit dead??>";
                        if (!lastScoutedSector.Contains(addStr)) lastScoutedSector += addStr; //If we get noresult we're not sure if the unit has all been KILLED or if there was a mistake of some kind entering the Chief name...
                                                                                                        //So instead of replacing the whole pos/sector with nothing, we leave it at it's default with this little note.
                    }
                    else
                    {
                        if (actorList[0] == null) return;
                        Point3d tempPos = actorList[0].Pos();
                        tempPos.z = Calcs.LandElevation_m(tempPos);
                        lastScoutedPos = tempPos;
                        lastScoutedSector = Calcs.correctedSectorNameDoubleKeypad(msn, lastScoutedPos);
                    }
                }

            } catch (Exception ex) { Console.WriteLine("updateCurrentReconPosWithChief ERROR: " + ex.ToString()); }

        }

        public void makeScouted(Player player)
        {
            Scouted = true;
            numTimesScouted++;
            //lastTimeScouted_hist_dt = msn.showTimeLeft().Item2;//this is a cool idea but there are some issues, for example if we run a mission today until 8pm and then start again it will be 4:30 am **the same day**
            lastTimeScouted_dt = DateTime.UtcNow;
            if (IsEnabled)
            {
                Point3d oldLastScoutedPos = lastScoutedPos;
                //lastScoutedPos = Pos; //Some objectives move now, so this records & savesthe current position/sector at the time scouted.  It will report this until re-scouted
                //lastScoutedSector = Sector;
                //New: updates position of objective, taking into consideration the possibility the objective is a _Chief that moves during the mission
                updateCurrentReconPosWithChief();
                estimateElevationXnumtimesScouted();
                if (numTimesScouted > 1 && !Calcs.Point3dEqualXY(oldLastScoutedPos, lastScoutedPos)) lastScoutedSector += "!!moved!!";
            } else //for disabled objectives (generally those scouted earlier but now re-scouted and disabled) 
            {
                lastScoutedPos = new Point3d(-1, -1, -1); //Some objectives move now, so this records & savesthe current position/sector at the time scouted.  It will report this until re-scouted
                lastScoutedSector = "[Scouted earlier but not found in latest recon of " + Calcs.correctedSectorName(msn, Pos) + "!]";
            }

            if (player == null || player.Name() == null) return;
            PlayersWhoContributedNames.Add(player.Name());
            if (PlayersWhoScoutedNames.ContainsKey(player.Name())) return; //they're already in the list
            //PlayersWhoScoutedNames

            PlayersWhoScoutedNames[player.Name()] = PlayersWhoScoutedNames.Count; //Add them to the list of players who have scouted; So 0 for the first player to scout, 1 for the 2nd, etc

        }
        public void makeScoutedFromBombRun(Player player)
        {
            DateTime now_dt= DateTime.UtcNow;
            if (!lastTimeScouted_dt.HasValue || lastTimeScouted_dt.Value.AddMinutes(15) < now_dt) //do this only if the obj hasn't been scouted before, OR scouted before but more than 15 mins ago.
            {
                if (!IsEnabled)
                {
                    msn.GamePlay.gpHUDLogCenter(new Player[] { player }, Name + " has been abandoned or moved!");
                    msn.GamePlay.gpLogServer(new Player[] { player }, "You bombed " + Name + " - but it appears to have been abandoned or moved.  Check the scouted objectives report.", null);
                }
                makeScouted(player);
            }            
        }
        public void makeScoutedFromHit(Point3d pos, Player player)
        {
            if (Calcs.CalculatePointDistance(pos, Pos) > 2000) return; //only do this if hit is less than 2km from the objective.
            DateTime now_dt = DateTime.UtcNow;
            if (!lastTimeScouted_dt.HasValue || lastTimeScouted_dt.Value.AddMinutes(15) < now_dt) //do this only if the obj hasn't been scouted before, OR scouted before but more than 15 mins ago.
            {
                if (!IsEnabled && player != null)
                {
                    msn.GamePlay.gpHUDLogCenter(new Player[] { player }, Name + " has been abandoned or moved!");
                    msn.GamePlay.gpLogServer(new Player[] { player }, "You bombed " + Name + " - but it appears to have been abandoned or moved.  Check the scouted objectives report.", null);
                }
                makeScouted(player);
            }
        }

        public bool isMobile()
        {
            if ((this.MOMobileObjectiveType != null && this.MOMobileObjectiveType != MO_MobileObjectiveType.None)) return true;
            else return false;
        }

        public string ToString(bool misformat = true)
        {
            //MissionObjective mo;

            if (misformat)
            {
                return "  " + TriggerName + " " + TriggerType + " " + TriggerPercent + " " + Pos.x + " " + Pos.y + " " + TriggerDestroyRadius;
            }
            else
            {
                string sn = ""; if (StaticNames != null && StaticNames.Count > 1) sn = string.Join(",", StaticNames);
                string srn = ""; if (StaticRemoveNames != null && StaticRemoveNames.Count > 1) sn = string.Join(",", StaticRemoveNames);
                /*return ID + " " + Name + " " + AttackingArmy.ToString() + " " + OwnerArmy.ToString() + " " + IsEnabled.ToString() + " " + MOObjectiveType.ToString() + " " + MOTriggerType + " " + IsPrimaryTarget.ToString() + " "
                + PrimaryTargetWeight.ToString() + " " + Points.ToString() + " " + Destroyed.ToString() + " " + Pos.x.ToString() + " " + Pos.y.ToString() + " " + Sector + " " + RadarEffectiveRadius.ToString() + " " + TriggerName + " "
                + TriggerType + " " + TriggerPercent.ToString() + " " + TriggerDestroyRadius.ToString() + " " + StaticPercentageRequired.ToString() + " " + StaticRemoveDelay_sec.ToString() + " " + StaticRemoveSpread_sec.ToString() + " "
                +Comment + " " + HUDMessage + " " + LOGMessage
                + " " + sn + " " + srn;*/

                return ID + "\t" + Name + "\t" + AttackingArmy.ToString() + "\t" + OwnerArmy.ToString() + "\t" + IsEnabled.ToString() + "\t" + MOObjectiveType.ToString() + "\t" + MOTriggerType + "\t" + IsPrimaryTarget.ToString() + "\t"
                    + PrimaryTargetWeight.ToString() + "\t" + Points.ToString() + "\t" + "Destroyed: " + Destroyed.ToString() + "\t" + "Scouted: " + Scouted.ToString() + "\t" + Pos.x.ToString() + "\t" + Pos.y.ToString() + "\t" + Sector + "\t" + RadarEffectiveRadius.ToString() + "\t" + TriggerName + "\t"
                    + TriggerType + "\t" + TriggerPercent.ToString() + "\t" + TriggerDestroyRadius.ToString() + "\t" + StaticPercentageRequired.ToString() + "\t" + StaticRemoveDelay_sec.ToString() + "\t" + StaticRemoveSpread_sec.ToString() + "\t"
                    + Comment + "\t" + HUDMessage + "\t" + LOGMessage
                    + "\t" + sn + "\t" + srn;

            }

        }
    }

    //List<MissionObjective> BlueDestroyedRadar = new List<MissionObjective>();

    public class MissionObjectives
    {
        private Mission msn;
        private maddox.game.IGamePlay gp;
        public Dictionary<string, string> FlakMissions = new Dictionary<string, string>();
        public Dictionary<string, string> Airfield_to_FlakMissions = new Dictionary<string, string>();
        //public TWCTobrukCampaignMissionObjectives twc_tobruk_campaign_mission_objectives; //moved this to main Mission class as it seems more logical there (needed EARLY in startup)

        public MissionObjectives(Mission mission, maddox.game.IGamePlay gameplay)
        {
            try
            {
                Console.WriteLine("MissionObjectives initializing...");
                msn = mission;
                gp = gameplay;

                bool[] loadPreviousMission_success = new bool[] { false, false, false, false, false, false };
                bool loadingFromDiskOK = false;
                try
                {
                    loadPreviousMission_success = msn.MO_ReadMissionObjects();
                }
                catch (Exception ex)
                {
                    Console.WriteLine("MissionObjectives: File Read problem on startup!!  Using defaults. Error message: " + ex.ToString());
                    loadPreviousMission_success = new bool[] { false, false, false, false, false, false }; //loadPreviousMission_success = false;
                }

                try
                {
                    msn.twc_tobruk_campaign_mission_objectives.UpdateMissionObjectives(this); //when we first initialize twc_tobruk_campaign_mission_objectives mission_objectives is not yet initialized, so we can't pass it.
                    Console.WriteLine("TTCMO updated MissionObjectives");

                }
                catch (Exception ex)
                {
                    Console.WriteLine("twc_tobruk_campaign_mission_objectives.UpdateMissionObjectives ERROR: " + ex.ToString());
                }

                try
                {
                    msn.twc_tobruk_campaign_mission_objectives.FlakDictionariesSetup();
                    Console.WriteLine("TTCMO updated FlakDictionaries");
                }
                catch (Exception ex)
                {
                    Console.WriteLine("twc_tobruk_campaign_mission_objectives.FlakDictionariesSetup ERROR: " + ex.ToString());
                }


                if (!loadPreviousMission_success[0] || !loadPreviousMission_success[3] || !loadPreviousMission_success[4] || !loadPreviousMission_success[5])
                {   //If we couldn't load the old file we have little choice but to just  start afresh [0]
                    //we couldn't read the current score [3], the list of objectives completed [4] or the full list of objectives  [5] we could just
                    //reconstruct those.  But for now if we lose them we'll just re-start everythign from scratch.
                    Console.WriteLine("File Read problem #2 on startup!!  Using defaults.");
                    msn.MissionObjectivesList = new Dictionary<string, MissionObjective>();  //zero out the mission objectives list (otherwise when we run the routine below they will ADD to anything already there)

                    try
                    {
                        msn.twc_tobruk_campaign_mission_objectives.BumRushCampaignValuesSetup();
                        msn.twc_tobruk_campaign_mission_objectives.RadarPositionTriggersSetup();
                        //RadarPositionTriggersSetup();
                        msn.twc_tobruk_campaign_mission_objectives.MissionObjectiveTriggersSetup();
                        //MissionObjectiveTriggersSetup();
                        Console.WriteLine("TTCMO loaded bumrush, radar, objective dictionaries (1)");
                        msn.MO_MissionObjectiveAirfieldsSetup(mission, gameplay, addNewOnly: false); //must do this after the Radar & Triggers setup, as it uses info from those objectives
                        msn.twc_tobruk_campaign_mission_objectives.MissionObjectiveAirfieldFocusBumrushSetup(); //must always be done right AFTER MO_MissionObjectiveAirfieldsSetup as it tweaks the airfields setup
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("twc_tobruk_campaign_mission_objectives SETUP MAJOR ERROR: " + ex.ToString());
                    }

                }
                else
                {
                    loadingFromDiskOK = true;

                    //RESET PRIMARY OBJECTIVES (so they can be re-read from the .ini file, reset, or whatever, down below)

                    msn.updateMissionObjectivesListOnReload(this); //We reloaded the MissionObjectivesList from disk, but if we have added or removed objectives OR changed or added fields in MissionObjective then the loaded-from-disk data will by out of sync with the changes we have made.  This updates MissionObjectivesList to reflect what is in the .cs file now, and initialize everything properly, but transfers any important data (mo.Destroyed, Mo.DestroyedPercent etc) from the saved-to-disk version to the current running version. 

                    //Now we have to pick up any NEW triggers or objectives that have been added to -main.cs since the last run
                    //RadarPositionTriggersSetup(addNewOnly: true); // now done by updateMissionObjectivesListOnReload();
                    //MissionObjectiveTriggersSetup(addNewOnly: true); // now done by updateMissionObjectivesListOnReload();

                    //msn.MO_MissionObjectiveAirfieldsSetup(mission, gameplay, addNewOnly: true); //does a bunch of airfield setup, adds new objectives; must do this after the Radar & Triggers setup, as it uses info from those objectives // now done by updateMissionObjectivesListOnReload();

                }

                if (!loadPreviousMission_success[1])
                {
                    Console.WriteLine("Failed to load Suggested Objectives - generating them fresh.");
                    SelectSuggestedObjectives(ArmiesE.Red);
                    SelectSuggestedObjectives(ArmiesE.Blue);
                }

                //Get new objectives for winner if they have turned the map OR read in the old objectives if not
                /* //no more winner stuff on session start; it all happens rolling.
                if (msn.MapPrevWinner == "Red")
                {
                    Console.WriteLine("RED turned the map last time - giving reward, selecting new objectives");
                    msn.MO_MissionObjectiveWinnersReward(ArmiesE.Red); //clear all destroyed radar, airfields, scouted objects, current primary objectives scored, for winner; 
                    msn.MO_SelectPrimaryObjectives(1, 0, fresh: true);
                    msn.MO_ReadPrimaryObjectives(2);
                    SelectSuggestedObjectives(ArmiesE.Red);
                }
                else if (msn.MapPrevWinner == "Blue")
                {
                    Console.WriteLine("BLUE turned the map last time - giving reward, selecting new objectives");
                    msn.MO_MissionObjectiveWinnersReward(ArmiesE.Blue); //clear all destroyed radar, airfields, scouted objects, current primary objectives scored, for winner; 
                    msn.MO_SelectPrimaryObjectives(2, 0, fresh: true);
                    msn.MO_ReadPrimaryObjectives(1);
                    SelectSuggestedObjectives(ArmiesE.Blue);
                }
                else
                */

                {
                    msn.MO_ReadPrimaryObjectives(2);
                    msn.MO_ReadPrimaryObjectives(1);
                    //SuggestedObjectives for both armies are read in via the .ini file
                }
                //this will go through all objectives (except airports) & disable any that need to be disabled, add any new ones in the .cs file, etc
                //needs to be done AFTER winner stuff is done this puts smoke on damaged objectives and other things that will be changed if the winner's rewards have not yet happened
                //adds destroyed radars to the DestroyedRadars list, etc.
                //Only exception is AIRFIELDS because they have their own special way of handling them.
                msn.MO_MissionObjectiveOnStartCheck(msn, gp);

                try
                {
                    msn.MO_HandleGeneralStaffPlacement();
                }
                catch (Exception ex) { Console.WriteLine("MO_init error1! " + ex.ToString()); }
                //Now write the new objective list to file
                try
                {
                    msn.MO_WritePrimaryObjectives();
                }
                catch (Exception ex) { Console.WriteLine("MO_init error2! " + ex.ToString()); }
                //Must select suggested/secondary objectives AFTER loading/choosing the primary objectives - otherwise we might end up with some items on both lists                        

                //msn.MO_WriteMissionObjects();
                //Thread.Sleep(1000); //For testing purposes, not really the best way to do it.

                try
                {
                    //load the flak for the areas that have primary objectives
                    msn.MO_LoadAllPrimaryObjectiveFlak(FlakMissions);
                }
                catch (Exception ex) { Console.WriteLine("MO_init error3! " + ex.ToString()); }

                try
                {
                    msn.MO_InitializeAllObjectives();
                }
                catch (Exception ex) { Console.WriteLine("MO_init error3a! " + ex.ToString()); }


                //Write list of triggers to a file in simulated .mis format so that it is easy to verify all triggers have been read in similar
                //to the .mis file
                try
                {
                    msn.MO_WriteOutAllMissionObjectives(msn.MISSION_ID + "-mission_objectives_mis_format.txt", true);
                }
                catch (Exception ex) { Console.WriteLine("MO_init error4! " + ex.ToString()); }
                try
                {
                    msn.MO_WriteOutAllMissionObjectives(msn.MISSION_ID + "-mission_objectives_complete.txt", false);
                }
                catch (Exception ex) { Console.WriteLine("MO_init error5! " + ex.ToString()); }
            }
            catch (Exception ex) { Console.WriteLine("MO_init ERROR (overall initializer)! " + ex.ToString()); }
        }

        //few little sanity checks on the objective data
        public bool MO_SanityChecks(string tn, string n, MO_TriggerType mtt)
        {
            if (msn.MissionObjectivesList.Keys.Contains(tn))
            {
                Console.WriteLine();
                Console.WriteLine("*************MissionObjective initialize WARNING****************");
                Console.WriteLine("MissionObjective initialize: Objective Trigger ID " + tn + " : " + n + " IS DUPLICATED in the .cs file.  This duplicate occurence will be ignored.");
                Console.WriteLine();
                return false;
            }
            if (mtt == MO_TriggerType.Trigger)
            {
                if (gp == null)
                {
                    Console.WriteLine();
                    Console.WriteLine("*************MissionObjective initialize WARNING****************");
                    Console.WriteLine("gp is null!");
                    Console.WriteLine();

                }
                if (gp.gpGetTrigger(tn) == null)
                {
                    Console.WriteLine();
                    Console.WriteLine("*************MissionObjective initialize WARNING****************");
                    Console.WriteLine("MissionObjective initialize: Objective Trigger " + tn + " : " + n + " DOES NOT EXIST in the MAIN .mis file. It may exist in a sub-mission file; please verify.");
                    Console.WriteLine();
                    //return false;
                    //OK, so now we can include triggers from sub-mission files we can't check this so easily!  So we'll have to check by hand.
                }
                /*
                 * //Turning this off for now as it seems useless?  Not sure what .Enable == false means?
                if (gp.gpGetTrigger(tn) != null && gp.gpGetTrigger(tn).Enable !=null && gp.gpGetTrigger(tn).Enable == false )
                {                
                    Console.WriteLine("MissionObjective initialize: WARNING: Objective Trigger " + tn + " : " + n + " .Enable=false; including it in the mission objective list nevertheless.");
                    return true;
                    //Just because it is disabled doesn't mean we can't include it in our objectives list.  Maybe it will be enabled later or whatever.
                    //Not even really sure what .Enable == false or .Enable == null means?
                }*/
            }
            return true;

        }
        //Trigger-style radar objective, using CloD built-in triggers
        public void addRadar(string obj_name, string flak, int ownerarmy, double pts, double repair_days, string obj_ID, string mission_trigger_type, double trigger_percent, double x, double y, double d, double e, bool pt, double ptp = 100, string comment = "", bool addNewOnly = false)
        {
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(obj_ID))
            {
                if (!MO_SanityChecks(obj_ID, obj_name, MO_TriggerType.Trigger)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                msn.MissionObjectivesList.Add(obj_ID, new MissionObjective(msn, obj_ID, obj_name, flak, ownerarmy, pts, repair_days, mission_trigger_type, trigger_percent, x, y, d, e, pt, ptp, comment));
                // public MissionObjective(Mission m, string objectiveKey, string objectiveName, string flak, int ownerarmy, double pts, double repairdays, double trigger_percent, double x, double y, double trigger_destroy_radius, double radar_effective_radius, bool is_primary_target, double primary_target_weight, string comment, MO_ObjectiveType MObjType = MO_ObjectiveType.Radar, MO_TriggerType MOTrigType = MO_TriggerType.Trigger, string initSub="", double orttkg = 100, double orttn = 2)
            }
        }
        //PointArea style radar target.
        public void addRadarPointArea(string objectiveName, string flak, int ownerarmy, double points, double repair_days, string targetKey, string initSub, double orttkg, double orttn, double x, double y, double siteRadius_m, double RadarEffectiveRadius_m, bool isPrimaryTarget, double primaryTargetWeight = 100, string comment = "", bool addNewOnly = false)
        {
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(targetKey))
            {
                if (!MO_SanityChecks(targetKey, objectiveName, MO_TriggerType.PointArea)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                //msn.MissionObjectivesList.Add(targetKey, new MissionObjective(msn, targetKey, objectiveName, flak, ownerarmy, points, repair, missionTriggerType, percentToKill, x, y, siteRadius_m, RadarEffectiveRadius_m, isPrimaryTarget, primaryTargetWeight, comment));
                //initsub t, p
                double numTargets = 0;
                GroundStationary[] gs = gp.gpGroundStationarys(x, y, siteRadius_m);
                if (gs != null) numTargets = gs.Length;
                int targetsRequired = Convert.ToInt32((Math.Floor(numTargets * 0.8))); // require 80% of the groundstationaries in the target area.  This should be quite hard.

                //NOTE!!!! Ignoring the given ortgg for now & just using 80% of the existing targets in the area.

                msn.MissionObjectivesList.Add(targetKey, new MissionObjective(msn, targetKey, objectiveName, flak, ownerarmy, points, repair_days, "PointArea", 100, x, y, siteRadius_m, RadarEffectiveRadius_m, isPrimaryTarget, primaryTargetWeight, comment, MObjType: MO_ObjectiveType.Radar, MOTrigType: MO_TriggerType.PointArea, initSub: initSub, orttkg: orttkg, orttn: targetsRequired));
                //msn.MissionObjectivesList.Add(tn, new MissionObjective(msn, mot, tn, n, flak, initSub, ownerarmy, pts, x, y, rad, trigrad, orttkg, ortt, ptp, ttr_hours, af, afip, fb, fnib, comment));
                ////public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double largearearadius = 100, double smallercentertargettrigrad=300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool af, bool afip, int fb, int fnib, string comment = "", bool addNewOnly = false)
            }
        }

        public void addTrigger(MO_ObjectiveType mot, string n, string flak, string submissionfile, string chiefname, int ownerarmy, double pts, string tn, string t = "", double p = 50, double x = 0, double y = 0, double d = 100, bool pt = false, double ptp = 100, double ttr_hours = 24, string comment = "", bool addNewOnly = false)
        {
            //Console.WriteLine("Adding Trigger pre " + tn + n + " " + pts.ToString());

            //Console.WriteLine("Adding Trigger post1 " + tn + n + " " + pts.ToString());
            //MissionObjective                                    (Mission m, MO_ObjectiveType mot,  string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, bool ptp, string comment)
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(tn))
            {
                if (!MO_SanityChecks(tn, n, MO_TriggerType.Trigger)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                Console.WriteLine("Adding Trigger post2 " + tn + n + " " + pts.ToString());
                if (ownerarmy == 1 && x > 210000 && y > 180000 && x < 321000 && y < 270000) ptp *= 1.4; //vastly increase proportion of mission objectives in 'primary' campaign area, and reduce others, for Blue 2020-01
                else ptp *= 0.8;
                msn.MissionObjectivesList.Add(tn, new MissionObjective(msn, mot, tn, n, flak, submissionfile, chiefname, ownerarmy, pts, t, p, x, y, d, pt, ptp, ttr_hours, comment));
            }
        }
        public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double rad = 100, double trigrad = 300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool auto_flak = true, bool auto_flak_ifprimary = true, int flak_numbatteries = 7, int flak_numbinbattery = 8, string comment = "", bool addNewOnly = false)
        {
            //Console.WriteLine("Adding Trigger pre " + tn + n + " " + pts.ToString());

            //Console.WriteLine("Adding Trigger post1 " + tn + n + " " + pts.ToString());
            //MissionObjective                                    (Mission m, MO_ObjectiveType mot,  string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, bool ptp, string comment)
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(tn))
            {
                if (!MO_SanityChecks(tn, n, MO_TriggerType.PointArea)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                Console.WriteLine("Adding pointarea post2 " + tn + n + " " + pts.ToString());
                msn.MissionObjectivesList.Add(tn, new MissionObjective(msn, mot, tn, n, flak, initSub, ownerarmy, pts, x, y, rad, trigrad, orttkg, ortt, ptp, ttr_hours, auto_flak, auto_flak_ifprimary, flak_numbatteries, flak_numbinbattery, comment));
            }
        }

        //public MissionObjective(Mission m, string objective_id, Point3d pos, double radius_m, double objective_points, double primaryobjective_weight, double timeToRemainActive_hrs, string flak_file, int ownerarmy, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "")
        public void addLandingGround(string objective_id, string name, Point3d pos, double radius_m, double objective_points, double primaryobjective_weight, double timeToRemainActive_hrs, string flak_file, int ownerarmy, bool auto_flak = true, bool auto_flak_ifprimary = true, int flak_numbatteries = 2, int flak_numberinbattery = 2, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "",  string comment = "", bool addNewOnly = false)

        //public MissionObjective(Mission m, string objective_id, string name, Point3d pos, double radius_m, double objective_points, double primaryobjective_weight, double timeToRemainActive_hrs, string flak_file, int ownerarmy, bool auto_flak = true, bool auto_flak_ifprimary = true, int flak_numbatteries = 7, int flak_numberinbattery = 8, MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None, string chief_name = "")
        {
            //Console.WriteLine("Adding Trigger pre " + tn + n + " " + pts.ToString());

            //Console.WriteLine("Adding Trigger post1 " + tn + n + " " + pts.ToString());
            //MissionObjective                                    (Mission m, MO_ObjectiveType mot,  string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, bool ptp, string comment)
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(objective_id))
            {
                if (!MO_SanityChecks(objective_id, objective_id, MO_TriggerType.TemporaryLandingGround)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                Console.WriteLine("Adding LandingGround post2 " + objective_id + " " + name + " " + objective_points.ToString());
                msn.MissionObjectivesList.Add(objective_id, new MissionObjective(m: msn, objective_id: objective_id, name: name, pos: pos, radius_m: radius_m, 
                    objective_points:objective_points, primaryobjective_weight:primaryobjective_weight, 
                    timeToRemainActive_hrs: timeToRemainActive_hrs, flak_file: flak_file, ownerarmy: ownerarmy, 
                    auto_flak: auto_flak, auto_flak_ifprimary: auto_flak_ifprimary = true, flak_numbatteries: flak_numbatteries, 
                    flak_numberinbattery: flak_numberinbattery, MOProdStorType: MOProdStorType, chief_name: chief_name));
            }
        }
        public void addMobile(MO_ObjectiveType mot, string n, string flak, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double rad = 100, double trigrad = 300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool auto_flak = true, bool auto_flak_ifprimary = true, int flak_numbatteries = 7, int flak_numberinbattery = 8, MO_MobileObjectiveType MobObjType = MO_MobileObjectiveType.ArmyEncampment,
            double mob_hrsbetweenMoves = 12, double x_sw = 0, double y_sw = 0, double x_ne = 360000, double y_ne = 360000,
            double min_move_dist_km = 2,
            double max_move_dist_km = 5,
            MO_ProducerOrStorageType ProdStorType = MO_ProducerOrStorageType.None, 
            string comment = "", bool addNewOnly = false, double radar_effective_radius_m = 20000)
        {
            //Console.WriteLine("Adding Trigger pre " + tn + n + " " + pts.ToString());

            //Console.WriteLine("Adding Trigger post1 " + tn + n + " " + pts.ToString());
            //MissionObjective                                    (Mission m, MO_ObjectiveType mot,  string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, bool ptp, string comment)
            //Add the item -always when add==false and if it doesn't already exist, when add==true
            if (!addNewOnly || !msn.MissionObjectivesList.ContainsKey(tn))
            {
                if (!MO_SanityChecks(tn, n, MO_TriggerType.PointArea)) return; //sanity checks - we're skipping many items with the IF statement, so no need for sanity check before this point
                Console.WriteLine("Adding Mobile post2 " + tn + n + " " + pts.ToString());
                //msn.MissionObjectivesList.Add(tn, new MissionObjective(msn, mot, tn, n, flak, initSub, ownerarmy, pts, x, y, rad, trigrad, orttkg, ortt, ptp, ttr_hours, auto_flak, auto_flak_ifprimary, flak_numbatteries, flak_numberinbattery, comment));
                msn.MissionObjectivesList.Add(tn, new MissionObjective(msn, mot, tn, n, flak, ownerarmy, pts, x, y, rad, trigrad, orttkg, ortt, ptp, ttr_hours, auto_flak, auto_flak_ifprimary, flak_numbatteries, flak_numberinbattery, MobObjType, mob_hrsbetweenMoves, new Point3d(x_sw, y_sw, 0), new Point3d(x_ne, y_ne, 0), min_move_dist_km, max_move_dist_km, ProdStorType, comment, radar_effective_radius_m: radar_effective_radius_m));
            }
        }

        /*
         public MissionObjective(Mission m, MO_ObjectiveType objective_type, string objective_ID, string objective_name, string flak, string init_submission_filename, int ownerarmy, 
            double points, double x, double y, double rad, double trigrad, double orttkg, double orttn, double primary_target_weight, double ttr_hr, bool auto_flak, bool auto_flak_ifprimary, 
            int num_flakbatteries, int num_in_eachbattery, string comment,
            MO_MobileObjectiveType mobile_objective_type,
            double mobile_hours_between_moves,
            Point3d mobile_SW_point,
            Point3d mobile_NE_point,
            MO_ProducerOrStorageType MOProdStorType = MO_ProducerOrStorageType.None)
         * */

        //public MissionObjective(Mission m, MO_ObjectiveType mot, string tn, string n, string flak, int ownerarmy, double pts, string t, double p, double x, double y, double rad, double trigrad, double orttkg, double ortt, bool pt, double ptp, double ttr_hr, string comment)

        //Flak field loads the corresponding flack file = large dictionary with name--->filename elsewhere
        //add=true means, we already loaded the triggers back from disk, but run through them & add any new ones from this list not already there.
        public void RadarPositionTriggersSetup(bool addNewOnly = false)
        {

            bool add = addNewOnly;
            //ID is the ID used in the [Trigger] portion of the .mis file. The central portion of the line can be copy/pasted from the  .mis file (then lightly edited)
            //Console.Write("#1a");

            //MissionObjective(Name,          Flak ID, OwnerArmy,points,ID, Days to repair, Trigger Type,Trigger percentage, location x, location y, trigger radius, radar effective radius, isPrimaryTarget, PrimaryTargetWeight (0-200), comment) {
            //weights change 0-200, many weights below adjusted, 2020-01
            //Prior to 2/15/2020 I had moved most Red Radar trigger % to about 40%.  Then 2/24 moved up to 70% to make it harder.  Now moved to 80% to make it even harder.  2020/02/27.
            //Note that these are in the .mis file.

            /*
            addRadar("Westgate Radar", "WesR", 1, 5, 2, "BTarget14R", "TGroundDestroyed", 39, 244791, 262681, 150, 25000, false, 30, "", add);
            addRadar("Sandwich Radar", "SanR", 1, 5, 2, "BTarget15R", "TGroundDestroyed", 50, 248579, 253159, 200, 25000, false, 30, "", add);
            addRadar("Deal Radar", "DeaR", 1, 5, 2, "BTarget16R", "TGroundDestroyed", 75, 249454, 247913, 200, 25000, false, 30, "", add);
            addRadar("Dover Radar", "DovR", 1, 5, 2, "BTarget17R", "TGroundDestroyed", 75, 246777, 235751, 200, 25000, false, 30, "", add);
            addRadar("Brookland Radar", "BroR", 1, 5, 2, "BTarget18R", "TGroundDestroyed", 75, 212973, 220079, 200, 25000, false, 30, "", add);
            addRadar("Dungeness Radar", "DunR", 1, 5, 2, "BTarget19R", "TGroundDestroyed", 50, 221278, 214167, 200, 25000, false, 30, "", add);
            addRadar("Eastbourne Radar", "EasR", 1, 5, 2, "BTarget20R", "TGroundDestroyed", 75, 178778, 197288, 200, 25000, false, 10, "", add);
            addRadar("Littlehampton Radar", "LitR", 1, 5, 2, "BTarget21R", "TGroundDestroyed", 76, 123384, 196295, 200, 35000, false, 10, "", add);
            addRadar("Ventnor Radar", "VenR", 1, 5, 2, "BTarget22R", "TGroundDestroyed", 75, 70423, 171706, 200, 35000, false, 10, "", add);
            addRadar("Radar Communications HQ", "HQR", 1, 11, 3, "BTarget28", "TGroundDestroyed", 61, 180207, 288435, 200, 350000, false, 5, "", add);
            addRadar("Radar Poole", "PooR", 1, 6, 2, "BTarget23R", "TGroundDestroyed", 75, 15645, 170552, 200, 35000, false, 5, "", add);

            //public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double largearearadius = 100, double smallercentertargettrigrad=300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool af, bool afip, int fb, int fnib, string comment = "", bool addNewOnly = false)
            //addPointArea(MO_ObjectiveType.Building, "Dover Naval HQ", "Dove", "", 1, 3, "BTargDoverNavalOffice", 245567, 233499, 50, 50, 800, 4, 120, 48, true, true, 4, 7, "", add);
            //NOTE: renaming the radar targets as "RPA in stead of just "R" so they no longer match the .mis file trigger names (which WILL still trigger if they are still in the file).
            addRadarPointArea("Oye Plage Freya Radar", "OypR", 2, 4, 2, "RTarget28RPA", "", 1000, 4, 294183, 219444, 85, 20000, false, 35, "", add);
            addRadarPointArea("Coquelles Freya Radar", "CoqR", 2, 4, 2, "RTarget29RPA", "", 1000, 4, 276566, 214150, 85, 20000, false, 35, "", add);
            addRadarPointArea("Dunkirk Radar #2", "DuRN", 2, 4, 2, "RTarget30RPA", "", 1000, 4, 341887, 232695, 85, 20000, false, 35, "", add);
            //    addRadarPointArea("Dunkirk Freya RadaRPA",           "DuRN", 2, 1, 2, "RTarget38RPA",  "", 1000, 4, 77, 339793, 232797,  100, 20000, false, 35, "", add);
            addRadarPointArea("Herderlot-Plage Freya Radar", "HePR", 2, 4, 2, "RTarget39RPA", "", 1000, 4, 264882, 178115, 85, 20000, false, 35, "", add); //Mission in mission file
            addRadarPointArea("Berck Freya Radar", "BrkR", 2, 4, 2, "RTarget40RPA", "", 1000, 4, 263234, 153713, 85, 20000, false, 5, "", add); //Mission in mission file
            //addRadarPointArea("Radar Dieppe", "DieR", 2, 4, 2, "RTarget41RPA",  "", 1000, 4, 232727, 103248, 85, 20000, false, 5, "", add); //This trigger exists in the .mis file but I don't believe there are any actual radars/stationaries in this area at all
            addRadarPointArea("Radar Le Treport", "TreR", 2, 4, 2, "RTarget42RPA", "", 1000, 4, 250599, 116531, 85, 20000, false, 15, "", add); // Mission in mission file
            addRadarPointArea("Radar Somme River", "SomR", 2, 4, 2, "RTarget43RPA", "", 1000, 4, 260798, 131885, 85, 20000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Radar AMBETEUSE", "AmbR", 2, 4, 2, "RTarget44RPA", "", 1000, 4, 266788, 197956, 85, 20000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Radar BOULOGNE", "BlgR", 2, 4, 2, "RTarget45RPA", "", 1000, 4, 264494, 188674, 85, 20000, false, 35, "", add); //Mission in mission file           
            addRadarPointArea("Radar Le Touquet", "L2kR", 2, 4, 2, "RTarget46RPA", "", 1000, 4, 265307, 171427, 85, 20000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Radar Dieppe", "FreR", 2, 5, 2, "RTarget47RPA", "", 1000, 4, 232580, 103325, 85, 20000, false, 15, "", add); //Mission in mission file
            addRadarPointArea("Veulettes-sur-Mer Radar", "VeuR", 2, 5, 2, "RTarget48RPA", "", 1000, 4, 195165, 93441, 85, 20000, false, 5, "", add);//Mission in mission file
            addRadarPointArea("Le Havre Freya Radar", "LhvR", 2, 5, 2, "RTarget49RPA", "", 1000, 4, 157636, 60683, 85, 20000, false, 15, "", add);//Mission in mission file
            addRadarPointArea("Ouistreham Freya Radar", "OuiR", 2, 5, 2, "RTarget50RPA", "", 1000, 4, 135205, 29918, 85, 20000, false, 15, "", add);// Mission in mission file
            addRadarPointArea("Bayeux Beach Freya Radar", "BayR", 2, 5, 2, "RTarget51RPA", "", 1000, 4, 104279, 36659, 85, 20000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Beauguillot Beach Freya Radar", "BchR", 2, 5, 2, "RTarget52RPA", "", 1000, 4, 65364, 43580, 85, 20000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Radar Tatihou", "TatR", 2, 5, 2, "RTarget53RPA", "", 1000, 4, 60453, 63873, 85, 30000, false, 5, "", add); //Mission in mission file
            addRadarPointArea("Radar Querqueville", "QueR", 2, 5, 2, "RTarget54RPA", "", 1000, 4, 17036, 77666, 85, 30000, false, 15, "", add); // Mission in mission file
            addRadarPointArea("Local Radar Wimereux", "", 2, 2, 1.2, "RWimereuxRadar", "", 85, 1, 266719, 193028, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Etaples", "", 2, 2, 1.2, "REtaplesRadar", "", 85, 1, 264833, 166251, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Calais", "", 2, 2, 1.2, "RCalaisRadar", "", 85, 1, 288993, 218087, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Dunkirk", "", 2, 2, 1.2, "RDunkirkRadar", "", 85, 1, 327244, 227587, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Marquise", "", 2, 2, 1.2, "RMarquiseRadar", "", 85, 1, 274709, 201374, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Tripod", "", 2, 2, 1.2, "RTripodRadar", "", 85, 1, 277579, 208243, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Local Radar Wailly-Beaucamp", "", 2, 2, 1.2, "RWaillyBeaucampRadar", "", 85, 1, 277423, 156268, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Ramsgate Local Radar", "", 1, 2, 1.2, "RRamsgateRadar", "", 85, 1, 253029, 259510, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Shoreham Local Radar", "", 1, 2, 1.2, "RShorehamRadar", "", 85, 1, 134312, 197580, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Dover Local Radar", "", 1, 2, 1.2, "RDoverRadar", "", 85, 1, 244253, 233078, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Eastchurch Local Radar", "", 1, 2, 1.2, "REastChurchRadar", "", 85, 1, 218306, 261855, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Bexhill Local Radar", "", 1, 2, 1.2, "RBexhillRadar", "", 85, 1, 190722, 201588, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Bembridge-Sandown Local Radar", "", 1, 2, 1.2, "RBembridgeSandownRadar", "", 85, 1, 72109, 180094, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Gosport Local Radar", "", 1, 2, 1.2, "RGosportRadar", "", 85, 1, 77878, 191392, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Deal Local Radar", "", 1, 2, 1.2, "RDealRadar", "", 85, 1, 250530, 244563, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Canterbury Local Radar", "", 1, 2, 1.2, "RCanterburyRadar", "", 85, 1, 236454, 248239, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            addRadarPointArea("Gravesend Local Radar", "", 1, 2, 1.2, "RGravesendRadar", "", 85, 1, 182026, 266767, 150, 5000, false, 33, "", add); //in -initsubmission-miniRadars.mis
            */

            /*
            addRadar("Oye Plage Freya Radar", "OypR", 2, 4, 2, "RTarget28R", "TGroundDestroyed", 61, 294183, 219444, 100, 20000, false, 35, "", add);
            addRadar("Coquelles Freya Radar", "CoqR", 2, 4, 2, "RTarget29R", "TGroundDestroyed", 63, 276566, 214150, 100, 20000, false, 35, "", add);
            addRadar("Dunkirk Radar #2", "DuRN", 2, 4, 2, "RTarget30R", "TGroundDestroyed", 77, 341887, 232695, 100, 20000, false, 35, "", add);
            //    addRadar("Dunkirk Freya Radar",           "DuRN", 2, 1, 2, "RTarget38R", "TGroundDestroyed", 77, 339793, 232797,  100, 20000, false, 35, "", add);
            addRadar("Herderlot-Plage Freya Radar", "HePR", 2, 4, 2, "RTarget39R", "TGroundDestroyed", 85, 264882, 178115, 100, 20000, false, 35, "", add); //Mission in mission file
            addRadar("Berck Freya Radar", "BrkR", 2, 4, 2, "RTarget40R", "TGroundDestroyed", 86, 263234, 153713, 100, 20000, false, 5, "", add); //Mission in mission file
            //addRadar("Radar Dieppe", "DieR", 2, 4, 2, "RTarget41R", "TGroundDestroyed", 85, 232727, 103248, 100, 20000, false, 5, "", add); //This trigger exists in the .mis file but I don't believe there are any actual radars/stationaries in this area at all
            addRadar("Radar Le Treport", "TreR", 2, 4, 2, "RTarget42R", "TGroundDestroyed", 86, 250599, 116531, 50, 20000, false, 15, "", add); // Mission in mission file
            addRadar("Radar Somme River", "SomR", 2, 4, 2, "RTarget43R", "TGroundDestroyed", 86, 260798, 131885, 50, 20000, false, 5, "", add); //Mission in mission file
            addRadar("Radar AMBETEUSE", "AmbR", 2, 4, 2, "RTarget44R", "TGroundDestroyed", 86, 266788, 197956, 50, 20000, false, 5, "", add); //Mission in mission file
            addRadar("Radar BOULOGNE", "BlgR", 2, 4, 2, "RTarget45R", "TGroundDestroyed", 85, 264494, 188674, 50, 20000, false, 35, "", add); //Mission in mission file           
            addRadar("Radar Le Touquet", "L2kR", 2, 4, 2, "RTarget46R", "TGroundDestroyed", 66, 265307, 171427, 50, 20000, false, 5, "", add); //Mission in mission file
            addRadar("Radar Dieppe", "FreR", 2, 4, 2, "RTarget47R", "TGroundDestroyed", 99, 232580, 103325, 50, 20000, false, 15, "", add); //Mission in mission file
            addRadar("Veulettes-sur-Mer Radar", "VeuR", 2, 4, 2, "RTarget48R", "TGroundDestroyed", 100, 195165, 93441, 50, 20000, false, 5, "", add);//Mission in mission file
            addRadar("Le Havre Freya Radar", "LhvR", 2, 4, 2, "RTarget49R", "TGroundDestroyed", 100, 157636, 60683, 50, 20000, false, 15, "", add);//Mission in mission file
            addRadar("Ouistreham Freya Radar", "OuiR", 2, 4, 2, "RTarget50R", "TGroundDestroyed", 100, 135205, 29918, 50, 20000, false, 15, "", add);// Mission in mission file
            addRadar("Bayeux Beach Freya Radar", "BayR", 2, 4, 2, "RTarget51R", "TGroundDestroyed", 100, 104279, 36659, 50, 20000, false, 5, "", add); //Mission in mission file
            addRadar("Beauguillot Beach Freya Radar", "BchR", 2, 4, 2, "RTarget52R", "TGroundDestroyed", 100, 65364, 43580, 50, 20000, false, 5, "", add); //Mission in mission file
            addRadar("Radar Tatihou", "TatR", 2, 4, 2, "RTarget53R", "TGroundDestroyed", 77, 60453, 63873, 50, 30000, false, 5, "", add); //Mission in mission file
            addRadar("Radar Querqueville", "QueR", 2, 4, 2, "RTarget54R", "TGroundDestroyed", 100, 17036, 77666, 50, 30000, false, 15, "", add); // Mission in mission file
            */

            /*
            BTarget15R TGroundDestroyed 75 248739 253036 200
            BTarget16R TGroundDestroyed 75 249454 247913 200
            BTarget17R TGroundDestroyed 75 246777 235751 200
            BTarget18R TGroundDestroyed 75 212973 220079 200
            BTarget19R TGroundDestroyed 50 221278 214167 200
            BTarget20R TGroundDestroyed 75 178778 197288 200
            BTarget21R TGroundDestroyed 76 123384 196295 200
            BTarget22R TGroundDestroyed 75 70423 171706 200
            BTarget28 TGroundDestroyed 61 180207 288435 200
  RTarget28R TGroundDestroyed 61 294183 219444 50
  RTarget29R TGroundDestroyed 63 276566 214150 50
  RTarget30R TGroundDestroyed 77 341887 232695 100
  RTarget38R TGroundDestroyed 85 341866 232710 50
  RTarget39R TGroundDestroyed 85 276567 214150 50
  RTarget40R TGroundDestroyed 86 263234 153713 50
  RTarget41R TGroundDestroyed 85 232576 103318 50
  RTarget42R TGroundDestroyed 86 250599 116531 50
  RTarget43R TGroundDestroyed 86 262560 133020 50
  RTarget44R TGroundDestroyed 86 266788 197956 50
  RTarget45R TGroundDestroyed 85 264266 188554 50
  RTarget46R TGroundDestroyed 66 266625 169936 50
  RTarget47R TGroundDestroyed 99 185931 88085 50
  RTarget48R TGroundDestroyed 100 195165 93441 50
  RTarget49R TGroundDestroyed 100 157636 60683 50
  RTarget50R TGroundDestroyed 100 135205 29918 50
  RTarget51R TGroundDestroyed 100 103641 36893 50
  RTarget52R TGroundDestroyed 100 65637 44013 50
  RTarget53R TGroundDestroyed 77 60453 63873 50
  RTarget54R TGroundDestroyed 100 17036 77666 50


            */

        }

        public void MissionObjectiveTriggersSetup(bool addNewOnly = false)
        {
            //2020-09: ALL MISSIONOBJECTIVETRIGGERSSETUP NOW MOVED TO \Battles\Tobruk_Campaign-Class-TWCTobrukCampaignMissionObjectives.cs
            //And various sub-classes of that class.
            //Info below is left simply as documentation/examples
            //

            //Format: addTrigger(MO_ObjectiveType.Building (Aircraft, airport, etc), "Name,                      OwnerArmy,Points,ID,TriggerType,PercRequired,XLoc,YLoc,Radius,IsPrimaryTarget,IsPrimaryTargetWeight,TimeToRepairIfDestroyed_hours,Comment "");
            //PercRequired doesn't actually do anything because the perc required is set in the TRIGGER in the .mis file.  However if you accurately record here the same
            //percent to kill value in the .mis file we can do interesting/helpful things with it here.
            bool add = addNewOnly;
            //BLUE TARGETS

            // addTrigger(MO_ObjectiveType.Building, "Coal mines in Normandy", "Shor", 1, 3, "BTargNormandyMiningCenter", "TGroundDestroyed", 50, 67510, 26083, 50, false, 100, 24, "", add);			
            //addTrigger(MO_ObjectiveType.Building, "Shoreham Submarine Base", "", 1, 3, "BTargShorehamSubmarineBase", "TGroundDestroyed", 10, 137054, 198034, 50, false, 120, 24, "", add);           




            //RED TARGETS
            //addTrigger(MO_ObjectiveType.Vehicles, "Bapaume Rail Transit Station", "Bapu", ".mis file to load if this objective is active", "1009_Chief or similar name used in the .mis file if you want RECON to be able to locate it while moving", 2, 8, "RTarget0", "TGroundDestroyed", 83, 354623, 121058, 100, false, 100, 24, "", add);  //g

            //So, in Desert Wings/CLOD 5.003 the ships just don't work.  They turn upside down, they fly, they are generally not well behaved.
            //So since these are already in placed, working, tested, I'm leaving these objectives in as possible secondary objectives etc but in general we'll just ignore them.
            /*
            addTrigger(MO_ObjectiveType.Ship, "Tobruk Tanker", "Tobr", "", "", 2, 2, "RTobrukTanker", "TGroupDestroyed", 100, 172859, 214570, 100, false, 0, 24, "", add);  //g
            addTrigger(MO_ObjectiveType.Ship, "Tobruk Cruiser", "Tobr", "", "", 2, 2, "RTobrukCruiser", "TGroupDestroyed", 100, 172859, 214570, 100, false, 0, 24, "", add);  //g            

            addTrigger(MO_ObjectiveType.Ship, "Sidi Barrani Tanker", "", "", "", 1, 2, "BSidiBarraniTanker", "TGroupDestroyed", 100, 295708, 193686, 100, false, 0, 24, "", add);  //g
            addTrigger(MO_ObjectiveType.Ship, "Sidi Barrani Corvette", "", "", "", 1, 2, "BSidiBarraniCorvette", "TGroupDestroyed", 100, 357990, 237331, 100, false, 0, 24, "", add);  //g            


            //RED & BLUE CONVOY PRIMARY OBJECTIVES.
            //These are in sub-missions and includes Oskar's new code to pass the trigger on to the main mission

            addTrigger(MO_ObjectiveType.Convoy, "Tobruk-Gasr Resupply Convoy", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-RTobrukGasrResupplyConvoy-objective.mis", "1006_Chief", 2, 5, "RTobrukGasrResupplyConvoy", "TGroupDestroyed", 100, 197907, 95422, 100, false, 200, 24, "", add);  //g
            addTrigger(MO_ObjectiveType.Convoy, "Alsmar-Gasr Resupply Convoy", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-RAlsmarGasrResupplyConvoy-objective.mis", "1007_Chief", 2, 5, "RAlsmarGasrResupplyConvoy", "TGroupDestroyed", 100, 150983, 37668, 100, false, 200, 24, "", add);  //g            

            addTrigger(MO_ObjectiveType.Convoy, "Sidi-Scegga Resupply Convoy", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-BSidiSceggaResupplyConvoy-objective.mis", "1010_Chief", 1, 5, "BSidiSceggaResupplyConvoy", "TGroupDestroyed", 100, 327607, 126528, 100, false, 200, 24, "", add);  //g
            addTrigger(MO_ObjectiveType.Convoy, "Siwi-Scegga Resupply Convoy", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-BSiwiSceggaResupplyConvoy-objective.mis", "1008_Chief", 1, 5, "RSiwiSceggaResupplyConvoy", "TGroupDestroyed", 100, 286184, 35204, 100, false, 200, 24, "", add);  //g 
            */
            

            //public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double rad = 100, double trigrad=300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool af, bool afip, int fb, int fnib, string comment = "", bool addNewOnly = false)
            // n is the DESCRIPTIVE NAME for the target--what the player sees
            //rad is the radius-extent to the object itself.  Say an airfield will have a certain radius, or a general industrial area or military base.
            //trigrad is like the center of the bullseye--the radius from the center within which the bombs, killed objectives etc will count THE MOST towards disabling the objective.  Anything outside this radius (but still inside the main radius of the object) won't count as much--but still counts.  Anything inside the radius counts more.  Anything outside both radii counts zero.
            //   - for example you might have an airbase with radius 2500 meters but you want the bombs to hit more in the center of that to count, so you set rad=2500, trigrad=1000.
            // tn is the INTERNAL KEY for the object.  It can be anything you want to identify it to yourself and the computer, but it must be unique (ie,different from ALL OTHER objectives listed here).
            //orttkg = kg of ordnance that must be dumped in this area to knock it out
            //ortt = number of objects (statics, buildings, AiActors like vehicles, trains, whatever) that must be killed within the area to knock it out. Note however that there is a scoring system and for example ships count 8-20 points, artillery/tank 4, planes on the ground 2, bridge 10, trucks/armoured vehicles 2, etc.   See MO_HandlePointAreaObjectives.
            //     - if you set this higher than 0 you MUST have some objects within the radius of the area, preferably the trigger radius, or taking out the objective will be impossible
            //     - AiActors such as vehicles, ships, trains, planes, artillery, etc also count as 'objects' that count towards this goal.  BUT they must be strictly within the radius given.  If they wander outside the radius, they are no longer part of this objective
            //     - Buildings can be counted to a limited extent in the future, but for now they are not (until TF resolves the OnBuildingKilled thing, which currently works for AI but not live players
            //     - You can add objects/actors, etc to the -main.cs file OR to a XXXXMission-initsubmission.mis file, which is loaded by this .cs file right at mission startup.  It is a lot cleaner to keep things in separate submission.mis files.
            //     - Note that you cannot add BUILDINGS in an -initsubmission file.  You can add them in FMB but they don't show up in-game.  However you could add a building in the -main.mis file and then other objects in an -initsubmission.mis file.
            //You can specify orttkg OR ortt OR both - if both, the player must satisfy both conditions to knock out
            //initSub is a submission that will be loaded when the mission starts, if this objective is enabled
            //ptp = primary target weight, ie, 0-200 increase or decrease chance of selection as a primary target.        
            //ttr_hours = time to repair, in hours, if taken out 100%.
            //af = add auto-flak batteries always
            //afip = add auto-flak batteries only if a primary target
            //fb = number of flak batteries to add (if a primary target)
            //fnib = number of guns in each battery (if a primary target)
            //Note that the number of batteries & guns per battery is only used if the objective is a current primary target. Otherwise just a much smaller amount of flak is put in place.
            //That's because too many flak installations seems to bring the server to its knees.
            //public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double largearearadius = 100, double smallercentertargettrigrad=300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool af, bool afip, int fb, int fnib, string comment = "", bool addNewOnly = false)

            /*
            addPointArea(MO_ObjectiveType.MilitaryArea, "Derna Fuel", "Dern", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-DernaFuel-objective.mis", 2, 5, "RTargDernaFuel", 32277, 264622, 200, 150, 1800, 4, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Tobruk Docks Fuel/Ammo Dump", "Tobr", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-TobrukDockFuel2-objective.mis", 2, 5, "RTargTobrukFuel", 160306, 186548, 200, 150, 1800, 2, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Coastal Fuel Dump", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-GermanFuelDump-objective.mis", 2, 5, "RCoastalFuel", 127599, 197411, 200, 150, 1800, 2, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Armor Camp", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Red-GermanArmorCamp-objective.mis", 2, 5, "RArmorCamp", 195633, 122432, 125, 100, 1800, 8, 200, 48, false, true, 3, 7, "", add);


            addPointArea(MO_ObjectiveType.MilitaryArea, "Sidi Barrani Fuel Dump", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-SidiBarraniFuel.mis", 1, 5, "BSidiBarraniFuelDump", 346862, 135133, 150, 125, 1800, 8, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Scegga Armor Camp", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-SceggaBritishArmorCamp-objective.mis", 1, 5, "BSceggaArmorCamp", 263026, 51966, 150, 125, 1800, 8, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Habata Armor Camp", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-HabataBritishArmorCamp-objective.mis", 1, 5, "BHabataArmorCamp", 301770, 89683, 150, 125, 1800, 8, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "BuqBuq Armor Camp", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-BuqBuqBritishArmorCamp-objective.mis", 1, 5, "BBuqBuqArmorCamp", 306575, 116772, 150, 125, 1800, 8, 200, 48, false, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.MilitaryArea, "Awdyat Fuel Dump", "", "PrimaryObjectives/Tobruk_Campaign-LOADONCALL-Blue-AwdyatFuel.mis", 1, 5, "BAwdyatFuelDump", 235348, 27829, 150, 125, 1800, 8, 200, 48, false, true, 3, 7, "", add);
            
            */



            /*
            addPointArea(MO_ObjectiveType.Building, "Dover Naval HQ", "Dove", "", 1, 3, "BTargDoverNavalOffice", 245567, 233499, 50, 50, 800, 4, 120, 48, true, true, 3, 7, "", add);
            addPointArea(MO_ObjectiveType.Building, "Dover Ammo Dump", "Dove", "", 1, 3, "BTargDoverAmmo", 245461, 233488, 50, 50, 800, 4, 120, 48, true, true, 3, 7, "", add);
         
            addPointArea(MO_ObjectiveType.MilitaryArea, "Folkestone Navy Docks Area", "Folk", "Tobruk_Campaign-LOADONCALL-folkestone-naval-docks-objective4.mis", 1, 7, "BTargFolkestoneNavyDocks", 237398, 228979, 700, 600, 7000, 40, 160, 24, true, true, 2, 8, "", add); //Because it's  a dock most bombs hit on "water", thus they don't count.  So it's hard to get a lot of ordnance KG on it.  Rely mostly on static kills for that reason.  NO SHIPS, must reduce count
            //public void addPointArea(MO_ObjectiveType mot, string n, string flak, string initSub, int ownerarmy, double pts, string tn, double x = 0, double y = 0, double rad = 100, double trigrad = 300, double orttkg = 8000, double ortt = 0, double ptp = 100, double ttr_hours = 24, bool af = true, bool afip = true, int fb = 7, int fnib = 8, string comment = "", bool addNewOnly = false)

            //246653, 233348, 800, 750, 
            addPointArea(MO_ObjectiveType.MilitaryArea, "Dover Naval Docks Area", "Dove", "Tobruk_Campaign-LOADONCALL-dover-naval-docks-objective5.mis", 1, 7, "BTargDoverNavyDocks", 246653, 233348, 800, 750, 7000, 40, 160, 24, true, true, 2, 8, "", add); //Because it's  a dock most bombs hit on "water", thus they don't count.  So it's hard to get a lot of ordnance KG on it.  Rely mostly on static kills for that reason.  NO SHIPS, must reduce count

            addPointArea(MO_ObjectiveType.MilitaryArea, "Brighton Naval Docks Area", "Dove", "Tobruk_Campaign-LOADONCALL-brighton-naval-docks-objective.mis", 1, 10, "BTargBrightonNavyDocks", 138520, 197736, 1300, 750, 10000, 40, 160, 24, true, true, 2, 8, "", add);
            //This one has a lot of land area, thus no worries about not enough KG
            */

            /*

            addPointArea(MO_ObjectiveType.MilitaryArea, "Dunkirk Naval Docks Area", "Dunk", "Tobruk_Campaign-LOADONCALL-dunkirk-naval-docks-objective.mis", 2, 10, "BTargDunkirkNavyDocks", 314227, 225610, 1150, 850, 10000, 40, 160, 24, true, true, 2, 8, "", add);

        
            addPointArea(MO_ObjectiveType.IndustrialArea, "Dieppe Cliffside German Special Forces Command Bunker", "", "Tobruk_Campaign-LOADONCALL-Dieppe-shoreline-bunker-objective.mis", 2, 6, "DieppeCliffsBunker", 238972, 107365, 70, 50, 4000, 20, 120, 24, true, true, 2, 8, "", add);

            */


            /*
            addMobile(MO_ObjectiveType.MilitaryArea, "Mobile Army Camp", "", 2, 1, "RMobileArmyCamp", 270276, 169671, 200, 150, 7000, 15, 1, 36, true, true, 1, 3, MO_MobileObjectiveType.ArmyEncampment, 15, 10000, 10000, 278420, 271000, 2, 7, MO_ProducerOrStorageType.None, "", add);
        
            addMobile(MO_ObjectiveType.MilitaryArea, "Intelligence Listening Post", "", 1, 1, "BIntelligenceListening", 212979, 182491, 250, 200, 4000, 15, 1, 36, true, true, 1, 3, MO_MobileObjectiveType.CamoGroup, 45, 197500, 10000, 370000, 190000, 5, 20, MO_ProducerOrStorageType.None, "", add);

            */

            ////$include "C:\Users\Brent Hugh.BRENT-DESKTOP\Documents\Visual Studio 2015\Projects\ClodBLITZ-2018-01\Tobruk_Campaign-MissionObjectivesInclude.cs"

            /* addTrigger(MO_ObjectiveType.Building, "Portsmouth Small Industrial Area SW", "Port", 1, 4, "BTargPortsmouthSmallIndustrialArea", "TGroundDestroyed", 35, 75235, 193676, 350, false, 120, 24, "", add);
addTrigger(MO_ObjectiveType.Building, "Portsmouth Large Industrial Area NE", "Port", 1, 5, "BTargPortsmouthLargeIndustrialArea", "TGroundDestroyed", 27, 77048, 193985, 850, false, 120, 24, "", add);
addTrigger(MO_ObjectiveType.Building, "Poole North Industrial Port Area", "Pool", 1, 5, "BTargPooleNorthIndustrialPortArea", "TGroundDestroyed", 33, 14518, 184740, 400, false, 120, 24, "", add);
addTrigger(MO_ObjectiveType.Building, "Poole South Industrial Port Area", "Pool", 1, 4, "BTargPooleSouthIndustrialPortArea", "TGroundDestroyed", 34, 13734, 183493, 400, false, 120, 24, "", add);
*/




            /*
             * 
                RTargBerckLandingCraft TGroundDestroyed 14 269247 147771 150
                RTargLeCrotoyLandingCraftManufactureAreaBomb TGroundDestroyed 25 271378 132785 1000 
              RTargEstreeArmyTraining TGroundDestroyed 4 279617 163616 100
              RTargEtaplesLandingCraft TGroundDestroyed 7 269447 166097 150
             * */
            /*41 162099 50034 50
         *

    /*    
*/
        }
        //Names of the flak areas and link to file name
        //Name is used in list of objectives aboe & must match exactly.  You can change the name below but then the name in the addTrigger etc above must also be changed to match
        //file name must match exactly with the filename
        /*public Dictionary<string, string> FlakMissions = new Dictionary<string, string>()
            {
                    { "az", "/Flak areas/AbiarZaidflak.mis" },
                    { "ar", "/Flak areas/Akramhaflak.mis" },
             
                    { "None", "/Flak areas/Noneflak.mis" },
				
				
				
				
				
					
					
					
					
					
					
				/*	

            };
        public Dictionary<string, string> Airfield_to_FlakMissions = new Dictionary<string, string>()
            {
                    { "az", "/Flak areas/AbiarZaidflak.mis" },
                   
                    { "None", "/Flak areas/Noneflak.mis" },
				
							

            };
                */

        /*
        //This creates a randomized list of Blue & Red objectives.  When asked for potential targets we can check which still have not yet been destroyed & list location, name, etc.
        public void SelectSuggestedObjectives()
        {

            List<string> keys = new List<string>(msn.MissionObjectivesList.Keys);
            Calcs.Shuffle(keys);

            foreach (var key in keys)
            {
                MissionObjective mo = msn.MissionObjectivesList[key];
                if (mo.AttackingArmy == 1 || mo.AttackingArmy == 2) msn.MissionObjectivesSuggested[(ArmiesE)mo.AttackingArmy].Add(key);

            }
        }*/
        //This creates a randomized list of Blue & Red objectives.  When asked for potential targets we can check which still have not yet been destroyed & list location, name, etc.
        //They are, however, weighted by PrimaryTargetWeight field so that we'll end up with a similar distribution of objectives to what we see in the Primary Objectives List
        public void SelectSuggestedObjectives(ArmiesE army)
        {

            List<string> keys = new List<string>(msn.MissionObjectivesList.Keys);
            Calcs.Shuffle(keys);
            int goal = msn.MissionObjectivesList.Count / 2;
            int count = 0;

            for (int x = 0; x < 1200; x++) //unlikely but possible that we'd need to cycle through the list of targets multiple times to select enough targets to reach the points. Could happen though if PrimaryTargetWeights are set low, or only a few possible objectives available in the list. TOBRUK many objective weights are ZERO because don't want them as primary targets.  But OK as secondary. 
            {
                foreach (var key in keys)
                {
                    MissionObjective mo = msn.MissionObjectivesList[key];
                    if (mo.PrimaryTargetWeight >= 0 && mo.IsEnabled && !mo.IsPrimaryTarget && !mo.Destroyed && !(mo.DestroyedPercent > 2) && !mo.ObjectiveAchievedForPoints) //shouldn't choose things that are already partially destroyed
                    {
                        double r = msn.stb_random.NextDouble() * 201 - 1; //was 100 but now primarytargetweight goes up to 200 instead of 100.  TOBRUK we want to choose tarets weight 0 sometimes, so adjusted the value
                        //Console.WriteLine("Select Primary " + mo.PrimaryTargetWeight + " " + r.ToString("N4") + " " + mo.ID);
                        if (mo.PrimaryTargetWeight < r) continue; //implement weight; if weight is less than the random number then this one is skipped; so 100% is never skipped, 50% skipped half the time, 0% skipped always
                        if (mo.AttackingArmy != (int)army) continue;
                        if (mo.AttackingArmy == 1 || mo.AttackingArmy == 2)
                        {
                            if (msn.MissionObjectivesSuggested[(ArmiesE)mo.AttackingArmy].Contains(key)) continue;
                            msn.MissionObjectivesSuggested[(ArmiesE)mo.AttackingArmy].Add(key);
                            count++;
                            if (count > goal) break;
                        }

                    }
                }
            }
        }
    }
    public void RemoveSuggestedObjective(MissionObjective mo)
    {

        List<string> keys = new List<string>(MissionObjectivesList.Keys);
        if (MissionObjectivesSuggested[(ArmiesE)mo.AttackingArmy].Contains(mo.ID)) ;
        {
            MissionObjectivesSuggested[(ArmiesE)mo.AttackingArmy].Remove(mo.ID);
        }


    }
    public void MO_turnedMapAnnouncements(ArmiesE army)
    {
        string winner = ArmiesL[(int)army];

        int endseconds = 0;
        Timeout(endseconds, () =>
        {
            twcLogServer(null, winner + " has won this battle and completed all objectives assigned by HQ!", new object[] { });
            GamePlay.gpHUDLogCenter(winner + " has won this battle. Congratulations, " + winner + "!");
        });
        Timeout(endseconds + 10, () =>
        {
            twcLogServer(null, winner + " has won, pushed the front forward, and pushed the enemy back!", new object[] { });
            GamePlay.gpHUDLogCenter(winner + " has won the battle & pushed the front forward!");
        });
        Timeout(endseconds + 20, () =>
        {
            twcLogServer(null, winner + " HQ is very pleased with their performance and has rushed extra repair crews to this sector.", new object[] { });
            GamePlay.gpHUDLogCenter(winner + " has won this battle. Congratulations, " + winner + "!");
        });
        Timeout(endseconds + 30, () =>
        {
            twcLogServer(null, "Extra repair crews will have all {0} airfields, radar, and other damaged areas repaired by morning!", new object[] { winner });
            GamePlay.gpHUDLogCenter(winner + " has won this battle. Congratulations, " + winner + "!");
        });
        Timeout(endseconds + 40, () =>
        {
            twcLogServer(null, winner + " has won this battle! All involved have had their contributions recorded at Divisional Headquarters - expect promotions and commendations for all who have fought bravely and well.", new object[] { winner });
            GamePlay.gpHUDLogCenter(winner + " has won this battle. Congratulations, " + winner + "!");
        });
        Timeout(endseconds + 50, () =>
        {
            twcLogServer(null, "Congratulations " + winner + " for winning this hard-fought battle and carrying the day!", new object[] { winner });
            GamePlay.gpHUDLogCenter(winner + " has won this battle. Congratulations, " + winner + "!");
        });

    }
    public void MO_MissionObjectiveRollingWinnerHandler(ArmiesE army, bool BumrushRepelVictory = false)
    {

        //Task.Run(() =>
        {
            Console.WriteLine(ArmiesL[(int)army] + " has turned the battle - giving reward, selecting new objectives");
            MO_turnedMapAnnouncements(army);
            //We'll have to work on making CalcMapMove work here
            //And also save the full stats at this point, similar to what we do at end of mission.    

            //TOBRUK!!!  Since we are ALSO calling ENDMISSION in TOBRUK, to actually ROLL IT
            //We can't ALSO do SAveMapState with intermediateSave: true here or it will DOUBLE SAVE the result &  DOUBLE ADD map update score ##
            //If we were ROLLLING the map & doing an actual INTERMEDIATE WIN we could call this.  But since this is actually THE FINAL WIN for TOBRUK we
            //must skip this here.
            //SaveMapState(ArmiesL[(int)army], intermediateSave: true, intermediateWin: true); //This calcs the new mapstate & saves to disk.  


            //MO_MissionObjectiveRollingWinnersReward(army); //clear all destroyed radar, airfields, scouted objects, current primary objectives scored, for winner; 

            //For TOBRUK we're going to restart the mission here
            //Have to do this before erasing mission/objectives points @ the next step (MO_MissionObjectiveWinnersReward(army);)
            EndMission(endseconds: 1 * 60, winner: ArmiesL[(int)army], BumrushRepelOnly: BumrushRepelVictory); //We've taken care of "winner" above, don't do it in EndMission - just leave as ""

            //TOBRUK!!! back to regular old Winner's Reward.  That way we can choose new objectives etc right away.
            MO_MissionObjectiveWinnersReward(army, bumrushRepelVictory: BumrushRepelVictory);

            //For TOBRUK we are doing this a little different - this is the Blitz/CLOD way:
            /* 
            MO_SelectPrimaryObjectives((int)army, 0, fresh: true);
            MO_WritePrimaryObjectives(); //POSSIBLE BUG - this might erase other army's objectives?  Shouldn't but might.
            mission_objectives.SelectSuggestedObjectives(army);
            Timeout(10, () => //delay this so it synchronizes with the HUD & LOG messages.  This must happen after SaveMapState (intermediateWin: true) which updates the current MapState.
            {
                DrawFrontLinesPerMapState(-MAP_WIN_POINTS / 100, MAP_WIN_POINTS / 100);
            });

            */

            //TOBRUK way:

            //BUMRUSH REPEL VICTORY means one side has repelled their bumrush airport attack
            //So that side (ONLY) retains their destroyed primary objectives (forpoints) AND score so they can just proceed from there
            //The OTHER side gets ALL primaries and ALL forpoints objectives wiped to zero and they start over with NO objectives completed
            if (BumrushRepelVictory)
            {
                //MO_SelectPrimaryObjectives((int)army, 0, eraseOnly: true, eraseForPoints: false); //winner
                //MO_SelectPrimaryObjectives(3 - (int)army, 0, eraseOnly: true, eraseForPoints: true); //loser
                                                                                                //Even if a Bumrush Repel victory, we can still erase all primaries.  This might scramble things up a little for the winners, but they will still have all of their destroyed objectives.  Whereas the losers will lose ALL of their destroyed objectives.
                                                                                                //We don't select NEW objectives here because if the map advances, we'll load a new Battle and that will have entirely NEW objectives to choose from

                MO_WritePrimaryObjectives();
                //mission_objectives.SelectSuggestedObjectives(ArmiesE.Red);
                //mission_objectives.SelectSuggestedObjectives(ArmiesE.Blue);
                //LOSER gets all points & objectives erased & must start over with that battle from the zero point
                //MissionObjectiveScore[(ArmiesE)(3 - army)] = 0; //loser gets points zeroed out                                                            
                //MissionObjectivesCompletedString[(ArmiesE)(3 - army)] = ""; //AND all objectives completed are erased

                //But WINNER gets to keep current objectives completed score AND list of completed objectives (thus the below are rem-ed out)
                //MissionObjectiveScore[ArmiesE(army)] = 0; 
                //MissionObjectivesCompletedString[ArmiesE(army)] = "";
            } 
            // NORMAL WIN, the attacking army has WON the bumrush airport, and they advance the front
            //The means ALL objectives & objective scores are cleared for BOTH armies
            else
            {
                //MO_SelectPrimaryObjectives((int)army, 0, eraseOnly: true, eraseForPoints: true); //winner
                //MO_SelectPrimaryObjectives(3 - (int)army, 0, eraseOnly: true, eraseForPoints: true); //loser
                                                                                                //Even if a Bumrush Repel victory, we can still erase all primaries.  This might scramble things up a little for the winners, but they will still have all of their destroyed objectives.  Whereas the losers will lose ALL of their destroyed objectives.
                                                                                                //We don't select NEW objectives here because if the map advances, we'll load a new Battle and that will have entirely NEW objectives to choose from
                MO_WritePrimaryObjectives();
                //mission_objectives.SelectSuggestedObjectives(ArmiesE.Red);
                //mission_objectives.SelectSuggestedObjectives(ArmiesE.Blue);
                //MissionObjectiveScore[army] = 0; //loser gets points zeroed out
                //MissionObjectiveScore[(ArmiesE)(3 - (int)army)] = 0; //loser gets points zeroed out
                                                              //MissionObjectiveScore[ArmiesE.Blue] = 0;
                //MissionObjectivesCompletedString[army] = "";
                //MissionObjectivesCompletedString[(ArmiesE)(3 - (int)army)] = "";

            }

            //NOTE:  COULD just do MO_MissionObjectiveWinnersReward(ArmiesE army) here, which more or less completely clears the decks

            
        }//);

        //TODO: Add a list of all players who helped turn the map.  And/or players who helped destroy each objective.
    }

    //When one side completes their full objective/reaches their score then they clear the decks
    //and everything destroyed is restored again - handled rolling in-session, no restart
    public void MO_MissionObjectiveRollingWinnersReward(ArmiesE army)
    {
        int minutesLeft = calcTimeLeft_min();
        int maxUndestroyTime_min = minutesLeft;
        if (maxUndestroyTime_min > 4 * 60) maxUndestroyTime_min = 4 * 60;
        maxUndestroyTime_min = 1; //TOBRUK
        DateTime currTime_dt = DateTime.UtcNow;
        //minutesLeft = 2;//FOR TESTING
        minutesLeft = 5; //For TOBRUK; we're going to re-start on turn of battle

        MissionObjectivesTimes[army]["RepairCrewEndTime_dt"] = currTime_dt.AddHours(24); //So they have repair crews for 24 hours.  Speeds up any repairs by 4X.        

        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];

            if (mo.OwnerArmy == (int)army && (mo.Destroyed || mo.DestroyedPercent > 0 ||
                    (mo.TimeToUndestroy_UTC.HasValue && mo.MOObjectiveType != MO_ObjectiveType.Airfield)
                    || mo.AirfieldDamagePoints >= mo.AirfieldPointsRequired))
            {
                DateTime timeToRestore_dt = currTime_dt;
                DateTime timeToRestoreAlt_dt = currTime_dt;

                //If the item has a timetoundestroy we speed it up.  First we try picking a random time between now & in next 4 hours (first did whole session but that seemed too long).
                //Then we try speeding up existing undestroy time by 4X.  
                //Whichever is SOONER is what we do.
                if (mo.TimeToUndestroy_UTC.HasValue && mo.TimeToUndestroy_UTC.Value.CompareTo(currTime_dt) > 0)
                {
                    timeToRestore_dt = currTime_dt.AddMinutes(random.Next(maxUndestroyTime_min));  //Don't restore immediately but at some time between now & four hours from now . . .
                                                                                          //Then we'll also to a complete restore on next mission start, which will make sure we haven't missed anything AND restore any destruction.  MAYBE?!?
                                                                                          //that happened the remainder of that mission (thanks to the extra crews/equipment assigned by HQ to do double fast repairs overnight etc)
                    timeToRestoreAlt_dt = currTime_dt.AddMinutes((mo.TimeToUndestroy_UTC.Value - currTime_dt).TotalMinutes / 4); //Alternate time to restore which speeds up repairs 4X
                    if (timeToRestoreAlt_dt.CompareTo(timeToRestore_dt) < 0) timeToRestore_dt = timeToRestoreAlt_dt;

                }
                mo.TimeToUndestroy_UTC = timeToRestore_dt; //timeToUndestroy is either now, if it's not destroyed, or some time in the future until the end of the mission, if destroyed.
                                                           //the idea is the extra crews work starting now but they really won't finish up completely until working double time overnight.
                Console.WriteLine("Winner: Setting timetoUnd for {0} to {1} ({2}) ", mo.Name, mo.TimeToUndestroy_UTC.Value.ToString("yyyy-MM-dd-HHmmss"), minutesLeft);
            }

            //PARTIALLY DAMAGED ITEMS - REPAIR
            //undestroy any partially damaged items, that are not completely destroyed yet - as far as we are able!  CloD built-in triggers we can't change
            if (mo.OwnerArmy == (int)army && !mo.Destroyed &&
                (mo.DestroyedPercent > 0 || mo.AirfieldDamagePoints > 0 || mo.OrdnanceOnTarget_kg > 0
                || mo.ObjectsDestroyed_num > 0)
                )
            {
                mo.DestroyedPercent = 0; //if it's damaged but not completely destroyed yet, we just reset that right now.
                if (mo.MOObjectiveType == MO_ObjectiveType.Airfield) restoreAirfield(mo); //this will remove any craters etc if an airfield is partially destroyed
                //mo.ObjectsDestroyed_num = 0;  //Setting this to zero causes problems as there might not be another amount of objects to destroy; they aren't recreated.
                mo.OrdnanceOnTarget_kg = 0;
                mo.AirfieldDamagePoints = 0;
                mo.LastHitTime_UTC = null;
                Console.WriteLine("Winner: Removing partial damage for {0}", mo.Name);
            }


            //FOR ALL OBJECTIVES (little failsafe - things get weird if these are not reset)
            if (mo.OwnerArmy == (int)army)
            {
                //have to do this for ALL the winner's own objectives or things get weird, like one more bomb will suddenly add 500% damage again.
                mo.DestroyedPercent = 0; //if it's damaged but not completely destroyed yet, we just reset that right now.                
                //mo.ObjectsDestroyed_num = 0; //setting this to zero causes problems for attackers
                mo.OrdnanceOnTarget_kg = 0;
                mo.LastHitTime_UTC = null;
            }

            if (mo.AttackingArmy == (int)army)
            {
                mo.ObjectiveAchievedForPoints = false; //this resets the objectives list for scoring purposes.  If items are still actually destroyed they can stay that way until they're repaired.  But for scoring purposes, the winning side is now starting over as though nothing were destroyed.
                mo.IsPrimaryTarget = false;
                mo.hasGeneralStaff = false; //Might need to not mess with this, but it goes along with removing all primary objectives
                mo.Scouted = false; //And we have to reset scouting because now we have a full NEW set of objectives to get
                mo.PlayersWhoScoutedNames = new Dictionary<string, int>();
                mo.lastScoutedPos = mo.Pos;
                mo.lastScoutedSector = mo.Sector;
                mo.lastTimeScouted_dt = null;
                mo.numTimesScouted = 0;
                mo.PlayersWhoContributedNames = new HashSet<string>();

                //if (mo.MOObjectiveType == MO_ObjectiveType.Airfield) restoreAirfield(mo); //this will remove any craters etc if an airfield is partially destroyed //don't do this for ENEMY airfields; arrgh.
                //Resetting these for the enemy objectives is a bit weird, but it has to do with the fact that we are wiping the slate clean as far as attacking the enemy.
                //If their item is destroyed it is STILL destroyed but if it is destroyed to 136% we can't just go drop another bomb on it and suddenly it's 138% and we get credit for a "victory".
                //For the enemy's purposes the destroyed amount is determined by the destroyed bool & also the timetoundestroy setting.  If we destroy it again now we can add more time to the time to undestroy setting.
                mo.DestroyedPercent = 0; //if it's damaged but not completely destroyed yet, we just reset that right now.
                mo.ObjectsDestroyed_num = 0;
                mo.OrdnanceOnTarget_kg = 0;
            }
        }

        MissionObjectiveScore[(ArmiesE)army] = 0;
        MissionObjectivesCompletedString[(ArmiesE)army] = "";

    }

    //When one side completes their full objective/reaches their score then they clear the decks
    //and everything destroyed is restored again
    public void MO_MissionObjectiveWinnersReward(ArmiesE army, bool bumrushRepelVictory = false)
    {

        string objList = "";
        double objScore = 0;
        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];

            //For the enemy's targets, we have to undestroy/unscout/un-forPoints everything because we'll be re-selecting our new targets from all of these.
            if (mo.OwnerArmy == (int)army)
            {

                mo.Destroyed = false;
                mo.DestroyedPercent = 0;
                mo.TimeToUndestroy_UTC = null;
                mo.LastHitTime_UTC = null;
                mo.IsPrimaryTarget = false;
                mo.ObjectiveAchievedForPoints = false;
                mo.OrdnanceOnTarget_kg = 0;
                mo.ObjectsDestroyed_num = 0;
                mo.Scouted = false; //And we have to reset scouting because now we have a full NEW set of objectives to get
                mo.PlayersWhoScoutedNames = new Dictionary<string, int>();
            }

            //We don't reset mo.ObjectiveAchievedForPoints here because the other side is still working on their objectives list.  So it is restored for use by the winning side but still counts towards objectives/points for the other side.  This is getting messy . . . 
            /*  hmm, this was a mistake but we **could** really do it.  When one side turns the map, the other side loses all of its recon photos.  Hmm.
            mo.Scouted = false;
            mo.PlayersWhoScoutedNames = new Dictionary<string, int>();
            */


            if (mo.AttackingArmy == (int)army)
            {
                //For the army that repelled the bumrush attack, they get to KEEP their achieved objectives and move forward.
                //so we have to retain those destroyed objs & also retotal their points & keep the list of achieved objectives to move forward
                if (bumrushRepelVictory && mo.ObjectiveAchievedForPoints)
                {
                    objList += " - " + mo.Name;
                    objScore += mo.Points;

                }
                else
                {

                    //TOBRUK new thing, we need to get objectives undestroyed immediately so we can use them again.
                    //Unless they're primaries we already destroyed & and retaining after bumrush repel, see above
                    mo.Destroyed = false;
                    mo.DestroyedPercent = 0;
                    mo.TimeToUndestroy_UTC = null;
                    mo.LastHitTime_UTC = null;


                    mo.ObjectiveAchievedForPoints = false; //this resets the objectives list for scoring purposes.  If items are still actually destroyed they can stay that way until they're repaired.  But for scoring purposes, the winning side is now starting over as though nothing were destroyed.
                    mo.IsPrimaryTarget = false;
                    mo.hasGeneralStaff = false; //Might need to not mess with this, but it goes along with removing all primary objectives
                    mo.Scouted = false; //And we have to reset scouting because now we have a full NEW set of objectives to get
                    mo.PlayersWhoScoutedNames = new Dictionary<string, int>();
                    mo.ObjectiveAchievedForPoints = false;
                    mo.OrdnanceOnTarget_kg = 0;
                    mo.ObjectsDestroyed_num = 0;
                }

            }
        }

        //In bumrushRepelVictory, the 
        if (bumrushRepelVictory)
        {
            MissionObjectiveScore[army] = objScore; //loser gets points zeroed out                                                            
            MissionObjectivesCompletedString[army] = objList; //AND all objectives completed are erased

        }
        else
        {

            MissionObjectiveScore[(ArmiesE)army] = 0;
            MissionObjectivesCompletedString[(ArmiesE)army] = "";
        }
        //Losing army always gets entire objectives/scores wiped out
        MissionObjectiveScore[(ArmiesE)(3 - (int)army)] = 0;
        MissionObjectivesCompletedString[(ArmiesE)(3 - (int)army)] = "";

    }

    //We load the existing objectives list from the disk.  But . . . . 
    //if an objective is still destroyed from a previous mission then have to do certain things, such as set up some smokes if it was hit recently, to make it look recently
    //hit, and also (depending on he type of objective) keep its functionality turned off as long as is is still destroyed/unrepaired.
    //This handles every kind of objective except airports, which are handled separately
    //
    public void MO_MissionObjectiveOnStartCheck(Mission msn, maddox.game.IGamePlay gp)
    {
        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];

            //DON'T RESET isPrimaryTarget here because we're doing this after the primary objectives are chosen & entered into this list.
            //We will do that needed reset, but earlier in the process
            //mo.IsPrimaryTarget = false; //we reset this every time we load from disk, because later we'll read the primary objectives file & set this = true if it is a primary objective based on that.

            if (mo.IsPrimaryTarget || !mo.IsEnabled) RemoveSuggestedObjective(mo); //make sure any primary targets and any disabled objectives are not listed in the suggested objectives list

            if (mo.Destroyed)
            {
                //Sometime is has been destroyed and now it is time to undestroy it
                if (mo.TimeToUndestroy_UTC.HasValue && DateTime.Compare(mo.TimeToUndestroy_UTC.Value, DateTime.UtcNow) < 0)
                {
                    mo.Destroyed = false;
                    mo.DestroyedPercent = 0;
                    mo.TimeToUndestroy_UTC = null;
                } else //so if it has been destroyed before.  So we will mark it with smoke to show it is damaged.
                       //We also mark it with a small smoke so you can tell it has been hit recently, but not too recently.
                       //However, we DO leave it marked as "destroyed", until it's time for undestroying comes along OR until that
                       //team turns the map, which undestroys all of the objectives they own.

                //Though this objective is smoked up, the trigger is reset when the mission restarts, so the opposing team can hit it again and destroy it even more and rack
                //up a few more points, though not as much as if it were pristine to start with.


                {


                    //string firetype = "BuildingFireSmall"; //small-ish
                    //if (mass_kg > 200) firetype = "BigSitySmoke_1"; //500lb bomb or larger  //REALLY huge
                    //if (mass_kg > 200) firetype = "Smoke1"; //500lb bomb or larger //larger
                    //string smoke = "BuildingFireSmall"; //was "BuildingFireBig" but that seems too big
                    //For TOBRUK we're avoiding larger fire/smoke due to FPS issues
                    string smoke = "BuildingFireSmall"; //was "BuildingFireBig" but that seems too big
                    double hoursSinceHit = 48;
                    if (mo.LastHitTime_UTC.HasValue) hoursSinceHit = DateTime.UtcNow.Subtract(mo.LastHitTime_UTC.Value).TotalHours;
                    //if (mo.LastHitTime_UTC != null && (hoursSinceHit < 12)) smoke = "BuildingFireSmall";
                    //if (mo.LastHitTime_UTC != null && (hoursSinceHit < 2)) smoke = "BuildingFireBig";  //Smoke2"; is a little too big.


                    Calcs.loadSmokeOrFire(GamePlay, this, mo.Pos.x + random.Next(50) - 25, mo.Pos.y + random.Next(50) - 25, 0, smoke, duration_s: 6 * 3600);
                    if (mo.LastHitTime_UTC != null && (hoursSinceHit < 12)) Calcs.loadSmokeOrFire(GamePlay, this, mo.Pos.x + random.Next(75) - 32.5, mo.Pos.y + random.Next(50) - 25, 0, smoke, duration_s: 6 * 3600);
                    if (mo.LastHitTime_UTC != null && (hoursSinceHit < 2)) Calcs.loadSmokeOrFire(GamePlay, this, mo.Pos.x + random.Next(150) - 75, mo.Pos.y + random.Next(150) - 75, 0, smoke, duration_s: 6 * 3600);                    

                    if (mo.Points > 3) Calcs.loadSmokeOrFire(gp, msn, mo.Pos.x + random.Next(70) - 35, mo.Pos.y + random.Next(70) - 35, 0, smoke, duration_s: 6 * 3600); //bigger objective, put another3


                    //Actually disabling the trigger was a mistake.  It is destroyed "for points purposes" which is reflected in mo.ObjectiveAchievedForPoints but can still be
                    //hit again as a 'normal objective' for fewer points, just not again as a primary objective
                    /*if (mo.MOTriggerType == MO_TriggerType.Trigger && GamePlay.gpGetTrigger(ID) != null)
                    {
                        Console.WriteLine("MO_DestroyObjective: Disabling trigger " + ID);
                        GamePlay.gpGetTrigger(ID).Enable = false;
                    }
                    */

                    //Turn off any radars if they are still disabled
                    if (mo.MOObjectiveType == MO_ObjectiveType.Radar)
                    {
                        if (mo.OwnerArmy == 1) DestroyedRadar[(ArmiesE.Red)].Add(mo);
                        if (mo.OwnerArmy == 2) DestroyedRadar[(ArmiesE.Blue)].Add(mo);
                    }

                    //Here is the spot to take any other action needed to show the affects if a target was destroyed and is still destroyed this session.
                    //So if an aircraft plant, turn off or down the aircraft manufacturing levels, if a bread making plant reduce the supply of bread, etc.
                    //Airports are handled specially, but everything else can be handled here.


                }
            }
        }
    }

    //AddNewOnly means only add new aps not already in the file read from disk.  addNewOnly=false means, forget about what's on the disk load, just read them all in.  Usually you only want to do this if the disk read failed.
    public void MO_MissionObjectiveAirfieldsSetup(Mission msn, maddox.game.IGamePlay gp, bool addNewOnly = false)
    {
        //public Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>> AirfieldTargets = new Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>>();
        //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, double airfield radius, Point3d airfield center (position)
        //TRIGGER initiator (for all types except RADAR)
        //public MissionObjective(Mission m, MO_ObjectiveType mot, double pts, double ptp, AiAirport airport, Tuple<bool, string, double, double, DateTime, double, Point3d> tup)
        //            string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, int ptp, string comment)


        //int NumNearbyTargets = MissionObjectivesNear();
        if (GamePlay == null)
        {
            Console.Write("");
            Console.Write("Airfieldsetup: MAJOR ERROR *************************************************** ");
            Console.Write("Airfieldsetup: MAJOR ERROR GamePlay not initialized, nothing done.  Exiting.");
            Console.Write("Airfieldsetup: MAJOR ERROR *************************************************** ");
            Console.Write("");
            Console.Write("");
            EndMission(endseconds: 0);
        }

        int count = AirfieldTargets.Count;
        double weight = (double)170 / (double)count; //500/count gives you about 1 airfield target about 1 of every 3 sets of targets.  2020/02/27 was 300/count, made it 200/count to slightly decrease airports chosen for mission objectives.  There ARE a lot of them typically; maybe a little too many?  Also increased points given to airport destruction from 3 to 5 now that it takes much more tonnage to take
           //out an airport.  So that should reduce the # of airports in a given mission objectives list because more points.  2020/03/06 - reduced from 200 to 170
        int num_added = 0;
        int num_updated = 0;
        var allKeys = new List<AiAirport>(AirfieldTargets.Keys);
        if (AirfieldTargets != null) foreach (AiAirport ap in allKeys)
            {
                string af_name = AirfieldTargets[ap].Item2 + "_spawn";
                Console.WriteLine("Checking airfield {0} already exists? {1}", af_name, MissionObjectivesList.ContainsKey(af_name));
                if (!addNewOnly || !MissionObjectivesList.ContainsKey(af_name))
                {
                    Console.Write("Airfieldsetup: adding new airfield " + af_name);

                    int NumNearbyTargets = MO_MissionObjectivesNear(AirfieldTargets[ap].Item7, 20000);  //was 15,000 - 2020-01
                    double IndWeight = weight;
                    if (NumNearbyTargets > 0) IndWeight = weight * 2;
                    else if (NumNearbyTargets > 3) IndWeight = weight * 16;  //was 4 -> 16 increasing airfields near major objects as targets with cover bomber system.  2020-01
                    else if (NumNearbyTargets > 5) IndWeight = weight * 48;  //was 12 -> 48 increasing 4X with cover bomber system.  2020-01
                                                                             //Console.WriteLine("AP: " + AirfieldTargets[ap].Item2 + "_spawn");
                    Point3d Pos = AirfieldTargets[ap].Item7;
                    int army = GamePlay.gpFrontArmy(Pos.x, Pos.y);
                    if (Pos.x > 210000 && Pos.y > 180000 && Pos.x < 321000 && Pos.y < 270000) IndWeight = 90; //vastly increase # of airports as mission objectives, in the 'main' campaign area. 2020-01. Was 200, now adjusting to 150.  2020/02/28
                    //2020-08 - making each airfield worth **********30 points*************** later we need to make only the PRIMARY TARGET AIRFIELD
                    //worth 30 points
                    //TODO: Fix this so only the primary target is 30 points, others are maybe 1-2 points.
                    

                    //TOBRUK: All objectives are just 1 point, except the FOCUS/PRimary objectives
                    //And chance of being chosen is low, just 0/200.
                    IndWeight = 0; 
                    MissionObjectivesList.Add(af_name, new MissionObjective(msn, 1, IndWeight, ap, army, AirfieldTargets[ap])); //5 is the points/difficulty level
                    num_added++;
                } else if (MissionObjectivesList.ContainsKey(af_name))
                {
                    Console.Write("Airfieldsetup: updating existing airfield " + af_name);
                    //AirfieldTargets = new Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>>();
                    //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, double airfield radius, Point3d airfield center (position)
                    Tuple<bool, string, double, double, DateTime, double, Point3d> oldAp = AirfieldTargets[ap];
                    MissionObjective mo = MissionObjectivesList[af_name];
                    //double damagePoints = 0; //assumed because it is knocked out/100%
                    //if (mo.DestroyedPercent > 0)
                    //damagePoints = mo.DestroyedPercent * oldAp.Item3;  //so if the airport was partially knocked out before, it still remains that way
                    //between this & the last-hit time the airport routine can calculate airport repair time accurately.
                    //so if the airport was partially knocked out before, it still remains that way
                    //double PointsTaken = oldAp.Item4;
                    double PointsTaken = 0; //default value
                    double PointsToKnockout = 190; //Was 30, then 30 for blue airfields & 65 for red, then bombing adjustment by bomber, then both were 65, then 90 when cover bombers introduced, then 200 as 90 seemed far too easy with cover bombers, then backing it off a bit to 190.
                    bool apDestroyed = false; //default valiue
                    DateTime lastHitTime = DateTime.UtcNow; //default value for time of last damage hit; IF we don't have this, we set it to right now

                    //These are the two things saved to disk in MissionObjectivesList & that we MUST transfer over the AP list:
                    if (mo.LastHitTime_UTC.HasValue) lastHitTime = mo.LastHitTime_UTC.Value;
                    PointsTaken = mo.AirfieldDamagePoints;
                    //Console.WriteLine("aptransfer: " + lastHitTime.ToString("yyyy-MM-dd-HHmmss") + " " + PointsTaken.ToString()); //for testing

                    if (mo.Destroyed)
                    {
                        //it was destroyed, but now it is time to undestroy the airport
                        if (!mo.TimeToUndestroy_UTC.HasValue || DateTime.Compare(mo.TimeToUndestroy_UTC.Value, DateTime.UtcNow) < 0) //airport should always have an undestroy time.  IF not, we assume the undestroy time is right now.
                        {
                            Console.Write("Airfieldsetup: updating airfield; time to undestroy it, " + af_name);
                            mo.Destroyed = false;
                            mo.DestroyedPercent = 0;
                            mo.TimeToUndestroy_UTC = null;
                            mo.OrdnanceOnTarget_kg = 0;
                            mo.ObjectsDestroyed_num = 0;
                            PointsTaken = 0;
                        }
                        else //it is still destroyed, so we need to mark it destroyed & actually destroy it
                        {
                            Console.Write("Airfieldsetup: updating airfield; it is still destroyed, " + af_name);
                            AirfieldDisable(ap, 1);
                        }
                    }
                    else if (PointsTaken > 0) //damaged but not completely destroyed.  So we scatter some craters in proportion to how destroyed it is.
                                              //TODO: Here we COULD save the old crater pattern exactly as it was @ mission start, and then restore it exactly . . .
                    {
                        Console.Write("Airfieldsetup: updating airfield; it is partially destroyed, " + af_name);
                        double percent = PointsTaken / PointsToKnockout;
                        AirfieldDisable(ap, percent);

                    }
                    //For TOBRUK all airports are targets but only 1 point, and 0% possibility of being chosen as a primary objective unless it is the Focus Airport
                    mo.Points = 1;
                    mo.PrimaryTargetWeight = 0;
                    if (af_name.ToLower().Contains("seaplane")) mo.PrimaryTargetWeight = 2; //slight chance of choosing seaplane bases however

                    AirfieldTargets.Remove(ap); //not sure if this is 100% necessary??
                    AirfieldTargets[ap] = new Tuple<bool, string, double, double, DateTime, double, Point3d>(
                        mo.Destroyed, //bool disabled
                        oldAp.Item2, //name
                        PointsToKnockout, //pointstoknockout
                        PointsTaken, //damage point total
                        lastHitTime,
                        oldAp.Item6, // airfield radius
                        oldAp.Item7  //airfield center
                        );
                    //Console.WriteLine("aptransfer2: " + lastHitTime.ToString("yyyy-MM-dd-HHmmss") + " " + PointsTaken.ToString()); //for testing

                    num_updated++;
                }

            }
        Console.WriteLine("Mission Objectives: Added " + num_added.ToString() + " airports to Mission Objectives, updated " + num_updated.ToString() + " weight " + weight.ToString("N5"));

    }

    /*
    String[] MO_BRBumrushTargetAirfieldsList = { "Tariq Al Ghubay Airfield", "Scegga No3 Airfield", "Gasr el Abid South Airfield", "Sidi Azeiz Airfield", "Sidi Rezegh LG153 Airfield" };

    //IMPORTANT: If you have different spawn points for the same airfield (say, in different .mis files) this will cause problems here!  Make sure spawnpoints for these airports are in one .mis file only!

    
    public void MO_BRMissionObjectiveAirfieldFocusBumrushSetup(Mission msn, maddox.game.IGamePlay gp, int level)
    {
        //*********************************************************************
        //WARNING!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!
        //
        // The Airport name as spelled here must EXACTLY match the name of the airport as found in the BIRTHPLACE listing of the .mis file
        // If you mis-spell it there you MUST mis-spell it EXACTLY the same here or IT WILL NOT WORK AT ALL!!!!!
        //[BirthPlace]
        //        Tariq_mysnot 1 226402 43716 0 1 1 1. . . 0
        //        Habatha_Kabatha 1 311428 81015 0 1 1 1. . . 0
        //        Wourk-el-SlABU 1 311428 41015 0 1 1 1. . . 0
        //
        //  String[] TargetAirfieldsList = { "Tariq_mysnot", "Habatha_Kabatha", "Wourk-el-SlABU" };

        //Also the objectives list has underlines instead of spaces, like Scegga_No2_airfield - so we'll have to adjust there; not sure why it is.

        gpLogServerAndLog(null, "***Starting Focus Airport/Bumrush setup", null);




        foreach (string af in MO_BRBumrushTargetAirfieldsList) {
            if (!MissionObjectivesList.ContainsKey(af + "_spawn")) //.Replace(' ', '_')
                gpLogServerAndLog(null, "**************WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! A target Airport does not exist, check FocusBumrushSetup: " + af, null);

        }

        int blueTarget = level;
        int redTarget = level + 1;

        MO_BRBumrushInfo[ArmiesE.Red].BumrushObjectiveName = MO_BRBumrushTargetAirfieldsList[redTarget] + "_spawn";
        MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjectiveName = MO_BRBumrushTargetAirfieldsList[blueTarget] + "_spawn";

        MO_BRBumrushInfo[ArmiesE.Red].BumrushAirportName = MO_BRBumrushTargetAirfieldsList[redTarget];
        MO_BRBumrushInfo[ArmiesE.Blue].BumrushAirportName = MO_BRBumrushTargetAirfieldsList[blueTarget];


        if (!MissionObjectivesList.ContainsKey(MO_BRBumrushInfo[ArmiesE.Red].BumrushObjectiveName))
        {
            gpLogServerAndLog(null, "", null);
            gpLogServerAndLog(null, "*********MAJOR STARTUP ERROR!!!! RED Target Airport {0} does not exist!!!!! Exiting....", new object[] { MO_BRBumrushInfo[ArmiesE.Red].BumrushObjectiveName });
            gpLogServerAndLog(null, "", null);
            (GamePlay as GameDef).gameInterface.CmdExec("battle stop");  //doesn't work for some unknown reason//!????
            //System.Environment.Exit(1);
        }
        else
        {
            MO_BRBumrushInfo[ArmiesE.Red].BumrushObjective = MissionObjectivesList[MO_BRBumrushInfo[ArmiesE.Red].BumrushObjectiveName];
            MissionObjective mo = MO_BRBumrushInfo[ArmiesE.Red].BumrushObjective;
            mo.IsPrimaryTarget = true;
            mo.IsFocus = true;
            mo.PrimaryTargetWeight = 200;
            mo.Points = 30; // 6 primary objects * 5 + the main airport makes 60 points required to start bumrush
            gpLogServerAndLog(null, "RED Primary Target Airport is " + MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjective.AirfieldName, null);

        }

        if (!MissionObjectivesList.ContainsKey(MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjectiveName))
        {
            gpLogServerAndLog(null, "", null);
            gpLogServerAndLog(null, "*********MAJOR STARTUP ERROR!!!! BLUE Target Airport {0} does not exist!!!!! Exiting....", new object[] { MO_BRBumrushInfo[ArmiesE.Red].BumrushObjectiveName });
            gpLogServerAndLog(null, "", null);
            (GamePlay as GameDef).gameInterface.CmdExec("battle stop");
            //System.Environment.Exit(1);
        }
        else
        {
            MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjective = MissionObjectivesList[MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjectiveName];
            MissionObjective mo = MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjective;
            mo.IsPrimaryTarget = true;
            mo.IsFocus = true;
            mo.PrimaryTargetWeight = 200;
            mo.Points = 30; // 6 primary objects * 5 + the main airport at 30 points makes 60 points required to start bumrush

            gpLogServerAndLog(null, "BLUE Primary Target Airport is " + MO_BRBumrushInfo[ArmiesE.Blue].BumrushObjective.AirfieldName, null);
        }

        //Check if the files actually exist.  Does NOT actually load them, just checks if they are actually there with correct name!!!!
        bool blue_red = LoadRandomSubmission(fileID: MISSION_ID + "-Rush-Blue-" + MO_BRBumrushInfo[ArmiesE.Red].BumrushAirportName, subdir: "Bumrushes", check: true);
        bool red_red = LoadRandomSubmission(fileID: MISSION_ID + "-Rush-Red-" + MO_BRBumrushInfo[ArmiesE.Red].BumrushAirportName, subdir: "Bumrushes", check: true);
        bool blue_blue = LoadRandomSubmission(fileID: MISSION_ID + "-Rush-Blue-" + MO_BRBumrushInfo[ArmiesE.Blue].BumrushAirportName, subdir: "Bumrushes", check: true);
        bool red_blue = LoadRandomSubmission(fileID: MISSION_ID + "-Rush-Red-" + MO_BRBumrushInfo[ArmiesE.Blue].BumrushAirportName, subdir: "Bumrushes", check: true);

        if (!blue_red || !red_red || !blue_blue || !red_blue)
        {
            gpLogServerAndLog(null, "", null);
            gpLogServerAndLog(null, "*********MAJOR STARTUP ERROR!!!! One of the REQUIRED " + MISSION_ID + "-Rush....mis files is MISSING or MISNAMED!!!!!! Exiting....", null);
            gpLogServerAndLog(null, "", null);
            if (!blue_red) gpLogServerAndLog(null, "*********MISSING OR MISNAMED FILE: Bumrushes/" + MISSION_ID + " - Rush-Blue-" + MO_BRBumrushInfo[ArmiesE.Red].BumrushAirportName, null);
            if (!red_red) gpLogServerAndLog(null, "*********MISSING OR MISNAMED FILE: Bumrushes/" + MISSION_ID + "-Rush-Red-" + MO_BRBumrushInfo[ArmiesE.Red].BumrushAirportName, null);
            if (!blue_blue) gpLogServerAndLog(null, "*********MISSING OR MISNAMED FILE: Bumrushes/" + MISSION_ID + "-Rush-Blue-" + MO_BRBumrushInfo[ArmiesE.Blue].BumrushAirportName, null);
            if (!red_blue) gpLogServerAndLog(null, "*********MISSING OR MISNAMED FILE: Bumrushes/" + MISSION_ID + "-Rush-Red-" + MO_BRBumrushInfo[ArmiesE.Blue].BumrushAirportName, null);
            gpLogServerAndLog(null, "", null);
            //(GamePlay as GameDef).gameInterface.CmdExec("battle stop");
            //System.Environment.Exit(1);

        } else
        {
            gpLogServerAndLog(null, "All needed BUMRUSH .mis files for both Blue & Red Primary Target Airports are in place.", null);
        }

        /*

        m_TargetAirfields.Add(ARMY_RED, "Habata_LG79", 9000, 1);
        m_TargetAirfields.Add(ARMY_RED, "Tariq_Al_Ghubay", 9000, 20);// denotes initial airport to attack and occupy 
        m_TargetAirfields.Add(ARMY_RED, "Scegga_No1", 9000, 1);
        m_TargetAirfields.Add(ARMY_RED, "Awdyat_ash_Ahiyah", 9000, 1);
        m_TargetAirfields.Add(ARMY_RED, "Bir_el_Malla_South_LG76", 9000, 1);
        m_TargetAirfields.Add(ARMY_RED, "Buq_Buq_LG01", 9000, 1);
        m_TargetAirfields.Add(ARMY_RED, "Bir_Basur_LG69", 9000, 1);
        /// blue airfields 
        m_TargetAirfields.Add(ARMY_BLUE, "Almiah_Alkhafia_LG15", 9000, 1);
        m_TargetAirfields.Add(ARMY_BLUE, "el_Adem_No1_LG144", 9000, 1);
        m_TargetAirfields.Add(ARMY_BLUE, "Gazala_No2_LG150", 9000, 1);
        m_TargetAirfields.Add(ARMY_BLUE, "Tobruk_No5", 9000, 1);
        m_TargetAirfields.Add(ARMY_BLUE, "Gambut_No5_West", 9000, 1);
        m_TargetAirfields.Add(ARMY_BLUE, "Sidi_Azeiz", 9000, 20);//denotes initial airport to attack and occupy
        m_TargetAirfields.Add(ARMY_BLUE, "Sidi_Rezegh_LG153", 9000, 1);
        */
    /*
    }
    */

    public void MO_MissionObjectiveAirfieldsArmyReset(Mission msn, maddox.game.IGamePlay gp, int army, string apID = null) //reset/restore all airfields for a given army, apID chooses only ONE to restore if that is the situation.
    {
        //public Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>> AirfieldTargets = new Dictionary<AiAirport, Tuple<bool, string, double, double, DateTime, double, Point3d>>();
        //Tuple is: bool airfield disabled, string name, double pointstoknockout, double damage point total, DateTime time of last damage hit, double airfield radius, Point3d airfield center (position)
        //TRIGGER initiator (for all types except RADAR)
        //public MissionObjective(Mission m, MO_ObjectiveType mot, double pts, double ptp, AiAirport airport, Tuple<bool, string, double, double, DateTime, double, Point3d> tup)
        //            string tn, string n, int ownerarmy, double pts, string t, double p, double x, double y, double d, bool pt, int ptp, string comment)

        //Console.WriteLine("Airfields Reset: {0} {1} ", apID, army);
        int num_updated = 0;
        var allKeys = new List<AiAirport>(AirfieldTargets.Keys);
        if (AirfieldTargets != null) foreach (AiAirport ap in allKeys)
            {
                string af_name = AirfieldTargets[ap].Item2 + "_spawn";
                if (apID != null && af_name != apID) continue; //skip all but the one requested, when only one is requested
                //Console.WriteLine("Airfields Reset: {0} {1} {2} ", apID, af_name, army);
                Tuple<bool, string, double, double, DateTime, double, Point3d> oldAp = AirfieldTargets[ap];
                if (!MissionObjectivesList.ContainsKey(af_name)) continue; //can't do anything if it is not in the objectives list; all airports should be
                MissionObjective mo = MissionObjectivesList[af_name];
                if (mo.OwnerArmy != army) continue; // only restore the aps of the designated army
                mo.Destroyed = false;
                mo.DestroyedPercent = 0;
                mo.TimeToUndestroy_UTC = null;
                mo.ObjectsDestroyed_num = 0;
                mo.OrdnanceOnTarget_kg = 0;
                mo.AirfieldDamagePoints = 0;

                //here we want to set damage to 0 & un-disable/un-destroy it
                AirfieldTargets[ap] = new Tuple<bool, string, double, double, DateTime, double, Point3d>(
                    false, //bool disabled
                    oldAp.Item2, //name
                    oldAp.Item3, //pointstoknockout
                    0, //damage point total
                    oldAp.Item5, //still hit at whatever time it was hit, even though this ahs been repaired now
                    oldAp.Item6, // airfield radius
                    oldAp.Item7  //airfield center
                    );

                num_updated++;
            }


        Console.WriteLine("Mission Objectives: Repaired " + num_updated.ToString() + " airports for army " + army.ToString("F0"));

    }

    //removes any craters, smoke, or fire statics within the given radius.  Typically used for airport but could be for anything.
    public void removeSmokeFireCraters(Point3d p, double radius_m, int percentToRemove = 100)
    {
        Calcs.removeStatics(GamePlay, this, p.x, p.y, radius_m, new List<string> {
            "Smoke1", "Smoke2", "BuildingFireSmall", "BuildingFireBig", "BigSitySmoke_0", "BigSitySmoke_1", "BombCrater_firmSoil_mediumkg", "BombCrater_firmSoil_largekg", "BombCrater_firmSoil_smallkg" }, percentToRemove);
        //"crater", "smoke", "fire" });
    }

    public int MO_MissionObjectivesNear(Point3d p, double dist_m)
    {
        int total = 0;
        List<string> keys = new List<string>(MissionObjectivesList.Keys);
        foreach (var key in keys)
        {
            MissionObjective mo = MissionObjectivesList[key];
            double d_m = Calcs.CalculatePointDistance(mo.Pos, p);
            if (d_m <= dist_m) total++;
        }
        return total;
    }

    //This creates a randomized list of Blue or Red Primary Objectives totalling (at least) the required point total
    //And sets the IsPrimaryTarget flag for each in that army, de-selecting the IsPrimaryTarget flag for all others
    //Only chooses from those in the PrimaryTargetWeight     
    //Will do either army=1 or army=2 or BOTH ARMIES if army=0  
    //eraseOnly = true erases all current primary objectives without choosing any new ones.  Needed for TOBRUK.
    //eraseForPoints is valid only if fresh is true and setse "forPoints = false, isDestroyed=false & destroyed% to 0.  Basically it sets the objectives up so it needs to be destroyed again from point zero.
    //Whereas fresh= true + eraseForPoints = false will leave all objectives destroyed/forPoints exactly as they currently are
    public void MO_SelectPrimaryObjectives(int army = 0, double totalPoints = 0, bool fresh = false, bool eraseOnly = false, bool eraseForPoints = false)
    {

        List<string> keys = new List<string>(MissionObjectivesList.Keys);
        Calcs.Shuffle(keys);

        List<int> arms = new List<int>();
        if (army == 0) { arms.Add(1); arms.Add(2); }
        else if (army == 1 || army == 2) arms.Add(army);

        

        foreach (var a in arms)
        {
            Console.WriteLine("Selecting new Mission Objectives for " + ArmiesL[army] + " TotalPoints: " + totalPoints.ToString() + " PointsReq: " + MO_BRBumrushInfo[(ArmiesE)a].PointsRequiredToBeginBumrush.ToString() + " Fresh: " + fresh.ToString());

            string objectivesList = "";
            //first, reset all the targets (in this army) to be not primaries.  
            //But ONLY if we are starting fresh; ie, choosing ALL the primaries now
            //If some have already been chosen, we have to respect the previously chosen IsPrimaryTarget = true;          
            if (fresh) foreach (var key in keys)
                {
                    if (MissionObjectivesList[key].AttackingArmy == a)
                    {
                        MissionObjectivesList[key].IsPrimaryTarget = false;
                        if (eraseForPoints)
                        {
                            MissionObjectivesList[key].ObjectiveAchievedForPoints = false; //TOBRUK, if you don't zero this out the army can't achieve their
                            MissionObjectivesList[key].Destroyed = false;
                            MissionObjectivesList[key].DestroyedPercent =0;
                        }
                    }
                }

            if (eraseOnly) continue;
            
            int counter = 1;

            for (int x = 0; x < 25; x++) //unlikely but possible that we'd need to cycle through the list of targets multiple times to select enough targets to reach the points. Could happen though if PrimaryTargetWeights are set low, or only a few possible objectives available in the list. 
            {
                foreach (var key in keys)
                {
                    MissionObjective mo = MissionObjectivesList[key];

                    //Console.WriteLine("Checking " + mo.Name);

                    //if (mo.AttackingArmy == a && mo.PrimaryTargetWeight > 0 && mo.IsEnabled && !mo.IsPrimaryTarget && !mo.Destroyed && !mo.ObjectiveAchievedForPoints && mo.DestroyedPercent <= 2)
                    if (mo.AttackingArmy == a && mo.PrimaryTargetWeight > 0 && mo.IsEnabled && !mo.IsPrimaryTarget)
                    {
                        //Console.WriteLine("Checking 1 " + mo.Name + " {0} {1} {2} {3} ", new object[] { mo.PrimaryTargetWeight, mo.Destroyed, mo.ObjectiveAchievedForPoints, mo.DestroyedPercent });
                        //usually we skip certain objectives as primaries, but primarytargetweight==200 is basically forcing use of that primary, eg in Tobruk campaign 2020/08
                        if (mo.PrimaryTargetWeight < 200 && (mo.Destroyed || mo.ObjectiveAchievedForPoints || mo.DestroyedPercent > 2)) continue;
                        //Console.WriteLine("Checking 2" + mo.Name);
                        double r = stb_random.NextDouble() * 200; //was 100.  This will cut chance of everything being chosen, in half.  Except airports and a few other things, which we increased by a lot.  2020-01
                        Console.WriteLine("Select Primary " + mo.PrimaryTargetWeight + " " + r.ToString("N4") + " " + mo.ID + " poinrts req: " + MO_BRBumrushInfo[(ArmiesE)a].PointsRequiredToBeginBumrush.ToString("N0") + totalPoints.ToString("N0")
                            );
                        Point3d pos = mo.returnCurrentPosWithChief();

                        //Except for the very highest-weighted mission objectives, make them more likely to be chosen if near the front,; less likely if distant
                        double frontDistance = GamePlay.gpFrontDistance(mo.AttackingArmy, pos.x, pos.y);
                        double distanceMult = 1;
                        if (mo.PrimaryTargetWeight<100)
                        {
                            
                            if (frontDistance > 240000) distanceMult = 0.1;
                            else if (frontDistance > 160000) distanceMult = 0.2;
                            else if (frontDistance > 80000) distanceMult = 0.4;
                        }

                        if (mo.PrimaryTargetWeight * distanceMult < r) continue; //implement weight; if weight is less than the random number then this one is skipped; so 200% is never skipped, 100% skipped half the time, 50% 3/4 of the time, 0% skipped always
                        //Console.WriteLine("Checking 3" + mo.Name);
                        if (totalPoints < MO_BRBumrushInfo[(ArmiesE)a].PointsRequiredToBeginBumrush)
                        {
                            //Console.WriteLine("Checking 4" + mo.Name);
                            mo.IsPrimaryTarget = true;
                            totalPoints += mo.Points;
                            objectivesList += " - " + mo.lastScoutedSector + " " + mo.Name;
                            Console.WriteLine("Adding new Mission Objective: " + mo.lastScoutedSector + " " + mo.Name + " " + mo.Points.ToString("F0") + " " + totalPoints.ToString("F0"));
                            //if (counter % 3 == 0) MissionObjectivesString[(ArmiesE)a] += Environment.NewLine;
                            counter++;
                        }
                        else
                        {
                            //Console.WriteLine("Checking 5" + mo.Name);
                            mo.IsPrimaryTarget = false;
                        }

                    }

                }
            }
            Console.WriteLine("Selecting/adding new Mission Objectives for " + ArmiesL[army] + ":");
            Console.WriteLine(objectivesList);
        }
        MO_SelectPrimaryObjectiveForGeneralStaffLocation(army);

    }

    public void MO_SelectPrimaryObjectiveForGeneralStaffLocation(int army = 0, double totalPoints = 0)
    {

        List<string> keys = new List<string>(MissionObjectivesList.Keys);
        Calcs.Shuffle(keys);

        List<int> arms = new List<int>();
        if (army == 0) { arms.Add(1); arms.Add(2); }
        else if (army == 1 || army == 2) arms.Add(army);

        Console.WriteLine("Selecting new Mission General Staff Location at a Primary Objective for " + ArmiesL[army]);

        foreach (var a in arms)
        {
            //first, reset all the targets (in this army) to be not the General Staff Location.            
            foreach (var key in keys)
            {
                if (MissionObjectivesList[key].AttackingArmy == a) MissionObjectivesList[key].hasGeneralStaff = false;
            }

            int counter = 1;

            for (int x = 0; x < 15; x++) //unlikely but possible that we'd need to cycle through the list of targets multiple times to get a good location for the GEneral
            {
                bool done = false;
                foreach (var key in keys)
                {
                    //So TOBRUK we can have situations where all of one side's primary objectives are destroyed etc. 
                    //So we gradually loosen up the criteria
                    MissionObjective mo = MissionObjectivesList[key];
                    //2020-08 - avoid ship type for now as obviously that puts the general i nteh water. In future we could change his camp to a small flottilla or something instead.
                    if ((mo.AttackingArmy == a || x > 4) && (mo.IsEnabled | x > 3) && (mo.IsPrimaryTarget || x > 2) && (!mo.Destroyed || x > 0) && ( !mo.ObjectiveAchievedForPoints || x > 1) && !(mo.MOObjectiveType==MO_ObjectiveType.Ship || x > 5))
                    {
                        mo.hasGeneralStaff = true;
                        done = true;
                        break;
                    }
                }
                if (done) break;
            }
        }
    }

    public class GeneralStaffLocationObject
    {
        public Point3d pos { get; set; }
        public string objectiveKey { get; set; }
        public string objectiveName { get; set; }
        public string staffGroupName { get; set; }
        public string sector { get; set; }
        public string sectorKeypad { get; set; }
        public string sectorDoublekeypad { get; set; }
        public bool discovered { get; set; }

        public GeneralStaffLocationObject(Point3d p, string o, string on, string sgn, string s, string sk, string sdk, bool d)
        {
            pos = p;
            objectiveKey = o;
            objectiveName = on;
            staffGroupName = sgn;
            sector = s;
            sectorKeypad = sk;
            sectorDoublekeypad = sdk;
            discovered = d;
        }
    }    

    public Dictionary<ArmiesE, GeneralStaffLocationObject> GeneralStaffLocations = new Dictionary<ArmiesE, GeneralStaffLocationObject>(); //location, objective key, objective name, name of general staff group, sector, sector keypad, sector double keypad, whether discovered yet
    //public Dictionary<ArmiesE, Tuple<Point3d, string, string, string, string, string, string, bool>> GeneralStaffLocations; //location, objective key, objective name, name of general staff group, sector, sector keypad, sector double keypad, whether discovered yet
    public static Dictionary<ArmiesE, string[]> GeneralStaffNames = new Dictionary<ArmiesE, string[]>() //army here is the TARGETING army, so General etc is from the opposite army
    {
        //{ArmiesE.Red, new string [] { "Generalfeldmarschall Kesselring and his staff", "Generalfeldmarschall Sperrle and his staff", "Generalfeldmarschall Kesselring and a few high Luftwaffe officers", "General Jeschonnek and his personal aides", "Luftwaffe General Kreipe and his aides" } },
        {ArmiesE.Red, new string [] { "Generalleutnant Rommel and his staff", "Marshal Balbo and his staff", "General Berti and his Italian Tenth Army staff", "Governor-General Gariboldi and his personal aides", "Lieutenant General Tellera and his staff", "Governor General Graziani and his personal aides"} },
        {ArmiesE.Blue, new string [] { "Lieutenant General Richard O'Connor and a small staff", "Commander-in-Chief Auchinleck and a group of high-ranking officers", "Lieutenant General Alexander and his aides", "Air Chief Marshal Tedder and his staff", "Admiral Cunningham and his aides", "Major General Harding and his command staff", "Lieutenant General Connor and his staff", "General Gott and the 8th Army commanders", "General Montgomery and his commanders", "Lieutenant-General Anderson and his staff officers", "Brigadier McNabb and his aides",
        "Major-General Evelegh and his staff", "Lieutenant-General Allfrey and the GOC V Corps command staff", "Colonel Kœnig and the Free French commanders"}}
    };



    public bool MO_CheckForGeneralStaffReconPhoto(Player player, AiAircraft aircraft, int army, Point3d pos)
    {

        double Z_AltitudeAGL_m = aircraft.getParameter(part.ParameterTypes.Z_AltitudeAGL, 0);
        var gsl = GeneralStaffLocations[(ArmiesE)army];  //Army here is the ATTACKING army, not the OWNER army

        double dist_m = Calcs.CalculatePointDistance(pos, gsl.pos);
        MissionObjective mo = MissionObjectivesList[gsl.objectiveKey];

        string af = "RAF";
        if (army == 1) af = "Luftwaffe"; //again army is ATTACKING army, so if attacking army =1 then the General being attacked is LW not RAF

        if (Z_AltitudeAGL_m < 100 && dist_m < 100)
        {

            if (gsl.discovered)
            {
                string msg = "Sorry, " + gsl.staffGroupName + " were discovered a while ago. But you are in the right area!";
                twcLogServer(new Player[] { player }, msg, new object[] { });
                return true;
            }
            gsl.discovered = true;

            twcLogServer(null, af + gsl.staffGroupName + " found in sector " + gsl.sector + " by " + player.Name(), new object[] { });
            GamePlay.gpHUDLogCenter(null, af + " Commander Found! Good Job, " + ArmiesL[army] + "!");
            Timeout(10, () => {
                twcLogServer(null, "The General's papers and effects are bound to reveal important intelligence.  Results will be broadcast as soon as Photo Intelligence analyzes the photos.", new object[] { });
                });
            return true;
        }
        else if (Calcs.CalculatePointDistance(pos, mo.Pos) < 15000 && Z_AltitudeAGL_m < 300)
        {
            string msg = "You tried to take a recon photo of the " + af + " commanders who were reported in this area.  But there was no trace of them in your photo!";
            twcLogServer(new Player[] { player }, msg, new object[] { });
            msg = "You must be below 100m AGL and within 100m of the target to take the required photo." + (Calcs.CalculatePointDistance(pos, mo.Pos)).ToString() + " " + Z_AltitudeAGL_m.ToString();
            twcLogServer(new Player[] { player }, msg, new object[] { });
            return true;
        }

        string msg2 = "No: " + (Calcs.CalculatePointDistance(pos, mo.Pos)).ToString() + " " + Z_AltitudeAGL_m.ToString();
        twcLogServer(new Player[] { player }, msg2, new object[] { });
        return false;

    }

    public void MO_DisplayGeneralStaffIntelligenceLeaks()
    {

        for (int attackingArmy = 1; attackingArmy < 3; attackingArmy++)
        {
            var gsl = GeneralStaffLocations[(ArmiesE)attackingArmy]; //army here is the ATTACKING army NOT the army the GEneral is part of/leading.
            if (!gsl.discovered) continue;

            int ownerArmy = 3 - attackingArmy;

            MO_ListRemainingPrimaryObjectives(null, ownerArmy, leak: true);

        }
    }


    public void MO_HandleGeneralStaffPlacement()
    {
        List<string> keys = new List<string>(MissionObjectivesList.Keys);

        List<int> arms = new List<int>();
        arms.Add(1); arms.Add(2);

        Console.WriteLine("Handling new Mission General Staff Location at a Primary Objective for both armies");

        foreach (var a in arms)
        {
            bool done = false;
            string staffKey = "";
            for (int x = 0; x < 10; x++)
            {
                //first, reset all the targets (in this army) to be not the General Staff Location.            
                foreach (var key in keys)
                {
                    MissionObjective mo = MissionObjectivesList[key];
                    if (mo.AttackingArmy == a && mo.hasGeneralStaff)
                    {
                        staffKey = key;
                        done = true;
                    }
                }
                if (done) break;
                MO_SelectPrimaryObjectiveForGeneralStaffLocation(a);
            }


            MissionObjective mo1 = MissionObjectivesList[staffKey];

            Point3d newPos = mo1.Pos;
            double adder_m = 1200;


            //try to find a place that is not water, not near an airport, outwards at least mo.radius + adder_m from the center of the objective
            for (int i = 0; i < 25; i++)
            {
                double angle = random.NextDouble() * 2.0 * Math.PI;
                double radius = random.Next(250) + adder_m + mo1.radius + i * 300.0;  //try ever-greater distances if it's not working well

                newPos.x = mo1.Pos.x + Math.Cos(angle) * radius;
                newPos.y = mo1.Pos.y + Math.Sin(angle) * radius;

                maddox.game.LandTypes landType = GamePlay.gpLandType(newPos.x, newPos.y);

                double dist = 5000;
                try
                {
                    AiAirport ap = Calcs.nearestAirport(GamePlay, newPos);
                    dist = Calcs.CalculatePointDistance(ap.Pos(), newPos);
                } catch (Exception ex) { Console.WriteLine("ERROR GENERAL STAFF! " + ex.ToString()); }

                if (landType != maddox.game.LandTypes.WATER && dist > 3500) break;
            }

            var items = new List<string> { "Stationary.Humans.150_cm_SearchLight_Gunner_1", "Stationary.Humans.Soldier_Flak38_Gunner", "Stationary.Humans.RRH_Gunner_1",
                "Stationary.Humans.Em_4m_R(H)34_Gunner_3",
                 "Stationary.Environment.Table_empty_UK-GER_1",
                "Stationary.Environment.Table_empty_UK-GER_1",
                "Stationary.Environment.Table_w_chess_UK-GER_1",
                "Stationary.Environment.Table_w_dinner_UK-GER_1",
                "Stationary.Environment.Table_empty_UK-GER_1",
                "Stationary.Environment.Table_w_chess_UK-GER_1",
                "Stationary.Environment.Table_w_dinner_UK-GER_1",
                "Stationary.Environment.Table_empty_UK-GER_1",
                "Stationary.Environment.Table_w_chess_UK-GER_1",
                "Stationary.Environment.Table_w_dinner_UK-GER_1",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",
                "tobruk:Stationary.TobrukBuilding.Generic.BoardWithMapT",};

            var cars = new List<string> { "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo",
                "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", 
                "Stationary.Opel_Blitz_tent", 
                "Stationary.BMW_R71_w_MG_34",
                "Stationary.BMW_R71_w_MG_34",
                "Stationary.Scammell_Pioneer_R100",
                "Stationary.Scammell_Pioneer_R100",
                "Stationary.Scammell_Pioneer_R100",
                "Stationary.Scammell_Pioneer_R100",
                "Stationary.Horch_830_B1",
                "Stationary.Horch_830_B1",
                "Stationary.Horch_830_B1" };

            string enemy = "de";
            if (a == 2) enemy = "gb";

            var trucks = new List<string> { "Stationary.Morris_CS8", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Morris_CS8", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Morris_CS8", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Opel_Blitz_tent", };

            var camo = new List<string> { "Stationary.Environment.CamoNetCars", "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer", "Stationary.Environment.CamoNetPlane",
            "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer","Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer",
            "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer","Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer",
            "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer","Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetHowitizer",};

            /*Stationary.Albion_AM463
                Stationary.Bedford_MW_tent
                Stationary.Morris_CS8
                */
            //Now actually PLACE the general and various items around there.
            ISectionFile f = GamePlay.gpCreateSectionFile();
            bool resetCount = true;

            //Jerrycan here makes bomb strikes here count as +1 even if in civilian area etc.
            f = Calcs.makeStatic(f, GamePlay, this, newPos.x + random.Next(4), newPos.y + random.Next(3), newPos.z, type: "Stationary.Environment.JerryCan_GER1_1", heading: random.Next(360), side: "nn");
            resetCount = false;

            Calcs.Shuffle(items);
            for (int i = 0; i < 9; i++) {

                string side = "nn";
                if (random.Next(6) == 0) side = enemy; //setting them as enemy makes them show up as black dots.  These are small so should be pretty dim black dots.

                //Timeout(10 + 2 * i, () =>
                //{ 
                f = Calcs.makeStatic(f, GamePlay, this, newPos.x + random.Next(10), newPos.y + random.Next(10), newPos.z, type: items[i], heading: random.Next(360), side: side, resetCount: resetCount);
                resetCount = false;
                //});
            }



            double hdg = random.Next(360);
            Calcs.Shuffle(cars);
            for (int i = 0; i < 4; i++)
            {
                double angle1 = i * 2.0 / 4.0 * Math.PI + random.NextDouble();
                double radius2 = random.Next(8) + 10;

                double nex = newPos.x + Math.Cos(angle1) * radius2;
                double ney = newPos.y + Math.Sin(angle1) * radius2;

                string side = "nn";
                if (random.Next(7) == 0) side = enemy;

                //Timeout(30 + 2 * i, () =>
                //{
                f = Calcs.makeStatic(f, GamePlay, this, nex, ney, newPos.z, type: cars[i], heading: hdg + random.Next(15), side: side);
                //});
            }

            Calcs.Shuffle(trucks);
            for (int i = 0; i < 7; i++)
            {
                double angle1 = i * 2.0 / 7.0 * Math.PI + random.NextDouble();
                double radius2 = random.Next(5) + 12;

                double nex = newPos.x + Math.Cos(angle1) * radius2;
                double ney = newPos.y + Math.Sin(angle1) * radius2;

                string side = "nn";
                if (random.Next(8) == 0) side = enemy;

                //Timeout(50 + 2 * i, () =>
                //{
                f = Calcs.makeStatic(f, GamePlay, this, nex, ney, newPos.z, type: trucks[i], heading: hdg + random.Next(15), side: side);
                //});
            }

            Calcs.Shuffle(camo);
            for (int i = 0; i < 15; i++)
            {
                //double angle1 = i * 2.0 / 7.0 * Math.PI + random.NextDouble();
                //double radius2 = random.Next(5) + 12;

                double nex = 0;
                double ney = 0;

                while (Calcs.CalculatePointDistance(new Point3d(nex, ney, 0), newPos) > 20) {
                    nex = newPos.x + random.Next(40) - 20;
                    ney = newPos.y + random.Next(40) - 20;
                    if (random.Next(30) == 0) break; //safety exit
                }                

                string side = "nn"; //Camo is always "neutral"
                //if (random.Next(5) == 0) side = enemy;

                //Timeout(50 + 2 * i, () =>
                //{
                f = Calcs.makeStatic(f, GamePlay, this, nex, ney, newPos.z, type: camo[i], heading: hdg + random.Next(15), side: side);
                //});
            }


            GamePlay.gpPostMissionLoad(f);
            f.save(CLOD_PATH + FILE_PATH + "/sectionfiles/" + "generals-ISectionFile"+random.Next(0,9)); //testing


            Console.WriteLine("The general staff near a {0} objective is at {1} - ({2:F0},{3:F0})", new object[] { ArmiesL[a], staffKey, newPos.x, newPos.y });
            Console.WriteLine("msn {0} objective)", new object[] { this as Mission != null });
            Console.WriteLine("msn {0} {1} {2} {3} {4} {5} {6} {7} objective)", new object[] {newPos, staffKey, mo1.Name,    GeneralStaffNames[(ArmiesE)a][1],
            Calcs.correctedSectorName(this as Mission, newPos),
            Calcs.correctedSectorNameKeypad(this as Mission, newPos),
            Calcs.correctedSectorNameDoubleKeypad(this as Mission, newPos),
            false
            });
            GeneralStaffLocationObject gslo = null;
            try
            {
                gslo = new GeneralStaffLocationObject(newPos, staffKey, mo1.Name,
                    //Calcs.randSTR(GeneralStaffNames[(ArmiesE)a]), //name of leader/group
                    GeneralStaffNames[(ArmiesE)a][1], //name of leader/group
                    Calcs.correctedSectorName(this as Mission, newPos),
                    Calcs.correctedSectorNameKeypad(this as Mission, newPos),
                    Calcs.correctedSectorNameDoubleKeypad(this as Mission, newPos),
                    false
                    );
            } catch (Exception ex) { Console.WriteLine("gslo error! " + ex.ToString()); }
            //GeneralStaffLocations[(ArmiesE)a] =
            GeneralStaffLocations[(ArmiesE)a] = gslo;
            Console.WriteLine("The general staff near a {0} objective is at {1} - ({2:F0},{3:F0})", new object[] { ArmiesL[a], staffKey, newPos.x, newPos.y });

        }
    }



    public static List<string> MO_Trucks = new List<string> { "Stationary.Morris_CS8", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Morris_CS8", "Stationary.Matilda_2A", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Morris_CS8", "Stationary.Morris_CS8_tent", "Stationary.Bedford_MW_tent", "Stationary.Albion_AM463", "Stationary.Fordson_Sussex_w_ballon", "Stationary.Panzerbefehlswagen_I", "Stationary.Environment.CamoNetTank", "Stationary.Ammo_Vehicles.10_5cm_LeFH18_Composition3_GER", "Stationary.Ford_G917", "Stationary.Ford_V8_E917_tent", "Stationary.Unic_P107", "Stationary.Fordson_Sussex_w_o_ballon", "Stationary.Guy_Quad-Ant", "Stationary.Horch_108_Typ_1A", "Stationary.Guy_Lizard", "Stationary.GER_Fuel_Column", "Stationary.Kubelwagen", "Stationary.Krupp_L2H43_Protze_Kfz69", "Stationary.Horch_108_Typ_1A_open", "Stationary.Opel_Blitz_radio", "Stationary.SdKfz_9_Crane", "Stationary.FIAT_OCI_708", "Stationary.Truck_Renault_UE", "Stationary.Opel_Blitz_radio", };

    public static List<string> MO_Armor_Tanks = new List<string> { "Stationary.SdKfz_10_1", "Stationary.SdKfz_231_6Rad", "Stationary.SdKfz_263_6Rad", "Stationary.SdKfz_263_6Rad", "Stationary.SdKfz_7", "Stationary.SdKfz_9", "Stationary.Thorneycroft_Bison", "Stationary.Bataille_B1_Bis", "Stationary.Breen_Carrier_Mk_I", "Stationary.Cruiser_Mk_IV", "Stationary.Pz_IIIF", "Stationary.Renault_Ft17", "Stationary.Somua_S35", "Stationary.Panzerbefehlswagen_I", "Stationary.SdKfz_232_8Rad", "Stationary.StuG_IIIA", "Stationary.Valentine_I", "Stationary.Vickers_Mk_VIB", "Stationary.Vickers_Mk_VIC", };

    public static List<string> MO_Cars = new List<string> { "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo",
                "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo", "Stationary.Opel_Blitz_cargo",
                "Stationary.BMW_R71_w_MG_34","Stationary.BMW_R71_w_MG_34","Stationary.Scammell_Pioneer_R100","Stationary.Scammell_Pioneer_R100","Stationary.Scammell_Pioneer_R100",
                "Stationary.Scammell_Pioneer_R100","Stationary.Horch_830_B1","Stationary.Horch_830_B1","Stationary.Horch_830_B1" };

    public static List<string> MO_Humans = new List<string> { "Stationary.Humans.150_cm_SearchLight_Gunner_1", "Stationary.Humans.Soldier_Flak38_Gunner", "Stationary.Humans.RRH_Gunner_1",
                    "Stationary.Humans.Em_4m_R(H)34_Gunner_3", "Stationary.Humans.Soldier_Horch_108_open_Gunner", "Stationary.Humans.Soldier_PaK_35_36_Gunner_1", "Stationary.Humans.Soldier_PaK_35_36_Gunner_2",
        "Stationary.Humans.Soldier_10_5_cm_LeFH_18_Gunner_1", "Stationary.Humans.Soldier_10_5_cm_LeFH_18_Gunner_2", "Stationary.Humans.RRH_Gunner_1","Stationary.Humans.RRH_Gunner_2",
        "Stationary.Humans.Soldier_40mm_2pdr_AT_Gun_Passenger_1","Stationary.Humans.Soldier_Beaverette_III_Gunner_1","Stationary.Humans.Soldier_AEC_Regent_III_Passenger_2",
        "Stationary.Humans.150_cm_Flakscheinwerfer_gunner1","Stationary.Humans.150_cm_Flakscheinwerfer_gunner2","Stationary.Humans.Em_4m_R(H)34_Gunner_1","Stationary.Humans.Em_4m_R(H)34_Gunner_2",
        "Stationary.Humans.Em_4m_R(H)34_Gunner_3", "Stationary.Humans.Gulaschkanone_passenger_1","Stationary.Humans.Gulaschkanone_passenger_2","Stationary.Humans.Gulaschkanone_passenger_3",
        "Stationary.Humans.Gulaschkanone_passenger_4","Stationary.Humans.Gulaschkanone_passenger_5","Stationary.Humans.Gulaschkanone_passenger_6","Stationary.Humans.Kdo_Hi_Ger35_passenger_1",
        "Stationary.Humans.Kdo_Hi_Ger35_passenger_2","Stationary.Humans.Kdo_Hi_Ger35_passenger_3","Stationary.Humans.Kdo_Hi_Ger35_passenger_4",};

    public static List<string> MO_Tables = new List<string>() {
                     "Stationary.Environment.Table_empty_UK-GER_1",
                    "Stationary.Environment.Table_empty_UK-GER_1",
                    "Stationary.Environment.Table_w_chess_UK-GER_1",
                    "Stationary.Environment.Table_w_dinner_UK-GER_1",
                    };


    public static List<string> MO_Radar = new List<string> { "Stationary.RadioBeacon.GenericLongRangeMast", "Stationary.Radar.EnglishRadar1", "Stationary.Radar.EnglishRadar2", "Stationary.Radar.EnglishRadar3", "Stationary.Radar.Wotan_I", "Stationary.Radar.Wotan_II", "Stationary.Radar.Wotan_II_ADD1", "Stationary.Radar.Wotan_II_ADD2", "Stationary.RadioBeacon.GenericLongRangeMast", "Stationary.Opel_Blitz_radio", };

    public static List<string> MO_Small_Radar = new List<string> { "Stationary.Radar.Wotan_I", "Stationary.Radar.Wotan_II", "Stationary.Opel_Blitz_radio", };

    public static List<string> MO_Jerrycan71 = new List<string> { "Stationary.Environment.JerryCan_GER1_1" }; //71, 141 etc refers to the radius this jerrycan covers - for purposes of giving players credit for bombing nearby areas.
    public static List<string> MO_Jerrycan141 = new List<string> { "Stationary.Environment.JerryCan_GER1_2" };
    public static List<string> MO_Jerrycan282 = new List<string> { "Stationary.Environment.JerryCan_GER1_3" };
    public static List<string> MO_Jerrycan1410 = new List<string> { "Stationary.Environment.JerryCan_GER1_5" };

    public static List<string> MO_GBBombers = new List<string> { "Stationary.WellingtonMkIc", "Stationary.BlenheimMkIV" };

    public static List<string> MO_GBFighters = new List<string> { "Stationary.SpitfireMkIa", "Stationary.HurricaneMkI_dH5-20", "Stationary.GladiatorMkII" };

    public static List<string> MO_DEFighters = new List<string> { "Stationary.Bf-109E-1", "Static1558 Stationary.Bf-110C-7", "Stationary.Bf-109E-3B" };

    public static List<string> MO_DEBombers = new List<string> { "Stationary.Bf-108B-2", "Stationary.Ju-88A-1", "Stationary.Do-17Z-2" };

    public static List<string> MO_Buildings = new List<string> { "Stationary.Airfield.Fuel_Storage", "Stationary.Industrial.Railroad.SmallFactory" };

    public static List<string> MO_Misc = new List<string> { "Stationary.Environment.CamoNetCrates", "Stationary.Environment.TelegaBallon_UK1", "Stationary.Environment.CamoNetHowitizer", "Stationary.Environment.FuelDrum_UK1_9", "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetPlane", "Stationary.Environment.Zwillingssockel36_Base_GER1", "Stationary.13T_Flat_ContainerA", "Stationary.13T_Flat_ContainerA", "Stationary.13T_Flat_ContainerBM", "Stationary.13T_Flat_ContainerBM", "Stationary.Morris_CS8-Bedford_MW_CargoAmmo1", "Stationary.Morris_CS8-Bedford_MW_CargoAmmo1", "Stationary.Morris_CS8-Bedford_MW_CargoAmmo2", "Stationary.Morris_CS8-Bedford_MW_CargoAmmo4", "Stationary.Morris_CS8-Bedford_MW_CargoCrate10", "Stationary.Morris_CS8-Bedford_MW_CargoFuel", "Stationary.Morris_CS8-Bedford_MW_CargoFuel", "Stationary.Morris_CS8-Bedford_MW_CargoFuel2", "Stationary.Morris_CS8-Bedford_MW_CargoFuel2", "Stationary.Morris_CS8-Bedford_MW_Cargo2", "Stationary.Morris_CS8-Bedford_MW_Cargo2", "Stationary.Morris_CS8-Bedford_MW_Cargo3", "Stationary.Morris_CS8-Bedford_MW_Cargo4", "Stationary.Renault_UE_Track_CargoSet3", "Stationary.Renault_UE_Track_CargoSet4", "Stationary.Environment.FieldKitchen_UK1", "Stationary.Environment.Gulaschkanone_GER1", };

    public static List<string> MO_Camo = new List<string> { "Stationary.Environment.CamoNetCrates", "Stationary.Environment.CamoNetAT", "Stationary.Environment.CamoNetPlane", "Stationary.Environment.CamoNetPlaneBig", "Stationary.Environment.CamoNetTank" };

    //taking out medic tent for now even though it's one of our best tents.  Maybe it has another skin.  But no war criminals for us . . . .
    public static List<string> MO_Tents = new List<string> { "Stationary.Environment.TentTroopLarge_GER1", "Stationary.Environment.TentRidgeTent_UK1", /*"Stationary.Environment.TentMedicLarge_UK1", */ "Stationary.Environment.FieldKitchen_UK1", "Stationary.Environment.TentBell_UK1", "Stationary.Environment.TentBell_UK1", "Stationary.Environment.TentSmall_UK1", "Stationary.Environment.TentStaffBig_GER1", "Stationary.Environment.TentStaffSmall_GER1", "Stationary.Environment.TentTroopLarge_GER1", "Stationary.Environment.TentZeltbahn_GER1", "Stationary.Environment.TentZeltbahnBig_GER1", };

    public static List<string> MO_Sandbags = new List<string> { "Stationary.Environment.SandBagWall_Line_12m", "Stationary.Environment.SandBagWall_Line", "Stationary.Environment.SandBagWall_Line_12m", "Stationary.Environment.SandBagWall_Line_4m", "Stationary.Environment.SandBagWall_Line_8m", "Stationary.Environment.SandBagWall_Line_8m", "Stationary.Environment.SandBagWall_Arch", };

    public static List<string> MO_Trenches = new List<string> { "Stationary.Trenches.Trench_Front", "Stationary.Trenches.Trench_10m_diameter", "Stationary.Trenches.Trench_3m_diameter", "Stationary.Trenches.Trench_6m_diameter", "Stationary.Trenches.Trench_30_degrees", "Stationary.Trenches.Trench_45_degrees", "Stationary.Trenches.Trench_60_degrees", "Stationary.Trenches.Trench_direct", "Stationary.Trenches.Trench_direct_15m", "Stationary.Trenches.Trench_direct_25m", "Stationary.Trenches.Trench_T_type", "Stationary.Trenches.Trench_T_type", };

    public static List<string> MO_Hedgehogs = new List<string> { "Stationary.Environment.Hedgehog_01", "Stationary.Environment.DragonTeethBig", "Stationary.Environment.DragonTeethSmall", "Stationary.Environment.DragonTeethSmall", };

    public static List<string> MO_Sentry = new List<string> { "Stationary.Environment.Sentry-Box_UK-GER_1", "Stationary.Environment.GuardTower_UK-GER_1" };

    public static List<string> MO_Detritus = new List<string> { "Stationary.Environment.SandBagWall_Line_4m", "Stationary.Environment.FuelDrum_UK1_9", "Stationary.Environment.Zwillingssockel36_Base_GER1", "Stationary.DamagedCar.Opel_Blitz_tent_MDG", "Stationary.Environment.Anlasswagen_(starter)_GER1_DMG1", "Stationary.Environment.Anlasswagen_(starter)_GER1_DMG1", "Stationary.Environment.TentStaffSmall_GER1_DMG1", "Stationary.Environment.TentTroopLarge_GER1_DMG1", "Stationary.Environment.TentZeltbahnBig_GER1_DMG1", "Stationary.Environment.TentMedicLarge_UK1_DMG1", "Stationary.Environment.Starter_UK1_DMG1", "Stationary.Environment.Kdo_Hi_Ger35_GER1_DMG1", "Stationary.Environment.Ladder_UK2_DMG1", "Stationary.Environment.Maschinensatz_15_KW_GER1_DMG1", "Stationary.Environment.TelegaBallon_UK1_DMG1", "Stationary.Environment.Gulaschkanone_GER1_DMG1", "Stationary.Environment.BombSled_GER1_DMG1", "Stationary.Environment.Telega_UK-GER_1_DMG1", "Stationary.Damaged.Airfield.Planelifter_UK2_DMG1", "Stationary.Environment.FieldKitchen_UK1_DMG1", "Stationary.Environment.Ladder_UK1_DMG1", "Stationary.Environment.RRH_GER1_DMG1", };

    public class MO_ThingsTypeNumberRadius
    {
        public List<string> things { set; get; }
        public int howmany { set; get; } //approx how many to place
        public double radius_m { set; get; } //approx radius from center to place them.  This will vary by +/- 20% or so
        public double range_m { set; get; } //Range this far in/out from the radius.  So radius 10m, range 10m will place the objects from 0 to 20m from the center.

        public MO_ThingsTypeNumberRadius(List<string> t, int hm = 7, double rm = 25, double rn = 25)
        {
            things = t;
            howmany = hm;
            radius_m = rm;
            range_m = rn;
        }
        public MO_ThingsTypeNumberRadius(MO_ThingsTypeNumberRadius mttnr)
        {
            things = mttnr.things;
            howmany = mttnr.howmany;
            radius_m = mttnr.radius_m;
            range_m = mttnr.range_m;

        }
    }

    public Dictionary<MO_MobileObjectiveType, Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>> mo_mobileobjectivethings = new Dictionary<MO_MobileObjectiveType, Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>>()
    {
         { MO_MobileObjectiveType.SecretAirbaseGB,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 7, 55, 50) },
                { MO_MobileObjectiveThings.Buildings, new MO_ThingsTypeNumberRadius( MO_Buildings, 2, 20, 17 ) },
                { MO_MobileObjectiveThings.GBFighters, new MO_ThingsTypeNumberRadius( MO_GBFighters, 2, 62, 20 ) },
                { MO_MobileObjectiveThings.GBBombers, new MO_ThingsTypeNumberRadius( MO_GBBombers, 3, 102, 20) },
                { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 7, 150, 1) },
                { MO_MobileObjectiveThings.Trenches, new MO_ThingsTypeNumberRadius(MO_Sandbags, 25, 175, 0.25) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 80, 180, 0.2) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 200, 20) },

            }
        },

        { MO_MobileObjectiveType.SecretAirbaseDE,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 8, 30,30) },
                { MO_MobileObjectiveThings.Buildings, new MO_ThingsTypeNumberRadius( MO_Buildings, 2, 20, 20) },
                { MO_MobileObjectiveThings.DEFighters, new MO_ThingsTypeNumberRadius( MO_DEFighters, 3, 65, 20) },
                { MO_MobileObjectiveThings.DEBombers, new MO_ThingsTypeNumberRadius( MO_DEBombers, 3, 95, 20) },
                { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 7, 150, 1) },
                { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 25, 175, 0.25) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 80, 179, 0.2) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 200, 20) },

            }
        },


         { MO_MobileObjectiveType.SecretAircraftResearchGB,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 7, 15, 12) },
                { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius( MO_Buildings, 3, 40, 20) },
                { MO_MobileObjectiveThings.DEFighters, new MO_ThingsTypeNumberRadius( MO_DEFighters, 3, 65, 20) },
                { MO_MobileObjectiveThings.DEBombers, new MO_ThingsTypeNumberRadius( MO_DEBombers, 4, 85, 20) },
                { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 7, 135, 1) },
                { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 35, 155, 0.25) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 60, 162, 3) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 200, 20) },

            }
         },

         { MO_MobileObjectiveType.SecretAircraftResearchDE,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 7, 15, 12) },
                { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius( MO_Buildings, 3, 40, 20) },
                { MO_MobileObjectiveThings.GBFighters, new MO_ThingsTypeNumberRadius( MO_GBFighters, 3, 60, 20) },
                { MO_MobileObjectiveThings.GBBombers, new MO_ThingsTypeNumberRadius( MO_GBBombers, 4, 80, 20) },
                { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 7, 135, 1) },
                { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 35, 155, 0.25) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 60, 161, 2) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 200, 20) },

            }
        },

        { MO_MobileObjectiveType.ArmyEncampment,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 5, 15, 12) },
                { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius( MO_Tables, 5, 10, 8) },
                { MO_MobileObjectiveThings.Tents, new MO_ThingsTypeNumberRadius(MO_Tents, 5, 25, 10) },
                { MO_MobileObjectiveThings.Trucks, new MO_ThingsTypeNumberRadius(MO_Trucks, 7, 35, 5) },
                { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 5, 50, 2) },
                { MO_MobileObjectiveThings.Trenches, new MO_ThingsTypeNumberRadius(MO_Trenches, 12, 50, 0.2) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 30, 53, 2) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 80, 20) },

            }
        },

        { MO_MobileObjectiveType.SmallArmourGroup,
            new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 5, 10, 8) },
                { MO_MobileObjectiveThings.Tents, new MO_ThingsTypeNumberRadius(MO_Tents, 4, 15, 10) },
                { MO_MobileObjectiveThings.Armor_Tanks, new MO_ThingsTypeNumberRadius(MO_Armor_Tanks, 7, 30, 5) },
                { MO_MobileObjectiveThings.Camo, new MO_ThingsTypeNumberRadius(MO_Camo, 10, 30, 25) },
                { MO_MobileObjectiveThings.Misc, new MO_ThingsTypeNumberRadius(MO_Misc, 7, 22, 18) },
                { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 12, 45, 0.5) },
                { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 15, 53, 4) },
                { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 100, 30) },

            }
        },

            { MO_MobileObjectiveType.LargeArmourGroup,
                new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                    { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 15, 10, 8) },
                    { MO_MobileObjectiveThings.Tents, new MO_ThingsTypeNumberRadius(MO_Tents, 8, 20, 15) },
                    { MO_MobileObjectiveThings.Armor_Tanks, new MO_ThingsTypeNumberRadius(MO_Armor_Tanks, 15, 40, 5) },
                    { MO_MobileObjectiveThings.Misc, new MO_ThingsTypeNumberRadius(MO_Misc, 14, 25, 20) },
                    { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 22, 60, 0.2) },
                    //{ MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 32, 67, 3 ) },
                    { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 120, 30) },


                }
            },
            { MO_MobileObjectiveType.CamoGroup,
                new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>() {

                    { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius( MO_Humans, 10, 15, 12) },
                    { MO_MobileObjectiveThings.Tents, new MO_ThingsTypeNumberRadius(MO_Tents, 4, 17, 12) },
                    { MO_MobileObjectiveThings.Camo, new MO_ThingsTypeNumberRadius(MO_Camo, 8, 40, 25) },
                    { MO_MobileObjectiveThings.Misc, new MO_ThingsTypeNumberRadius(MO_Misc, 12, 40, 35) },
                    { MO_MobileObjectiveThings.Sentry, new MO_ThingsTypeNumberRadius(MO_Sentry, 4, 70, 2) },
                    { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 16, 75, 0.1) },
                    { MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 32, 83, 5) },
                    { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 2, 140, 30) },
                }
            },
            { MO_MobileObjectiveType.MobileRadar1,
                new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>(){

                    { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius(MO_Humans,5, 12, 7 )},
                    { MO_MobileObjectiveThings.Trucks, new MO_ThingsTypeNumberRadius(MO_Trucks,3, 40, 10 )},
                    { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius(MO_Tables, 3, 15, 7 )},
                    { MO_MobileObjectiveThings.Radar, new MO_ThingsTypeNumberRadius(MO_Radar, 2, 15, 10 )},
                    { MO_MobileObjectiveThings.Camo, new MO_ThingsTypeNumberRadius(MO_Camo, 12, 15, 13) },
                    { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 22, 65, 0.3) },
                    //{ MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 44, 71, 3) },                    
                }
            },
                    { MO_MobileObjectiveType.MobileRadar2,
                    new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>(){
                    { MO_MobileObjectiveThings.Buildings, new MO_ThingsTypeNumberRadius(MO_Buildings, 1, 3, 3 )},
                    { MO_MobileObjectiveThings.Humans, new MO_ThingsTypeNumberRadius(MO_Humans,8, 25, 20 )},
                    { MO_MobileObjectiveThings.Trucks, new MO_ThingsTypeNumberRadius(MO_Trucks,3, 50, 20 )},
                    { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius(MO_Tables, 3, 25, 20 )},
                    { MO_MobileObjectiveThings.Camo, new MO_ThingsTypeNumberRadius(MO_Camo, 10, 30, 25) },
                    { MO_MobileObjectiveThings.Radar, new MO_ThingsTypeNumberRadius(MO_Radar, 3, 30, 20 )},
                    { MO_MobileObjectiveThings.Sandbags, new MO_ThingsTypeNumberRadius(MO_Sandbags, 22, 75, 0.2) },
                    //{ MO_MobileObjectiveThings.Hedgehogs, new MO_ThingsTypeNumberRadius(MO_Hedgehogs, 44, 85, 7) },

                }
            },
                    { MO_MobileObjectiveType.DesertRadar,
                    new Dictionary<MO_MobileObjectiveThings, MO_ThingsTypeNumberRadius>(){
                   
                    { MO_MobileObjectiveThings.Trucks, new MO_ThingsTypeNumberRadius(MO_Trucks, 2, 40, 20 )},
                    { MO_MobileObjectiveThings.Tables, new MO_ThingsTypeNumberRadius(MO_Tables, 4, 4, .3 )},
                    //{ MO_MobileObjectiveThings.Camo, new MO_ThingsTypeNumberRadius(MO_Camo, 1, 8, 3) },
                    { MO_MobileObjectiveThings.Small_Radar, new MO_ThingsTypeNumberRadius(MO_Small_Radar, 1, 120, 30) },

                }
            },

        };

    //Stretches the circle to make it a bit non circular or oblong or whatever.
    //Needs to be some kind of function that is continuous 0-2pi & f(0)==f(2pi)
    public double circleStretcher(double ang, double stretcherAmt, int type)
    {
        double ret = 0;
        double PI = Math.PI;
        double PI2 = 2.0 * PI;
        //each function should range 0 to 1; we multiply by stretcher in the end so it will range 0 to stretcher
        if (type == 0)
        {

        }
        else if (type == 1)
        {
            ret = ang / PI2;
            ret = ang % 1;
            if (ret > 0.5) ret = 1 - ret;
        }

        ret *= stretcherAmt;
        return ret;

    }


    //subHeading -1, choose a random heading for each object
    //subHeading -2 means align with the circle perimeter, ie tangent to the circle
    //variance is a random amount the object will be moved inside OR outside the circle radius (up to variance_m distance plus or minus)
    public ISectionFile PlaceObjectsInCircles(ISectionFile f, List<string> things, Point3d newPos, double radius_m, double variance_m, int howmany, int army, int percentSide = 33, double subHeading = -1,
        int stretcherType = 0, double stretcherAmt = 0, bool avoidWater = false, bool resetCount = false)
    {
        string ownerside = "nn";
        if (army == 2) ownerside = "de";
        if (army == 1) ownerside = "gb";


        //Calcs.Shuffle(things);
        howmany += random.Next(howmany / 4) - howmany / 8; //slightly randomize howmany
        //Console.WriteLine("Cirles: " + howmany.ToString());

        bool rstCnt = resetCount;

        for (int i = 0; i < howmany; i++)
        {

            string side = "nn";
            if (random.Next(100) < percentSide) side = ownerside; //setting them as enemy makes them show up as black dots. So some, but not all.

            double angle1 = 0;

            Point3d thingPos = new Point3d(newPos.x, newPos.y, newPos.z);
            if (radius_m <= 5)
            {
                thingPos.x = newPos.x + (random.NextDouble() * 2.0 - 1.0) * radius_m;
                thingPos.y = newPos.y + (random.NextDouble() * 2.0 - 1.0) * radius_m;
            }
            else
            {

                angle1 = i * 2.0 / howmany * Math.PI + random.NextDouble() / howmany * Math.PI * 2.0 / 3.0;
                double radius1 = radius_m + (circleStretcher(angle1, stretcherAmt, stretcherType));
                double radius2 = (random.NextDouble() * 2.0 - 1.0) * variance_m + radius1; //vary by up to variance amount, plus or minus from given radius.

                thingPos.x = newPos.x + Math.Cos(angle1) * radius2;
                thingPos.y = newPos.y + Math.Sin(angle1) * radius2;
            }

            double subsubHeading = subHeading + random.Next(24) - 12;
            if (subHeading == -1) subsubHeading = random.Next(360);
            if (subHeading == -2) subsubHeading = Calcs.RadiansToDegrees(angle1); //reverse angle seems to work best (otherwise angle trenches etc are angled the wrong way relative to the circle) 2020/02/24 now trying the original angle as the arch sandbags seem reversed & are common
            //Console.WriteLine("Cirles: {0:F2} {1:F2} {2:F2} " + howmany.ToString(), angle1, subHeading, subsubHeading);


            if (avoidWater) thingPos = MO_FindNoWaterPos(thingPos, radius_m);

            int ranThing = random.Next(things.Count);
            f = Calcs.makeStatic(f, GamePlay, this, thingPos.x + random.Next(2), thingPos.y + random.Next(2), thingPos.z, type: things[ranThing], heading: subsubHeading, side: side, resetCount: rstCnt);
            rstCnt = false;

        }
        return f;
    }

    public double MO_CalcMobileObjRadius_m(MissionObjective mo)
    {
        if (mo.MOMobileObjectiveType != MO_MobileObjectiveType.None)
        {
            var things = mo_mobileobjectivethings[mo.MOMobileObjectiveType];

            double searchRadius_m = 50;

            foreach (MO_MobileObjectiveThings t in things.Keys)
            {
                MO_ThingsTypeNumberRadius mttnr = new MO_ThingsTypeNumberRadius(things[t]);
                if (mttnr.radius_m > searchRadius_m) searchRadius_m = mttnr.radius_m;
            }
            return searchRadius_m;
        } else
        {
            return mo.radius;
        }

    }

    public bool MO_WaterInRadius(Point3d p, double radius_m)
    {
        Point3d testPos = new Point3d(0, 0, 0);
        for (int i = 1; i < 300; i++)
        {
            double angle1 = i; //radians
            double radius2 = i * radius_m / 200.0;
            testPos.x = p.x + Math.Cos(angle1) * radius2;
            testPos.y = p.y + Math.Sin(angle1) * radius2;
            maddox.game.LandTypes landType = GamePlay.gpLandType(testPos.x, testPos.y);
            if (landType == maddox.game.LandTypes.WATER) return true;
        }
        return false;
    }

    //check if the pos is on water and if so try to return a new non-water pos withing the given radius
    //If it fails thne it just returns the initial point
    public Point3d MO_FindNoWaterPos(Point3d p, double radius_m)
    {
        Point3d testPos = p; //preserves p.z value
        for (int i = 0; i < 300; i++)
        {
            double angle1 = i; //radians
            double radius2 = i * radius_m / 200.0;
            testPos.x = p.x + Math.Cos(angle1) * radius2;
            testPos.y = p.y + Math.Sin(angle1) * radius2;
            maddox.game.LandTypes landType = GamePlay.gpLandType(testPos.x, testPos.y);
            if (landType != maddox.game.LandTypes.WATER) return testPos;
        }
        return p;
    }

    public void MO_PlaceDetritusInObjectArea(MissionObjective mo, int numDetrit = 8, int rangeDetrit = 6, bool placeSmoke = true, double searchRadius_m = 0)
    {
        Console.WriteLine("Placing detritus field at " + mo.ID + " " + mo.Name);

        if (searchRadius_m == 0) searchRadius_m = MO_CalcMobileObjRadius_m(mo);
        double stretchA = (searchRadius_m + 40) / 3.0 * random.NextDouble();

        //7 * Math.Pow(Math.Ceiling(searchRadius_m/1000),2) - say it takes 7 Jerrycan282 to cover 1000m radius, if it is 2000m the amount increases by the ^2, etc

        ISectionFile f = GamePlay.gpCreateSectionFile();
        f = PlaceObjectsInCircles(f, MO_Detritus, mo.Pos, searchRadius_m / 2, 4.0 * searchRadius_m / 5.0, numDetrit + random.Next(rangeDetrit), mo.OwnerArmy, percentSide: 70, subHeading: -1, stretcherType: 1, stretcherAmt: stretchA, resetCount: true);
        //f = PlaceObjectsInCircles(f, MO_Jerrycan282, mo.Pos, searchRadius_m / 2, 4.0 * searchRadius_m / 5.0, 7 * Math.Pow(Math.Ceiling(searchRadius_m/1000),2), mo.OwnerArmy, percentSide: 70, subHeading: -1, stretcherType: 1, stretcherAmt: stretchA);

        Timeout(55, () => //no rush here, better to wait a bit
        {
            GamePlay.gpPostMissionLoad(f);

            f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/detritusobj_" + mo.ID); //testing)

            Point3d smokePos = new Point3d(mo.Pos.x + (random.NextDouble() * 2.0 - 1.0) * searchRadius_m, mo.Pos.y + (random.NextDouble() * 2.0 - 1.0) * searchRadius_m, -15); //try -z position to see if it will make a diff effect

            smokePos = MO_FindNoWaterPos(smokePos, searchRadius_m + 40);

            if (placeSmoke) Calcs.loadSmokeOrFire(GamePlay, this, smokePos.x, smokePos.y, smokePos.z, "BuildingFireSmall", 24 * 3600);

            MO_PlaceAppropriateJerrycan(mo); //there is still a jerrycan there so players can get stats points for bombing it, but there is just no objective here any more.
        });

    }

    public void MO_RemoveObjective(MissionObjective mo)
    {
        Task.Run(() =>
        {
            //var things = mo_mobileobjectivethings[mo.MOMobileObjectiveType]; //only valid for  mobileobjective types , and we're not using it yet.

            Console.WriteLine("Removing objective statics at " + mo.ID + " " + mo.Name);

            double searchRadius_m = MO_CalcMobileObjRadius_m(mo);

            List<GroundStationary> gs = GamePlay.gpGroundStationarys(mo.Pos.x, mo.Pos.y, searchRadius_m + 40).ToList();
            foreach (GroundStationary g in gs) Timeout(random.Next(20, 1200), () => { g.Destroy(); }); //COULD check to make sure they are the same type we placed, here.
                                                                                                       //Timeout makes the group disappear gradually over time but ALSO avoids the issue with deleting items in the list while looping it

            MO_PlaceDetritusInObjectArea(mo, searchRadius_m: searchRadius_m);
        });

    }

    //Designed so that you can send every objective to this routine at the start of the session and several time throughout, and it will
    //just return on any non-mobile objectives, and do nothing if the objective doesn't need to be changed/updated
    //On startup it will draw all objectives in place, even if it is not their time to change location.
    public void MO_HandleMobileObjectivePlacement(MissionObjective mo, bool startup = false)
    {
        if (mo == null || mo.MOMobileObjectiveType == null || mo.MOMobileObjectiveType == MO_MobileObjectiveType.None) return;

        DateTime currTime = DateTime.UtcNow;

        if (!mo.IsEnabled) {

            if (mo.MobileNextMoveTime_dt.HasValue && !startup) MO_RemoveObjective(mo); //if disabled and placed (ie, has value), just remove it
            mo.MobileNextMoveTime_dt = null;
            //if (startup) MO_PlaceDetritusInObjectArea(mo); //if startup & !enabled, then just place the detritus.  Ok, we're doing this for ALL disabled objectives now, not just the mobile ones.  So skip it here.
            return;
        }

        if (!startup && mo.MobileNextMoveTime_dt.HasValue && mo.MobileNextMoveTime_dt.Value.CompareTo(currTime) > 0) return; //only update them at start of session OR if their nextmovetime is null OR in the past

        if (GamePlay == null)
        {
            Console.Write("");
            Console.Write("MO_HandleMobileObjectivePlacement: MAJOR ERROR *************************************************** ");
            Console.Write("MO_HandleMobileObjectivePlacement: MAJOR ERROR GamePlay not initialized, nothing done.  Exiting routine. " + mo.Name );
            Console.Write("MO_HandleMobileObjectivePlacement: MAJOR ERROR *************************************************** ");
            Console.Write("");
            Console.Write("");
            return;
        }

        Console.WriteLine("Handling placement of mobile objective ({0})" + mo.Name, ArmiesL[mo.OwnerArmy]);

        if (!startup && mo.MobileNextMoveTime_dt.HasValue && mo.MobileNextMoveTime_dt.Value.CompareTo(currTime) <= 0) {
            Console.WriteLine("It's time to move " + mo.ID + " " + mo.Name);
            MO_RemoveObjective(mo);

        }

        Point3d newPos = mo.Pos; //this will be the randomly selected point for the objective IF that has previously been selected

        if (!mo.MobileNextMoveTime_dt.HasValue || (mo.MobileNextMoveTime_dt.HasValue && mo.MobileNextMoveTime_dt.Value.CompareTo(currTime) <= 0)) //if move time is null OR it exists & is in the past, then reset it now AND select the new location now
        {
            Console.WriteLine("Picking a new location for mobile objective ({2}) {0:F0} {1:F0} " + mo.Name, newPos.x, newPos.y, ArmiesL[mo.OwnerArmy]);
            mo.MobileNextMoveTime_dt = currTime.AddHours(mo.MobileMoveTime_hrs);


            //OK, select the new location

            //it is a rectangle defined by sw corner & ne corner
            Point3d swPos = mo.MobileSWPoint;
            Point3d nePos = mo.MobileNEPoint;


            double searchRadius_m = MO_CalcMobileObjRadius_m(mo);

            //try to find a place that is not water, not near an airport, outwards at least mo.radius + adder_m from the center of the objective, within min/max move distance specified
            //try it a bunch of times if no success
            int maxSearchNum = 23250;
            for (int i = 0; i < maxSearchNum; i++)
            {
                
                /*//if having trouble finding a place, expand the search area . . . 
                if (i > 50) {
                    double adder = i * 27;
                    swPos.x -= adder;
                    swPos.y -= adder;
                    nePos.x += adder;
                    nePos.y += adder;
                }
                */

                newPos.x = swPos.x + random.NextDouble() * (nePos.x - swPos.x);
                newPos.y = swPos.y + random.NextDouble() * (nePos.y - swPos.y);

                bool withinMinMax = false;
                double distFromOldPos_m = Calcs.CalculatePointDistance(newPos, mo.Pos);
                //Console.WriteLine("Trying location {0:F0} {1:F0} for " + mo.Name, newPos.x, newPos.y);
                
                //move by a certain min & max amount
                if (distFromOldPos_m <= mo.MobileMaxMoveDist_km * 1000 && distFromOldPos_m >= mo.MobileMinMoveDist_km * 1000) withinMinMax = true;                

                double dist = 5000;
                try
                {
                    AiAirport ap = Calcs.nearestAirport(GamePlay, newPos);
                    dist = Calcs.CalculatePointDistance(ap.Pos(), newPos);
                }
                catch (Exception ex) { Console.WriteLine("ERROR MOBILE OBJECTIVE PLACEMENT! " + ex.ToString()); }

                bool farEnoughFromAirport = true;
                if (dist - searchRadius_m < 3500) farEnoughFromAirport = false;

                ////!!!!!! TODO !!!!!!! Also check that this isn't close to any other existing mobile objective

                bool waterinObjectiveArea = MO_WaterInRadius(newPos, searchRadius_m);

                int terr = GamePlay.gpFrontArmy(newPos.x, newPos.y);
                bool onEnemyTerritory = (mo.AttackingArmy == terr); //We can place these on friend OR neutral territory but not enemy.  Unless there is NO other choice.

                if (!waterinObjectiveArea && farEnoughFromAirport && withinMinMax) Console.WriteLine("MOBILE OBJECTIVE PLACEMENT - {0} terr: {1} attacking: {2} Owner: {3} Pos: {4} {5} OnEnemyTerr: {6}",new object[] { mo.Name, terr, mo.AttackingArmy, mo.OwnerArmy, newPos.x, newPos.y, onEnemyTerritory});

                if (!waterinObjectiveArea && farEnoughFromAirport && !onEnemyTerritory && withinMinMax) break;
                if (!waterinObjectiveArea && farEnoughFromAirport && !onEnemyTerritory && i >= maxSearchNum/3.0) 
                { 
                    Console.WriteLine("MOBILE OBJECTIVE PLACEMENT - PROBLEM!  Couldn't find a location within min/max movement parameters.  Just picking another location meeting ALL other criteria except it is a big jump. {0} min search, {1} searched.", maxSearchNum / 3.0, i);
                    break; //if not working we'll relax the requirement for moving by a certain amount
                }
                if (!waterinObjectiveArea && !onEnemyTerritory && i >= 2.0*maxSearchNum/3.0) // if still not working we'll relax the requirement to avoid airport
                {
                    Console.WriteLine("MOBILE OBJECTIVE PLACEMENT - PROBLEM!  Couldn't find a location within min/max movement parameters && outside of airport radius.  Just picking another location meeting all criteria except Big Jump & Close to Airport. {0} min search, {1} searched.", 2.0 * maxSearchNum / 3.0, i);
                    break; //if not working we'll relax the requirement for moving by a certain amount
                }
                if (!onEnemyTerritory && i >= 5.0*maxSearchNum/6.0) // if still not working we'll relax the requirement to avoid airport
                {
                    Console.WriteLine("MOBILE OBJECTIVE PLACEMENT - PROBLEM!  Couldn't find a location within min/max movement parameters && not on water && outside of airport radius.  Just picking another location outside of Enemy Territory. {0} min search, {1} searched.", 5.0 * maxSearchNum / 6.0, i);
                    break; //if not working we'll relax the requirement for moving by a certain amount
                }
                if (i >= maxSearchNum - 1)
                {
                    Console.WriteLine("MOBILE OBJECTIVE PLACEMENT - BIG PROBLEM!  Couldn't find a location not too near an airport or on water or on enemy territory, and right movement distance. Placing near center of area as last resort.");
                    newPos.x = (swPos.x + nePos.x) / 2.0 + random.NextDouble() * 10000 - 5000;
                    newPos.y = (swPos.y + nePos.y) / 2.0 + random.NextDouble() * 10000 - 5000;
                }
            }
        }

        var things = mo_mobileobjectivethings[mo.MOMobileObjectiveType];

        double masterHeading = random.Next(360);

        newPos.z = twcLandscape.HQ(newPos.x, newPos.y); //saving altitude/elevation of the objective.
        if (mo.AttackingArmy == 1) newPos.z = Calcs.meters2feet(newPos.z); //(in feet for Red army)
        mo.Pos = newPos;
        

        mo.Sector = Calcs.correctedSectorNameDoubleKeypad(this, newPos);
        mo.bigSector = Calcs.makeBigSector(this, newPos);

        int stretchType = 1;
        double stretchPercent = random.NextDouble() * 0.3;

        //Now actually PLACE mobile objective.
        ISectionFile f = GamePlay.gpCreateSectionFile();
        bool resetCount = true;

        foreach (MO_MobileObjectiveThings t in things.Keys)
        {
            MO_ThingsTypeNumberRadius mttnr = new MO_ThingsTypeNumberRadius(things[t]);

            double subHeading = masterHeading + random.Next(40) - 20;

            if (t == MO_MobileObjectiveThings.Sandbags || t == MO_MobileObjectiveThings.Trenches || t == MO_MobileObjectiveThings.Hedgehogs) subHeading = -2; //meaning, align them with the circle rather than the prevailing angle

            if (t == MO_MobileObjectiveThings.Humans) newPos.z = 1;
            else newPos.z = 0;

            //Console.WriteLine("Cirles: " + t.ToString() + " " + subHeading.ToString());

            f = PlaceObjectsInCircles(f, mttnr.things, newPos, mttnr.radius_m, mttnr.range_m, Convert.ToInt32(mttnr.howmany + random.Next(Convert.ToInt32(mttnr.howmany / 4.0)) + mttnr.howmany / 2.0), mo.OwnerArmy, subHeading: subHeading, percentSide: 33, stretcherType: stretchType, stretcherAmt: stretchPercent * mttnr.radius_m, avoidWater: true, resetCount: resetCount);
            //Console.WriteLine("mobile obj: {0} {1} ", mo.ID, resetCount);
            resetCount = false;

        }

        Timeout(random.Next(47, 100), () => { GamePlay.gpPostMissionLoad(f); });


        f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/mobileobj_" + mo.ID); //testing)

        Console.WriteLine("The mobile objective {0} ({3}) is at ({1:F0},{2:F0})", new object[] { mo.Name, mo.Pos.x, mo.Pos.y, ArmiesL[mo.OwnerArmy] });

    }


    int autoFlakTotal = 0;
    public void MO_AutoFlakPlacement(MissionObjective mo) {
        {
            //return; //testing
            List<string> keys = new List<string>(MissionObjectivesList.Keys);

            //Console.WriteLine("Handling autoFlakPlacement for {0} {1} {2} {3}", mo.ID, mo.Pos.x, mo.Pos.y, mo.OwnerArmy);
            Point3d newPos = mo.Pos;

            int nfb = mo.NumFlakBatteries;
            int nib = mo.NumInFlakBattery;

            //TESTING!!!!
            //amount for PRIMARY objectives
            nfb = 2;
            nib = 2;

            if (mo.MOObjectiveType.Equals(MO_ObjectiveType.Ship)) return; 

            //too much flak seems to bring the server to it's knees, so if not a primary just 2x2 flak, otherwise what is requested
            if (!mo.IsEnabled || !mo.IsPrimaryTarget)
            {
                
                if (mo.MOObjectiveType == MO_ObjectiveType.Radar) //radar needs more flak to protect it, so just half the req amount if not primary.
                {
                    /*nfb = nfb / 3;
                    nib = nib;
                    if (nfb < 2) nfb = 2;
                    if (nib < 2) nib = 2;
                    */
                    //Console.WriteLine("RADAR autoFlakPlacement  {0} {1} ", nfb, nib);
                    nfb = 2;
                    nib = 2;

                }
                else //for everything else, just a little bit. 
                {
                    nfb = 1;
                    nib = 2;
                }
            }

            //A little more for the currently active Bumrush objective:
            if (mo == MO_BRCurrentBumrushMissionObjective())
            {
                //Based on experiment, 2 AI flak for airport defenders seems about right.  But 4 is too many
                //If they want to jump into flak (placed in the bumrush.mis file) that is one thing.  But too many AI flak makes
                //defense of the base almost 100% certain.
                nfb = 1;
                nib = 3;
            }


            ISectionFile f = GamePlay.gpCreateSectionFile();
            double batteryRadius = mo.radius;
            if (mo.MOObjectiveType == MO_ObjectiveType.Radar && mo.OwnerArmy == 2) batteryRadius += 250;  //For Blue radars, the exact location of flak can help locate the radar position, which we don't want. So we spread the batteries out a fair bit more.

            if (nfb * nib < 2 && batteryRadius >  75) batteryRadius = 75; //experimental, if just a couple of flak try placing it right amid the actual target

            bool resetCount = true;
            int flakNum = 0;

            for (int j = 0; j < nfb; j++) {

                //try to find a place that is not water,  outwards at least mo.radius + adder_m from the center of the objective
                for (int i = 0; i < 2000; i++)
                {
                    double angle = random.NextDouble() * 2.0 * Math.PI;
                    double radius = random.Next(10) + batteryRadius + i * 5.0;  //try ever-greater distances if it's not working well

                    newPos.x = mo.Pos.x + Math.Cos(angle) * radius;
                    newPos.y = mo.Pos.y + Math.Sin(angle) * radius;

                    maddox.game.LandTypes landType = GamePlay.gpLandType(newPos.x, newPos.y);

                    double dist = 1000;
                    double apRadius = 1000;
                    try
                    {
                        AiAirport ap = Calcs.nearestAirport(GamePlay, newPos);
                        dist = Calcs.CalculatePointDistance(ap.Pos(), newPos);
                        apRadius = ap.FieldR();
                    }
                    catch (Exception ex) { Console.WriteLine("ERROR FLAKPLACE! " + ex.ToString()); }

                    if (landType != maddox.game.LandTypes.WATER && dist > 999 && dist > apRadius) break;
                }

                string owner = "nn";
                if (mo.OwnerArmy == 1) owner = "gb";
                else if (mo.OwnerArmy == 2) owner = "de";
                else Console.WriteLine("Autoflak Placement ARMY ERROR for {0} objective - Owner Army was not 1 or 2", new object[] { mo.Name });

                //TOBRUK!!!
                //In case this is the DISPUTED airport, then the defending army gets to place flak there, but NOT the ATTACKING army.
                if (mo == MO_BRCurrentBumrushMissionObjective())
                {
                    int cdf = MO_BRCurrentDefendingArmy();
                    if (cdf == 1) owner = "gb";
                    else if (cdf == 2) owner = "de";

                }

                //Bofors_StandAlone is very good.
                //37mm_PaK_35_36 doesn't seem to work at all?
                //.3_7_inch_QF_Mk_I might work OK, hit me.  Doesn't fire very often.
                //Artillery.Flak30_Shield is very good, maybe better than Bofors.  Fires often and accurately.

                //var flak = new List<string> { "Artillery.37mm_PaK_35_36", /*"Artillery.Flak37",*/ "Artillery.Bofors_StandAlone", "Artillery.3_7_inch_QF_Mk_I", "Artillery.Flak30_Shield", };
                var flak = new List<string> { "Artillery.Flak30_Shield", "Artillery.Bofors_StandAlone", };

                //OK, the artillery chief is one of my prime suspects for the warping/rubberbanding.  Trying to disable them all to see if that helps.  2020/03/07
                //Next thing to try would be disabling all this autoflak.  It does seem to slow down/tie up the server noticeably.
                //Trying chiefs onliy for primary targets

                //if (mo.IsPrimaryTarget) //experimentally making Chiefs only for primary target artillery.

                f = Calcs.makeAIChief(f, GamePlay, this, newPos.x, newPos.y, newPos.z, 10 + nfb * 2 + 50, chiefNum: j, resetCount: resetCount);
                resetCount = false;

                //Now actually PLACE the flak.

                double hdg = random.Next(360);
                Calcs.Shuffle(flak);
                for (int i = 0; i < nib; i++)
                {
                    double angle1 = i * 2.0 / mo.NumInFlakBattery * Math.PI + random.NextDouble() / mo.NumInFlakBattery;
                    double radius2 = random.Next(2) + 10 + nfb * 2;

                    double nex = newPos.x + Math.Cos(angle1) * radius2;
                    double ney = newPos.y + Math.Sin(angle1) * radius2;

                    string side = owner;

                    //Timeout(30 + 2 * i, () =>
                    //{
                    f = Calcs.makeStatic(f, GamePlay, this, nex, ney, newPos.z, type: flak[flakNum], heading: hdg + random.Next(15), side: side, radiusHide: 6000, chiefNum: j, resetCount: resetCount);
                    resetCount = false;
                    flakNum++; //so we're just going to alternate between the two types of effective flak and that way if you have at least 2 flaks at each location you'll have one of each type.
                    if (flakNum >= flak.Count) flakNum = 0; 
                    //});
                }

            }
            autoFlakTotal += nib * nfb;
            Console.WriteLine("{2} flak guns placed for {3} at {0} {1} - Total: {4})", mo.Pos.x, mo.Pos.y, nib * nfb, mo.Name, autoFlakTotal);
            f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/airfieldArtilleryChieffile"+random.Next(0,20).ToString("F0") + ".txt"); //testing

            //wait to load, saves a lot of scrolling @ mission start.
            Timeout(45, () => { GamePlay.gpPostMissionLoad(f); });
        }
    }

    public void MO_TestObjectiveWithFlak(MissionObjective mo, int NumFlakBatteries, int NumInFlakBattery)
    {
        {
            List<string> keys = new List<string>(MissionObjectivesList.Keys);



            Console.WriteLine("Handling TESTFLAK for {0} {1} {2} {3} {4}", mo.ID, mo.Pos.x, mo.Pos.y, NumFlakBatteries, NumInFlakBattery);
            Point3d newPos = mo.Pos;

            for (int j = 0; j < NumFlakBatteries; j++)
            {

                double rd = mo.radius;

                if (rd < 250) rd = 20;
                if (rd < 5000) rd = 5000;

                Point3d pos = mo.returnCurrentPosWithChief(); //use the "chief position calculator" where necessary

                newPos.x = pos.x + random.Next(Convert.ToInt32(mo.radius));
                newPos.y = pos.y + random.Next(Convert.ToInt32(mo.radius));


                //This is place ENEMY flake in the middle of a FRIENDLY objective, so that the enemyflak will destroy the objective
                string enemy = "de";
                if (mo.AttackingArmy == 1) enemy = "gb";

                //var flak = new List<string> { "Artillery.37mm_PaK_35_36", /*"Artillery.Flak37",*/ "Artillery.Bofors_StandAlone", "Artillery.3_7_inch_QF_Mk_I", "Artillery.Flak30_Shield", };
                var flak = new List<string> { "Artillery.Bofors_StandAlone", "Artillery.Bofors", }; //These are the big guns, literally

                //Now actually PLACE the flak.
                ISectionFile f = GamePlay.gpCreateSectionFile();



                double hdg = random.Next(360);
                Calcs.Shuffle(flak);
                for (int i = 0; i < NumInFlakBattery; i++)
                {
                    double angle1 = i * 2.0 / NumInFlakBattery * Math.PI + random.NextDouble() / NumInFlakBattery;
                    double radius2 = random.Next(2) + 10 + NumInFlakBattery * 2;

                    double nex = newPos.x + Math.Cos(angle1) * radius2;
                    double ney = newPos.y + Math.Sin(angle1) * radius2;

                    //Console.WriteLine("The artillery is at {0} {1})", new object[] { nex, ney });

                    string side = enemy;

                    //Timeout(30 + 2 * i, () =>
                    //{
                    f = Calcs.makeStatic(f, GamePlay, this, nex, ney, newPos.z, type: flak[0], heading: hdg + random.Next(15), side: side);
                    //});
                }


                GamePlay.gpPostMissionLoad(f);


                Console.WriteLine("The TESTFLAK is at {0} {1})", new object[] { newPos.x, newPos.y });



            }
        }
    }

    static ManualResetEvent resetEvent = new ManualResetEvent(false);

    public bool MO_WriteMissionObject(object mo, string name, bool wait = false)
    {
        Console.WriteLine("Writing " + name + " to file");

        string ext = ".xml";
        string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_SESSIONSTATE_" + name + ext;
        string suffix = "_SESSIONSTATE_" + name;
        string fileName_base = CAMPAIGN_ID;
        string backupDir = CAMPAIGN_ID + @" campaign backups\"; //will be added at the end of STATSCS_FULL_PATH

        //WriteAllTextAsyncWithBackups(string fileDir_base, string fileName_base, string suffix, string ext, string backupDir, bool wait = false, ManualResetEvent resetEvent = null)

        try
        {
            /* 
             * //System.Xml.Serialization.XmlSerializer writer = new System.Xml.Serialization.XmlSerializer(mo.GetType());
            BinaryFormatter writer = new BinaryFormatter();
            using (FileStream fs = File.Create(filepath))
            {
                writer.Serialize(fs, mo);
            }
            */

            //List<Type> knownTypes = new List<Type> { typeof(List<string>), typeof(Tuple<int, int, Player>) };
            //var serializer = new DataContractSerializer(mo.GetType(), knownTypes);
            var serializer = new DataContractSerializer(mo.GetType());
            string xmlString;
            using (var sw = new StringWriter())
            {
                using (var writer = new XmlTextWriter(sw))
                {
                    writer.Formatting = Formatting.Indented; // indent the Xml so it's human readable
                    serializer.WriteObject(writer, mo);
                    writer.Flush();
                    xmlString = sw.ToString();
                }
            }
            //File.WriteAllText(filepath, xmlString);

            int count = 0;

            //if wait is set we block the thread & wait until it's complete
            //we only do this at final program exit, just to make sure file write actually complete/not corrupted
            if (wait)
            {

                /*Task<bool> task = Calcs.WriteAllTextAsync(filepath, xmlString);
                bool res = await task; */
                //Calcs.WriteAllTextAsync(filepath_new, xmlString, wait: true, resetEvent: resetEvent);
                Calcs.WriteAllTextAsyncWithBackups(xmlString, STATSCS_FULL_PATH, fileName_base, suffix, ext, backupDir, wait: true, resetEvent: resetEvent);
                Console.WriteLine("MO_WriteMissionObject: waiting . . . to write " + name);
                resetEvent.WaitOne(); // Blocks the thread until until "set"
                Console.WriteLine("MO_WriteMissionObject: . . . . released.");

            } else Calcs.WriteAllTextAsyncWithBackups(xmlString, STATSCS_FULL_PATH, fileName_base, suffix, ext, backupDir);

        }
        catch (Exception ex)
        {
            Console.WriteLine("WriteMissionObjectivesClass ERROR: " + ex.ToString());
            return false;
        }
        return true;

    }

    public object MO_ReadMissionObject(object mo, string name)
    {
        Console.WriteLine("Reading " + name + " from file");

        string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_SESSIONSTATE_" + name + ".xml";

        try
        {
            /* 
             * //System.Xml.Serialization.XmlSerializer writer = new System.Xml.Serialization.XmlSerializer(mo.GetType());
            BinaryFormatter writer = new BinaryFormatter();
            using (FileStream fs = File.Create(filepath))
            {
                writer.Serialize(fs, mo);
            }
            */
            string xmlString = File.ReadAllText(filepath);

            //XmlDictionaryReader reader =
            //    XmlDictionaryReader.CreateTextReader(fs, new XmlDictionaryReaderQuotas());

            var serializer = new DataContractSerializer(mo.GetType());

            using (XmlReader reader = XmlReader.Create(new StringReader(xmlString))) {
                DataContractSerializer formatter0 =
                    new DataContractSerializer(mo.GetType());
                mo = formatter0.ReadObject(reader);
            }

        }


        /*

        string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_" + name + ".json";        

        //System.Xml.Serialization.XmlSerializer reader = new System.Xml.Serialization.XmlSerializer(mo.GetType());
        BinaryFormatter writer = new BinaryFormatter();

        try
        {
            using (FileStream fs = File.OpenRead(filepath))
            {
                //jsonString = File.ReadAllText(filepath);
                mo =  writer.Deserialize(fs);
            }
        }
        */

        catch (Exception ex)
        {
            Console.WriteLine("ReadMissionObjectivesClass ERROR: " + ex.ToString());
            return null;
        }
        return mo;



    }

    //wait = true makes it wait for the async disk write & verify that it worked/no errors
    //usually we only do this right before final thread exit
    public void MO_WriteMissionObjects(bool wait = false)
    {
        MO_WriteMissionObject(MissionObjectivesList, "MissionObjectivesList", wait);
        MO_WriteMissionObject(MissionObjectivesTimes, "MissionObjectivesInfo", wait);
        MO_WriteMissionObject(ScoutPhotoRecord, "ScoutPhotoRecord", wait);
        MO_WriteMissionObject(DestroyedRadar, "DestroyedRadar", wait);
        MO_WriteMissionObject(MissionObjectivesSuggested, "MissionObjectivesSuggested", wait);
        MO_WriteMissionObject(MissionObjectiveScore, "MissionObjectiveScore", wait);
        MO_WriteMissionObject(MissionObjectivesCompletedString, "MissionObjectivesCompletedString", wait);
        MO_WriteMissionObject(MO_BRBumrushInfo, "MO_BRBumrushInfo", wait);
        MO_WriteMissionObject(GamePlay.gpTimeofDay(), "MissionCurrentTime", wait);

        //MO_WriteMissionObject(MissionObjectivesString, "MissionObjectivesString", wait);

    }


    public bool[] MO_ReadMissionObjects()
    {
        bool[] ret = new bool[] { true, true, true, true, true, true, true };
        var mo = MO_ReadMissionObject(MissionObjectivesList, "MissionObjectivesList");
        Console.WriteLine("Read " + mo.GetType().ToString());
        if (mo != null) MissionObjectivesList = mo as Dictionary<string, MissionObjective>;
        else ret[0] = false;

        Dictionary<string, MissionObjective> mo_dic = mo as Dictionary<string, MissionObjective>;//have to switch it from type object to Dictionary
        /*
        if (mo != null) foreach ( string key in (mo_dic as Dictionary<string, MissionObjective>).Keys)
            {
                //Console.WriteLine("RMO: Restoring " + key + " " + MissionObjectivesList[key].Scouted.ToString() + mo_dic[key].Scouted.ToString());
                if (!MissionObjectivesList.ContainsKey(key)) continue;
                MissionObjectivesList[key].Scouted = mo_dic[key].Scouted;
                MissionObjectivesList[key].PlayersWhoScoutedNames = mo_dic[key].PlayersWhoScoutedNames;
            }
            */

    var mo1 = MO_ReadMissionObject(MissionObjectivesSuggested, "MissionObjectivesSuggested");
        if (mo1 != null) Console.WriteLine("Read " + mo1.GetType().ToString());
        if (mo1 != null) MissionObjectivesSuggested = mo1 as Dictionary<ArmiesE, List<String>>;
        else ret[1] = false;

        /*
         * 
         * Dictionary<ArmiesE, Dictionary<string,object>> MissionObjectivesInfo = new Dictionary<ArmiesE, Dictionary<string, object>>() {
            {ArmiesE.Red, Dictionary<string,object>() },
            {ArmiesE.Blue, Dictionary<string,object>() }
        };
        */

        var mo2 = MO_ReadMissionObject(MissionObjectivesTimes, "MissionObjectivesInfo");
        if (mo2 != null) Console.WriteLine("Read " + mo2.GetType().ToString());
        if (mo2 != null)
        {
            MissionObjectivesTimes = mo2 as Dictionary<ArmiesE, Dictionary<string, DateTime>>;
        }
        else ret[2] = false;

        /*
         * //We don't need this as it is reconstructed from the MissionObjectivesList .Destroyed flag for objectives
        var mo2 = MO_ReadMissionObject(DestroyedRadar, "DestroyedRadar");
        Console.WriteLine("Read " + mo1.GetType().ToString());
        if (mo2 != null) DestroyedRadar = mo2 as Dictionary<ArmiesE, List<MissionObjective>>;
        else ret[2] = false;
        */

        var mo3 = MO_ReadMissionObject(MissionObjectiveScore, "MissionObjectiveScore");
        if (mo3 != null) Console.WriteLine("Read " + mo3.GetType().ToString());
        if (mo3 != null) MissionObjectiveScore = mo3 as Dictionary<ArmiesE, double>;
        else ret[3] = false;

        var mo4 = MO_ReadMissionObject(MissionObjectivesCompletedString, "MissionObjectivesCompletedString");
        if (mo4 != null) Console.WriteLine("Read " + mo4.GetType().ToString());
        if (mo4 != null) MissionObjectivesCompletedString = mo4 as Dictionary<ArmiesE, string>;
        else ret[4] = false;

        /*
        var mo5 = MO_ReadMissionObject(MissionObjectivesString, "MissionObjectivesString");
        Console.WriteLine("Read " + mo5.GetType().ToString());
        if (mo5 != null) MissionObjectivesString = mo5 as Dictionary<ArmiesE, string>;
        else ret[5] = false;
        */

        //MO_BRBumrushInfo = new Dictionary<ArmiesE, MO_BRBumrushInfoType>()
        var mo5 = MO_ReadMissionObject(MO_BRBumrushInfo, "MO_BRBumrushInfo");
        if (mo5 != null) Console.WriteLine("Read " + mo5.GetType().ToString());
        if (mo5 != null) MO_BRBumrushInfoRestored = mo5 as Dictionary<ArmiesE, MO_BRBumrushInfoType>;
        else ret[5] = false;

        var mo6 = MO_ReadMissionObject(ScoutPhotoRecord, "ScoutPhotoRecord");
        if (mo6 != null) Console.WriteLine("Read " + mo6.GetType().ToString());
        if (mo6 != null)
        {
            ScoutPhotoRecord = mo6 as Dictionary<Tuple<int, int, aPlayer>, List<string>>;
            try
            {
                /*foreach (KeyValuePair<Tuple<int, int, aPlayer>, List<string>> entry in ScoutPhotoRecord)
                {
                    Console.WriteLine(entry.Key);
                    Console.WriteLine(entry.Value);
                    Console.WriteLine(entry.Key.Item1.ToString());
                    Console.WriteLine(entry.Key.Item2.ToString());
                    Console.WriteLine(entry.Key.Item3.ToString());
                    Console.WriteLine(entry.Key.Item3.name);
                    Console.WriteLine(entry.Key.Item3.army.ToString());
                }
                */
            } catch (Exception ex) { Console.WriteLine("ScoutPhotoRecord read from disk ERROR: " + ex.ToString()); }
        }
        //if (mo6 != null) ScoutPhotoRecord = mo6 as ScoutPhotoRecord_class;
        else ret[6] = false;

        return ret;
        /*
        MO_WriteMissionObject(DestroyedRadar, "DestroyedRadar");
        MO_WriteMissionObject(MissionObjectivesSuggested, "MissionObjectivesSuggested");
        MO_WriteMissionObject(MissionObjectiveScore, "MissionObjectiveScore");
        MO_WriteMissionObject(MissionObjectivesCompletedString, "MissionObjectivesCompletedString");
        MO_WriteMissionObject(MissionObjectivesString, "MissionObjectivesString");
        */

    }


    //This reads the primary objectives selected from the previous mission
    //Just reads the previous objectives, but takes into consideration that objectives might have been removed, names changed
    //required point total increased or decreased, etc etc since the file was written
    public void MO_ReadPrimaryObjectives(int army = 0)
    {
        //MO_SelectPrimaryObjectives(army);
        if (army < 1 || army > 2) return;

        Console.WriteLine("Reading Mission Objectives from file for " + ArmiesL[army]);

        List<string> moKeys = new List<string>(MissionObjectivesList.Keys);

        //first, remove any/all existing primary targets marked in the MissionObjectivesList
        //reason is, we want the .ini file primary objective list to be the operative list. 
        //What it says, goes.  So you can for example change or delete objectives just by editing the .ini file.  Then MissionObjectivesList will be updated (here) to match that.
        foreach (var key in moKeys)
        {
            if (MissionObjectivesList[key].AttackingArmy == army) MissionObjectivesList[key].IsPrimaryTarget = false;
        }

        string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapObjectives.ini";

        //Ini.IniFile ini = new Ini.IniFile(filepath, this);
        Ini.IniFile ini = new Ini.IniFile(filepath);

        List<string> keys = ini.IniReadList(ArmiesL[army] + "_Objectives", "Objective");
        //Console.WriteLine("READ: " + keys.ToString());

        double totalPoints = 0;
        foreach (var key in keys)
        {
            //Console.WriteLine("MOReading " + key);
            //The objective that previous existed may not be in the list on this run, so we have to be careful when reading it, not just assume it exists
            var mo = new MissionObjective(this);
            if (!MissionObjectivesList.TryGetValue(key, out mo)) continue;

            if (mo.AttackingArmy == army && mo.PrimaryTargetWeight > 0 && mo.IsEnabled && !mo.IsPrimaryTarget)
            {
                if (totalPoints < MO_BRBumrushInfo[(ArmiesE)army].PointsRequiredToBeginBumrush)
                {
                    mo.IsPrimaryTarget = true;
                    totalPoints += mo.Points;
                    //MissionObjectivesString[(ArmiesE)army] += " - " + mo.Sector + " " + mo.Name;
                    //Console.WriteLine("MOReading add:" + key);
                }
                else
                {
                    mo.IsPrimaryTarget = false;
                    //Console.WriteLine("MOReading skip:" + key);
                }

            }

        }

        //In case the total points are not enough, we can go select more additional objectives
        //Console.WriteLine(totalPoints.ToString () + " < points > " + MO_PointsRequired[(ArmiesE)army].ToString());
        if (totalPoints < MO_BRBumrushInfo[(ArmiesE)army].PointsRequiredToBeginBumrush)
        {
            MO_SelectPrimaryObjectives(army, totalPoints, fresh: false);
            //MO_WritePrimaryObjectives(); DON'T do this here as it erases both army's info at and this point we're only doing one army, so writing now will DELETE the other army
        }
        return;


    }

    public void MO_WritePrimaryObjectives()
    {


        Console.WriteLine("MO_Write #2");

        string filepath = STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapObjectives.ini";
        string filepath_old = STATSCS_FULL_PATH + CAMPAIGN_ID + "_MapObjectives_old.ini";
        string currentContent = String.Empty;

        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX5 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        //Save most recent copy of Campaign Map Score with suffix _old
        try
        {
            if (File.Exists(filepath_old)) { File.Delete(filepath_old); }
            File.Copy(filepath, filepath_old); //We could use File.Move here if we want to eliminate the previous .ini file before writing new data to it, thus creating an entirely new .ini.  But perhaps better to just delete specific sections as we do below.
            Console.WriteLine("MO_Write #2a");
        }
        catch (Exception ex) { Console.WriteLine("MO_Write Inner: " + ex.ToString()); }


        Console.WriteLine("MO_Write Save #3");

        try
        {

            //Ini.IniFile ini = new Ini.IniFile(filepath, this);
            Ini.IniFile ini = new Ini.IniFile(filepath);

            //.ini keeps the same file & just adds or updates entries already there. Unless you delete them.
            //Delete all entries in these sections first
            ini.IniDeleteSection("Red_Objectives");
            ini.IniDeleteSection("Blue_Objectives");

            //Console.WriteLine(MO_ListAllPrimaryObjectives((int)ArmiesE.Red).ToString());
            //Console.WriteLine(MO_ListAllPrimaryObjectives((int)ArmiesE.Blue).ToString());

            //Write the new data in the two sections
            ini.IniWriteList("Red_Objectives", "Objective", MO_ListAllPrimaryObjectives((int)ArmiesE.Red));
            ini.IniWriteList("Blue_Objectives", "Objective", MO_ListAllPrimaryObjectives((int)ArmiesE.Blue));

            //Save campaign objective list to special directory as a bit of a backup/record of objectives over time
            Console.WriteLine("MO_Write #3a");
        }
        catch (Exception ex) { Console.WriteLine("MapState Write: " + ex.ToString()); }

        MO_makeCampaignFilesBackup(filepath, @" campaign backups\", @"_MapObjectives-", ".ini");

        Console.WriteLine("MO_Write #4");

        /*
        var backPath = STATSCS_FULL_PATH + CAMPAIGN_ID + @" campaign backups\";
        string filepath_date = backPath + CAMPAIGN_ID + @"_MapObjectives-" + dt.ToString("yyyy-MM-dd-tt") + ".ini";

        //Create the directory for the MapState.txt backup files, if it doesn't exist
        if (!System.IO.File.Exists(backPath))
        {

            try
            {
                //System.IO.File.Create(backPath);
                System.IO.Directory.CreateDirectory(backPath);
            }
            catch (Exception ex) { Console.WriteLine("MO_Write Dir Create Date: " + ex.ToString()); }

        }

        //Save most recent copy of Campaign Objectives List with suffix like  -2018-05-13.ini
        try
        {
            if (File.Exists(filepath_date)) { File.Delete(filepath_date); }
            File.Copy(filepath, filepath_date);
        }
        catch (Exception ex) { Console.WriteLine("MO_Write Date: " + ex.ToString()); }
        */



    }

    public void MO_makeCampaignFilesBackup(string fullFilename, string dirName, string fileSuffix, string extension)
    {

        DateTime dt = DateTime.UtcNow;
        string date = dt.ToString("u");

        var backPath = STATSCS_FULL_PATH + CAMPAIGN_ID + dirName;
        string filepath_date = backPath + CAMPAIGN_ID + fileSuffix + dt.ToString("yyyy-MM-dd-tt") + extension;

        //Create the directory for the MapState.txt backup files, if it doesn't exist
        if (!System.IO.File.Exists(backPath))
        {

            try
            {
                //System.IO.File.Create(backPath);
                System.IO.Directory.CreateDirectory(backPath);
            }
            catch (Exception ex) { Console.WriteLine("MO_Write Dir Create Date: " + ex.ToString()); }

        }

        //Save most recent copy of corresponding file with suffix like  -2018-05-13.ini
        try
        {
            if (File.Exists(filepath_date)) { File.Delete(filepath_date); }
            File.Copy(fullFilename, filepath_date);
        }
        catch (Exception ex) { Console.WriteLine("MO_Write Date: " + ex.ToString()); }


    }

    //Lists the current secondary/suggested targets to theplayer's screen, and/or just returns the keys of the objectives as a List<string>
    public List<string> MO_ListSuggestedObjectives(Player player, int army, int numToDisplay = 5, double delay = 0.2, bool display = true)
    {

        int numDisplayed = 0;
        double totDelay = 0;
        List<string> currentSecondaryObjectives = new List<string>() { };

        try
        {

            if (player != null && display) twcLogServer(new Player[] { player }, "SUGGESTED " + ArmiesL[army].ToUpper() + " SECONDARY OBJECTIVES:", new object[] { });

            string msg1 = ">>> NOTE: If recon areas are listed, those sectors need to be scouted.";


            if (player != null && display) twcLogServer(new Player[] { player }, msg1, new object[] { });

            msg1 = ">>> Scout those sectors and take recon photos - Tab-4-9. HQ will then identify specific targets.";

            if (player != null && display) twcLogServer(new Player[] { player }, msg1, new object[] { });

            foreach (var key in MissionObjectivesSuggested[(ArmiesE)army])
            {

                if (numDisplayed >= numToDisplay) break;
                MissionObjective mo = null;
                if (MissionObjectivesList.ContainsKey(key)) mo = MissionObjectivesList[key];
                else continue;

                if (!mo.Destroyed && !mo.ObjectiveAchievedForPoints && mo.IsEnabled)
                {
                    currentSecondaryObjectives.Add(key);

                    if (display && player != null)
                    {
                        totDelay += delay;
                        Timeout(totDelay, () =>
                        {
                            //print out the radar contacts in reverse sort order, which puts closest distance/intercept @ end of the list               

                            // + " (" + mo.Pos.x + "," + mo.Pos.y + ")"



                            string msg = "Recon sector: " + mo.Sector.Substring(0, 4).TrimEnd('.');
                            if (mo.Scouted) msg = mo.lastScoutedSector + " " + mo.Name + " (" + mo.Pos.x.ToString("F0") + ", " + mo.Pos.y.ToString("F0") + ")";
                            twcLogServer(new Player[] { player }, msg, new object[] { });

                        });//timeout    
                    }
                    numDisplayed++;
                }
            }
        }
        catch (Exception ex) { Console.WriteLine("ListSuggestedObjectives ERROR!: " + ex.ToString()); }


        return currentSecondaryObjectives;

    }

    public string MO_ListScoutedObjectives(Player player = null, int army = 1, int numToDisplay = -1, double delay = 0.2) //num to display less than 1 means display all
    {

        int numDisplayed = 0;
        double totDelay = 0;

        string retmsg = "";
        string msg = "Scouted " + ArmiesL[army] + " Targets with Coordinates:";

        if (player != null) twcLogServer(new Player[] { player }, msg, new object[] { });
        retmsg += msg + Environment.NewLine;

        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        //foreach (var key in MissionObjectives[(ArmiesE)army])
        {
            //mo.AttackingArmy == army
            if (numToDisplay > 0 && numDisplayed >= numToDisplay) break;
            MissionObjective mo = entry.Value;


            if (mo.AttackingArmy == army && mo.Scouted)
            {
                totDelay += delay;
                //print out the radar contacts in reverse sort order, which puts closest distance/intercept @ end of the list               

                // + " (" + mo.Pos.x + "," + mo.Pos.y + ")"
                string msg6 = mo.lastScoutedSector + " " + mo.Name;
                if (!Calcs.Point3dEqual(mo.lastScoutedPos, new Point3d(-1, -1, -1))) //set to (-1,-1,-1) means the objective was previously scouted by not is disabled/removed
                    msg6 += " (" + mo.lastScoutedPos.x.ToString("F0") + ", " + mo.lastScoutedPos.y.ToString("F0") + ", " + mo.lastScoutedPos.z.ToString("F0") + ")";
                if (!mo.IsEnabled) msg6 += "!!No longer there!!";
                //if (mo.Destroyed) msg6 += " (destroyed)";
                //else if (mo.IsPrimaryTarget) msg6 += " (primary objective)";
                if (mo.lastTimeScouted_dt.HasValue) {
                    TimeSpan diff = DateTime.UtcNow - mo.lastTimeScouted_dt.Value;
                    msg6 += " ";
                    if (mo.numTimesScouted > 1) msg6 += mo.numTimesScouted.ToString("F0") + "X, ";
                    //This is cool but soooo long
                    //msg6 += (mo.lastTimeScouted_hist_dt.Value).ToString("d'.'MM'.'yy' 'HH':'mm)");
                    msg6 += (Math.Round(diff.TotalHours * 2.0) / 2.0).ToString("F1") + "hr";
                }

                string dl = " L" + mo.Points.ToString();

                string pc = "";
                if (mo.DestroyedPercent > 0) pc = ", " + (mo.DestroyedPercent * 100.0).ToString("F0") + "%";

                msg6 += dl + pc;

                retmsg += msg6 + Environment.NewLine;
                numDisplayed++;
                Timeout(totDelay, () =>
                {
                    if (player != null) twcLogServer(new Player[] { player }, msg6, new object[] { });
                });//timeout
                if (mo.hasGeneralStaff)
                {

                    var gsl = GeneralStaffLocations[(ArmiesE)army];
                    string af = "general";
                    if (mo.OwnerArmy == 1) af = "RAF";
                    else if (mo.OwnerArmy == 2) af = "Luftwaffe";
                    int timeLeft_min = calcTimeLeft_min();
                    string msg7 = ">>>Recon has identified a possible group of high-ranking " + af + " officers in sector " + gsl.sector + " near " + mo.Name;
                    if (timeLeft_min < MISSION_LENGTH_HRS * 60.0 / 2 || mo.numTimesScouted > 1) msg7 = ">>>Additional reconnaissance has determined that " + gsl.staffGroupName + " are in sector " + gsl.sectorKeypad + " near " + mo.Name;
                    if (timeLeft_min < MISSION_LENGTH_HRS * 60.0 / 4 || mo.numTimesScouted > 2) msg7 = ">>>Additional reconnaissance has determined that " + gsl.staffGroupName + " are in sector " + gsl.sectorDoublekeypad + " near " + mo.Name;
                    if (mo.numTimesScouted > 3) msg7 = ">>>Additional reconnaissance has determined that " + gsl.staffGroupName + " are in sector " + gsl.sectorDoublekeypad + " near (" + (gsl.pos.x + random.Next(1000) - 500).ToString("F0") + "," + (gsl.pos.y + random.Next(1000) - 500).ToString("F0") + ") in the area of " + mo.Name;
                    if (mo.numTimesScouted > 4) msg7 = ">>>Several additional reconnaissance flights have narrowed down the location of " + gsl.staffGroupName + " within less than 1 km, in sector " + gsl.sectorDoublekeypad + " near (" + (gsl.pos.x + random.Next(1000) - 500).ToString("F0") + "," + (gsl.pos.y + random.Next(1000) - 500).ToString("F0") + ") in the area of " + mo.Name;
                    if (mo.numTimesScouted > 5) msg7 = ">>>Several additional reconnaissance flights have narrowed down the location of " + gsl.staffGroupName + " to sector " + gsl.sectorDoublekeypad + " within a few hundred meters of (" + (gsl.pos.x + random.Next(1000) - 200).ToString("F0") + "," + (gsl.pos.y + random.Next(1000) - 200).ToString("F0") + ") in the area of " + mo.Name;
                    //if (timeLeft_min < MISSION_LENGTH_HRS * 60.0 / 8) msg7 = ">>>" + gsl.staffGroupName + " may have been spotted in sector " + gsl.sectorDoublekeypad + " near " + mo.Name;
                    retmsg += msg7 + Environment.NewLine;
                    totDelay += delay;
                    Timeout(totDelay, () =>
                    {
                        if (player != null) twcLogServer(new Player[] { player }, msg7, new object[] { });
                    });//timeout

                }


            }
        }
        if (numDisplayed == 0)
        {
            msg = ">>>>> No objectives scouted yet <<<<<";
            if (player != null) twcLogServer(new Player[] { player }, msg, new object[] { });
            retmsg += msg + Environment.NewLine;
        }
        Timeout(totDelay + 2, () =>
        {
            if (player != null) twcLogServer(new Player[] { player }, ">>> To scout objectives, fly 10000ft/3000m or higher in an aircraft with no bombs on board and record a reconnaissance photo of the area via Tab-4-9.", new object[] { });
            Timeout(2, () =>
            {
                if (player != null) twcLogServer(new Player[] { player }, ">>> Return the photos to base, land safely, and use chat command <record to transfer the photos to headquarters.", new object[] { });
            });
            Timeout(4, () =>
            {
                if (player != null) twcLogServer(new Player[] { player }, ">>> The photos allow headquarters to determine precise coordinates of all potential objectives in that area.", new object[] { });
            });
            //twcLogServer(new Player[] { player }, ">>>>> The higher you fly the larger the area your photo will capture.", new object[] { });

        });

        return retmsg;
    }

    /*
    [CollectionDataContract
    (Name = "ScoutPhotoRecord",
    ItemName = "entry",
    KeyName = "Playertuple",
    ValueName = "ScoutedObjectiveList")]
    public class ScoutPhotoRecord_class : Dictionary<Tuple<int, int, aPlayer>, List<string>> { };
    */

    //List interesting targets for player, if within radius of distance_m.  The inclusion of distance_m is to avoid displaying updates for, say, mobile/moving target position
    //When the player is too far away to actually observe the MO's new position.
    public void displayInterestingScoutTargets(Player player, double distance_m=20000)
    {
        Console.WriteLine("Listing interesting scout targets for " + player.Name() + " at {0:N0}m", distance_m);
        if (!ScoutInterestingTargets.ContainsKey(player)) return;

        string sectorList = "";
        if (player == null || player.Place() == null) return;

        foreach (string s in ScoutInterestingTargets[player])
        {
                string moving = "";
                Console.WriteLine("Listing all interesting scout targets " + s);
                if (!MissionObjectivesList.ContainsKey(s)) continue;
            MissionObjective mo = MissionObjectivesList[s];
            if (Calcs.CalculatePointDistance(mo.returnCurrentPosWithChief(), player.Place().Pos()) > distance_m) continue;
                if (MissionObjectivesList[s].hasChief()) moving = "(moving)";
                string sect = Calcs.correctedSectorNameDoubleKeypad(this,(MissionObjectivesList[s].returnCurrentPosWithChief()));            
                sectorList += sect + moving + " ";
        }

        if (sectorList.Length == 0) return;
            gpLogServerAndLog(new Player[] { player }, ">>> Interesting sectors from your recon flight for a closer look or high-res screenshot photos: " + sectorList, null);
        }

    public void displayNewInterestingScoutTarget(Player player, string moID, double distance_m = 20000) {
        Timeout(10, () =>
        {
            gpLogServerAndLog(new Player[] { player }, ">>> Preliminary analysis indicates a high-res screenshot photo of sector " + MissionObjectivesList[moID].lastScoutedSector + " may help locate important targets in that area.", null);
        });
        Timeout(20, () =>
        {
            displayInterestingScoutTargets(player, distance_m);
        });
    }

    public void addInterestingScoutTarget(Player player, string moID) {
        Console.WriteLine("Adding Interesting Scout Target: " + moID);
        var nhs = new HashSet<string>();
        if (ScoutInterestingTargets.ContainsKey(player)) nhs = ScoutInterestingTargets[player];

        bool newInterestingTarget = true;
        if (nhs.Contains(moID)) newInterestingTarget = false;
        nhs.Add(moID);
        ScoutInterestingTargets[player] = nhs;

        //if (newInterestingTarget) displayNewInterestingScoutTarget(player, moID);

    }

    int ScoutPhotoID = 0;


    Dictionary<Tuple<int, int, aPlayer>, List<string>> ScoutPhotoRecord = new Dictionary<Tuple<int, int, aPlayer>, List<string>>(); //<int,int> = ScoutPhotoID, Army; <string> = Mission Objective keys
                                                                                                                                    //ScoutPhotoRecord_class ScoutPhotoRecord = new ScoutPhotoRecord_class(); //<int,int> = ScoutPhotoID, Army

    Dictionary<Player, HashSet<string>> ScoutInterestingTargets = new Dictionary<Player, HashSet<string>>(); //Interesting objectives in given area, such as mobile, primary, whatever that the scouting player might want to take a screenshot of.

    //NOTE: ScoutPhotoRecord is saved/restored during our usual regular/periodic backups & then restored on mission start
    public Dictionary<Player, int> LastPhotoTime_sec = new Dictionary<Player, int>(); //last time in seconds player took a photo

    public void MO_TakeScoutPhoto(Player player, int army, double delay = 0.2, Point3d? test = null)
    {
        //TODO: This fails silently if the player isn't in a plane
        //Task.Run(() =>

        {
            if (player == null || player.Place() == null) return;
            bool firstPhotoThisSession = true;
            if (LastPhotoTime_sec.ContainsKey(player)) firstPhotoThisSession = false;
            int currTime_sec = Time.tickCounter() / 33;
            if (LastPhotoTime_sec.ContainsKey(player) && (currTime_sec - LastPhotoTime_sec[player]) < 15)
            {
                gpLogServerAndLog(new Player[] { player }, "Recon photo NOT recorded - photo once every 15 seconds at most! ", null);
                // + currTime_sec.ToString() + " " + LastPhotoTime_sec[player].ToString()
                return;
            }

            int numScouted = 0;
            string minAlt = "10000 feet";
            if (army == 2) minAlt = "3000m";

            bool fail = false;
            string reason = "";
            if (player.Place() as AiAircraft == null && !test.HasValue)
            {
                fail = true;
                reason += "Not in aircraft ";
            }

            AiAircraft aircraft = player.Place() as AiAircraft;

            Point3d pos = aircraft.Pos();
            if (test.HasValue) pos = test.Value; //for testing

            double altitude = pos.z;

            if (altitude < 3000)
            {
                fail = true;
                reason += "Altitude too low ";
                LastPhotoTime_sec[player] = currTime_sec;
                if (MO_CheckForGeneralStaffReconPhoto(player, aircraft, army, pos)) return; //If they're taking a legit general staff recon photo we don't give an error message
            }

            double radiusCovered_m = altitude / 0.342;  //(Sin (20 degrees) = 0.342)  Meaning that we can scout things 20 degrees below the horizon & lower.  This might be a little ambitious, but also maybe not?

            string alt = (radiusCovered_m / 1000.0).ToString("F1") + " km";
            if (army == 1) alt = (Calcs.meters2feet(radiusCovered_m) / 5280.0).ToString("F1") + " miles";

            if (aircraft.AirGroup().hasBombs())
            {
                fail = true;
                reason += "Aircraft indicates 'has bombs' ";
            }

            if (fail)
            {
                Console.WriteLine("Scout photo: fail alt:{0} ppasAC:{1} hasBombs:{2}", altitude, player.Place() as AiAircraft, aircraft.AirGroup().hasBombs());
                twcLogServer(new Player[] { player }, "You must be in an aircraft, with no bombs on board, above " + minAlt + ", to successfully take a reconnaissance photo. (" + reason + ")", new object[] { });
                return;
            }

            LastPhotoTime_sec[player] = currTime_sec;
            ScoutPhotoID++;

            List<string> keys = new List<string>();

            twcLogServer(new Player[] { player }, ">>> Reconnaissance photo successfully taken, covering a radius of approx. " + alt + ".", new object[] { });

            bool interestingScoutTarget = false;

            foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
            //foreach (var key in MissionObjectives[(ArmiesE)army])
            {
                //mo.AttackingArmy == army

                MissionObjective mo = entry.Value;

                //if (!mo.Destroyed && mo.AttackingArmy == army && mo.IsEnabled && !mo.Scouted && Calcs.CalculatePointDistance (mo.Pos, pos) < radiusCovered_m) // no reason they can't scout destroyed objects - some might be undestroyed sometime soon. Also we're allowing multiple people to scout the same objective now, they just get less points if they are not the first.
                //So for targets that MOVE (_Chief) we havea problem, because we won't pick them up if we are scouting the area where they now ARE but we will pick them
                //up if you scout the area where they started at.  So we'll add in a kludge, you also pick them up if you scout the area where they were LAST SCOUTED.  Usually this is good enough
                //As they don't really move that far.  But just in case, we also do returnCurrentPosWithChief() instead of just plan mo.Pos
                if (mo.AttackingArmy == army && (Calcs.CalculatePointDistance(mo.returnCurrentPosWithChief(), pos) < radiusCovered_m || Calcs.CalculatePointDistance(mo.lastScoutedPos, pos) < radiusCovered_m))
                {
                    keys.Add(entry.Key);
                    numScouted++;

                    //So, we add some targets into the "interesting targets list" which then displays to the scout some possible coordinates to take screenshots of
                    if (mo.IsPrimaryTarget && mo.MOMobileObjectiveType != MO_MobileObjectiveType.None) addInterestingScoutTarget(player, entry.Key);//  ScoutInterestingTargets.Add(entry.Key); 
                    else if (mo.IsPrimaryTarget && mo.hasChief())
                    {
                        addInterestingScoutTarget(player, entry.Key);// ScoutInterestingTargets.Add(entry.Key);
                        interestingScoutTarget = true;
                    }
                    else if (mo.hasChief() && random.NextDouble() < 0.65) //moving targets, like convoys or ships
                    {
                        addInterestingScoutTarget(player, entry.Key);// ScoutInterestingTargets.Add(entry.Key);
                        interestingScoutTarget = true;
                    }
                    else if (mo.IsEnabled && mo.MOMobileObjectiveType != MO_MobileObjectiveType.None && random.NextDouble() < 0.15)
                    {
                        addInterestingScoutTarget(player, entry.Key);// ScoutInterestingTargets.Add(entry.Key);
                        interestingScoutTarget = true;
                    }
                    else if (mo.IsPrimaryTarget && random.NextDouble() < 0.02)
                    {
                        addInterestingScoutTarget(player, entry.Key);// ScoutInterestingTargets.Add(entry.Key);
                        interestingScoutTarget = true;
                    }
                }
                
            }

            var recordKey = new Tuple<int, int, aPlayer>(ScoutPhotoID, army, new aPlayer(player));
            ScoutPhotoRecord.Add(recordKey, keys);

            if (interestingScoutTarget || random.NextDouble() < 0.33) //so once in a while we display interesting scout target sectors, if there are any so far and they are still nearby.
            {
                Timeout(12, () =>
                {
                    Console.WriteLine("displaying interesting scout targets");
                    displayInterestingScoutTargets(player, radiusCovered_m * 1.75);
                });
            }

            Timeout(2 * 60 * 60, () =>
            {
                if (ScoutPhotoRecord.ContainsKey(recordKey) && !photosRecorded.Contains(recordKey)) //if it's still in the photorecord but NOT in the photosrecorded, we spoil
                {
                    int total = ScoutPhotoRecord[recordKey].Count();
                    ScoutPhotoRecord.Remove(recordKey);
                    if (total > 0) twcLogServer(new Player[] { player }, "I'm sorry to inform you that your reconnaissance photo taken over 2 hours ago identifying " + total.ToString() + " objectives was spoiled due to equipment malfunction during an overly extended flight.", new object[] { });
                }

            }); //spoil it after 2 hours if not returned

            /*
            if (numScouted == 0)
            {
                Timeout(3, () =>
                {
                    twcLogServer(new Player[] { player }, ">>> That area did not look very promising for locating valuable objectives.", new object[] { });
                    return;
                });
            }
            */

            numScouted += Convert.ToInt32(Math.Round(random.Next(numScouted * 3) / 4.0 - numScouted * 3.0 / 8.0)); //fuzz the result a little
            if (numScouted < 0) numScouted = 0;
            string msg1 = ">>> That area did not look very promising for locating valuable objectives.";
            if (numScouted > 0) msg1 = ">>> It looks like that area may contain a few valuable military objectives.";
            if (numScouted > 8) msg1 = ">>> It looks like that area may contain several valuable military objectives.";

            Timeout(1.5, () =>
            {
                twcLogServer(new Player[] { player }, msg1, new object[] { });
            });

            if (firstPhotoThisSession) //onlyi give this announcement for the FIRST photo of this session
            {
                Timeout(3, () =>
                {
                    twcLogServer(new Player[] { player }, "Reconnaissance results will be available after you land safely and headquarters has a chance to analyze the photos fully.", new object[] { });
                });
                Timeout(4.5, () =>
                {
                    twcLogServer(new Player[] { player }, "You have two hours to return and land safely or the photo will be spoiled.", new object[] { });
                });
            }
            /*
            else
            {
                Timeout(4.5, () =>
                {
                    twcLogServer(new Player[] { player }, ">>> One hour to land/record photo.", new object[] { });
                });
            }
            */
            //});
        }
    }

    public void MO_SpoilPlayerScoutPhotos(Player player)
    {
        Task.Run(() =>
        {
            int total = 0;
            var ScoutPhotoRecord_copy = new Dictionary<Tuple<int, int, aPlayer>, List<string>>(ScoutPhotoRecord); //<int,int> = ScoutPhotoID, Army
            foreach (KeyValuePair<Tuple<int, int, aPlayer>, List<string>> entry in ScoutPhotoRecord_copy)
            {
                if (entry.Key.Item3 != new aPlayer(player)) continue;
                total += ScoutPhotoRecord[entry.Key].Count;
                ScoutPhotoRecord.Remove(entry.Key);
            }
            if (total > 0)
                Timeout(20, () => //wait a while for message because it often comes when player died, crashed, etc, many other messages coming through at once.
                {
                    twcLogServer(new Player[] { player }, "I'm sorry to inform you that your reconnaissance photos identifying " + total.ToString() + " objectives were lost.", new object[] { });
                });
        });
    }

    public void MO_SpoilPlayerScoutPhotos(HashSet<Player> players)
    {

        foreach (Player player in players)
        {
            MO_SpoilPlayerScoutPhotos(player);
        }

    }


    HashSet<Tuple<int, int, aPlayer>> photosRecorded = new HashSet<Tuple<int, int, aPlayer>>();

    //check = true means, the player is requesting to record the photos, ie, checking.
    //Otherwise it is some automated thing & no message is required unless there is success.
    public void MO_RecordPlayerScoutPhotos(Player player, bool check = false, bool test = false)
    {
        if (check) twcLogServer(new Player[] { player }, "Checking recon photos . . . ", new object[] { });
        if (GamePlay == null) return;
        Task.Run(() =>
        {
        try
        {
            if (player == null) return;
                if (test ||
                    (player.Place() != null && (player.Place() as AiAircraft) != null &&
                    GamePlay.gpFrontArmy(player.Place().Pos().x, player.Place().Pos().y) == player.Army() &&
                    //Stb_distanceToNearestAirport(actor) < 3100 &&
                    Calcs.CalculatePointDistance((player.Place() as AiAircraft).AirGroup().Vwld()) < 2 &&
                    player.Place().IsAlive())
                    )
                {//it's good 
                 //(do nothing)
                }
                else
                {//it's no good
                    string reason = "";
                    if (player.Place() == null || (player.Place() as AiAircraft) == null) reason += "Not in an aircraft - ";
                    if (GamePlay.gpFrontArmy(player.Place().Pos().x, player.Place().Pos().y) != player.Army()) reason += "Not in on friendly territory - ";
                    //Stb_distanceToNearestAirport(actor) < 3100 &&
                    double vel_mps = Calcs.CalculatePointDistance((player.Place() as AiAircraft).AirGroup().Vwld());
                    if (vel_mps >= 2) reason += "You are still moving (" + vel_mps.ToString("F1") + ") - ";
                    if (!player.Place().IsAlive()) reason += "CLOD says your aircraft is dead/crashed";
                    if (check)
                    {
                        twcLogServer(new Player[] { player }, "You can't check in your reconnaissance photos now - you must be safely landed, in your aircraft with the photos, on friendly ground and ideally at an air base.", new object[] { });
                        Timeout(0.05, () =>
                        {
                            twcLogServer(new Player[] { player }, "Reasons: " + reason, new object[] { });
                        });
                    }
                    return;
                }

                Console.WriteLine("RCRec: #1");

                if (ScoutPhotoRecord == null || ScoutPhotoRecord.Count == 0) return;

                int totalPhotos = 0;
                int total = 0;
                int totalPrimary = 0;
                int totalSecondary = 0;
                int totalRadar = 0;
                int totalAirfield = 0;
                int totalShip = 0;
                int totalFuel = 0;
                int totalNeverScouted = 0;
                int army = player.Army();
                //List<String> mos = MissionObjectivesSuggested[(ArmiesE)army];
                List<String> mos = MO_ListSuggestedObjectives(null, player.Army(), display: false); //Get the current list of MissionObjectivesSuggested[(ArmiesE)OldObj.AttackingArmy];

                

                var ScoutPhotoRecord_copy = new Dictionary<Tuple<int, int, aPlayer>, List<string>>(ScoutPhotoRecord); //<int,int> = ScoutPhotoID, Army

                //Console.WriteLine("RCRec: #2");

                HashSet<string> objectivesIDed = new HashSet<string>();

                //Console.WriteLine("RCRec: #2a");

                foreach (KeyValuePair<Tuple<int, int, aPlayer>, List<string>> entry in ScoutPhotoRecord_copy)
                {
                    try
                    { //if the on-disk copy of ScoutPhotoRecord gets messed upsometimes the values are really wonky and give an error here no matter what.  So this catches them & continues, if possible.
                      //Console.WriteLine("RCRec: #2b");
                        if (entry.Key == null || photosRecorded.Contains(entry.Key)) continue;  //This photo already recorded this session.  prevents double-counting photos/objectives found while HQ is 'processing' the info for up to 360 seconds.
                                                                                                //if (entry.Key.Item3 != new aPlayer(player)) continue;
                                                                                                //Console.WriteLine("RCRec: #2c");
                        aPlayer aplayer = new aPlayer(player);
                        //Console.WriteLine("RCRec: #2d");
                        if (entry.Key == null) continue;
                        //Console.WriteLine("RCRec: #2da");
                        //Console.WriteLine("RCRec: #2da" + entry.Key.ToString());
                        if (DBNull.Value.Equals(entry.Key.Item1) || DBNull.Value.Equals(entry.Key.Item2) || DBNull.Value.Equals(entry.Key.Item3)
                            || DBNull.Value.Equals(entry.Key.Item3.name) || DBNull.Value.Equals(entry.Key.Item3.army)) continue; //This can happen if data is empty or just corrupted.
                                                                                                                                 //Console.WriteLine("RCRec: #2da" + entry.Key.Item3.ToString());
                                                                                                                                 //Console.WriteLine("RCRec: #2da" + (entry.Key.Item3).GetType().ToString());
                                                                                                                                 //if (entry.Key.Item3.name == "") Console.WriteLine("yes"); 

                        if (entry.Key.Item3 == null) continue;
                        //Console.WriteLine("RCRec: #3da");
                        //if (entry.Key.Item3.name == null) continue;
                        //Console.WriteLine("RCRec: #3da");
                        //if (entry.Key.Item3.army == null) continue;
                        /* Console.WriteLine("RCRec: #3da");
                        Console.WriteLine("RCRec: #3db" + aplayer.name);
                        Console.WriteLine("RCRec: #3dc" + entry.Key.Item3.name);
                        Console.WriteLine("RCRec: #3dd" + entry.Key.Item3.army.ToString());
                        Console.WriteLine("RCRec: #3de" + aplayer.army.ToString());
                        */

                        if (entry.Key.Item3.name != aplayer.name || entry.Key.Item3.army != aplayer.army) continue;
                        //if (entry.Key.Item3 == null || entry.Key.Item3 != aplayer) continue;
                        //Console.WriteLine("RCRec: #2e");

                    }
                    catch (Exception ex)
                    {
                        try { ScoutPhotoRecord.Remove(entry.Key); } catch (Exception ex1) { Console.WriteLine("Record Scout Photo error2!!! " + ex1.ToString()); }
                        Console.WriteLine("Record Scout Photo error!!! " + ex.ToString());
                        continue;
                    }
                    totalPhotos++;

                    //Console.WriteLine("RCRec: #3");

                    if (player.Army() == 1) RedScoutPhotosI++;
                    if (player.Army() == 2) BlueScoutPhotosI++;
                    if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_IncrementSessStat(player, 848);  //848 recon photos taken, 849 # of objectives photographed
                    if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, 848, 1);

                    string amalg = player.Name() + player.Army().ToString();

                    var copyList = new List<string>(entry.Value);
                    copyList.Add(amalg);

                    int seed = Calcs.seedObj(copyList.ToArray());

                    Random repeatRandom = new Random(seed);

                    Console.WriteLine("RCRec: #4 " + seed.ToString());

                    foreach (string key in entry.Value)
                    {
                        try
                        {
                            //So, from a given recon mission we only identify 1/4 of possible objectives in that area.  Because recon photos aren't perfect, photo intelligence ID
                            //of targets isn't perfect, etc. So that we reconning the same area again might result in more targets IDed.
                            //But, we always identify primary targets, not because recon is specially good for them, but because  HQ has chosen the primary targets based on 
                            //Recon photos returned.  
                            //FUTURE: Maybe 1/4 of targets IDed is too much or too little.  Or maybe it varies day to day depending on weather, time of day photo taken, etc.

                            //However, if we have already IDed this objective from previous recon flights, then we always add knowledge/credit more for that one.
                            //Because Photo Intel already knows where it is etc.

                            if (!MissionObjectivesList.ContainsKey(key)) continue; //maybe this objective has been deleted/removed/whatever since it was originally scouted

                            MissionObjective mo = MissionObjectivesList[key];
                            int ct = objectivesIDed.Count;
                            objectivesIDed.Add(key);

                            //Console.WriteLine("RCRec: #5");                
                            if (!mo.IsEnabled && mo.Scouted)
                            {
                                //mo.Scouted = false;
                                mo.makeScouted(player); // for disabled objectives this will just mark them as scouted, but then removed per further scouting and this will show up on the recon list as "No Longer There !!!1!!"
                                continue;
                            } //There are a lot of possible things to do here, but for now just remove from the scouted list so that it doesn't show up there as a nice target to visit any more.
                            if (!mo.IsEnabled) continue;

                            if (!mo.IsPrimaryTarget && !mo.Scouted && repeatRandom.Next(4) != 0) continue;  //only "find" 1/4 of the objectives in the scouted area.  But **always** find the primary targets; always skip disabled.  Add the mo to the processed list first, THEN determine if it is one of the 1/4 identified.  Otherwise each mo could get multiple chances to be picked, if the player has taken multiple photos of the same area.  Also, always re-find previously found objectives.


                            if (ct != objectivesIDed.Count) //only bother doing all this stuff if it's new/unique object not before identified during this photo processing run from this player
                            {

                                if (player.Army() == 1) RedScoutedObjectivesI++;
                                if (player.Army() == 2) BlueScoutedObjectivesI++;
                                if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_IncrementSessStat(player, 849);  //848 recon photos taken, 849 # of objectives photographed
                                if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, 849, 1);

                                //Console.WriteLine("RCRec: #6");
                                int time = 360;
                                if (test) time = 10;

                                //make sure they're all recorded before the mission ends.
                                int timeleft_sec = calcTimeLeft_min() * 60;
                                if (time > timeleft_sec) time = timeleft_sec;
                                if (time < 1) time = 1;//Sometimes timeleft is <0, maybe?
                                
                                Timeout(random.Next(time), () =>
                                {
                                    mo.makeScouted(player);
                                    if (mo.hasGeneralStaff)
                                    {
                                        string af = "RAF";
                                        if (army == 1) af = "Luftwaffe";
                                        string name = "";
                                        if (player != null && player.Name() != null) name = " by " + player.Name();
                                        string msg7 = ">>>Recon" + name + " has identified a possible group of high-ranking " + af + " officers near " + mo.Name;
                                        twcLogServer(null, msg7, null);
                                    }
                                }); //Some delay for careful analysis, before they show up in the in-game lists. 

                                //Console.WriteLine("RCRec: #7");
                                total++;
                                if (mo.IsPrimaryTarget) totalPrimary++;
                                if (mos.Contains(key) && mos.IndexOf(key) < 5) totalSecondary++;
                                if (mo.MOObjectiveType == MO_ObjectiveType.Radar) totalRadar++;
                                if (mo.MOObjectiveType == MO_ObjectiveType.Airfield) totalAirfield++;
                                if (mo.MOObjectiveType == MO_ObjectiveType.Ship) totalShip++;
                                if (mo.MOObjectiveType == MO_ObjectiveType.Fuel) totalFuel++;
                                if (!mo.Scouted) totalNeverScouted++;

                                //Console.WriteLine("RCRec: #8");
                                //Radar, AA, Ship, Building, Fuel, Airfield, Aircraft, Vehicles, Bridge, Dam, Dock, RRYard, Railroad, Road, AirfieldComplex, FactoryComplex, ArmyBase
                            }
                        }
                        catch (Exception ex)
                        {                            
                            Console.WriteLine("Record Scout Photo error 3!!! " + ex.ToString());
                            continue;
                        }

                    }
                    //Console.WriteLine("RCRec: #9");
                    photosRecorded.Add(entry.Key); //avoid processing this photo again this session, but leave it in the ScoutPhotoRecord until all items have been processed, just to avoid losing data when the server dies or whatever
                    Timeout(360, () => ScoutPhotoRecord.Remove(entry.Key)); //to avoid losing data in case of server crash/exit/etc we delay deleting this photo until 360 seconds after initial processing, when all the mos should be marked scouted.  So if the server crashes in the meanwhile, the photo(s) can just be re-read & re-processed on next restart.
                                                                            //Console.WriteLine("RCRec: #10");
                }

                if (total == 0 && totalPhotos > 0) twcLogServer(new Player[] { player }, "I'm sorry to inform you that your " + totalPhotos.ToString() + " reconnaissance photos identified no new objectives.", new object[] { });
                else if (totalPhotos == 0 && check) twcLogServer(new Player[] { player }, "You have no reconnaissance photos to process.  Perhaps they were processed automatically when you landed?", new object[] { });

                //Console.WriteLine("RCRec: #11");
                if (total > 0)
                {
                    int totalOthers = total - totalPrimary - totalSecondary;
                    if (totalOthers < 0) totalOthers = 0;
                    twcLogServer(new Player[] { player }, ">>>> Your " + totalPhotos.ToString() + " reconnaissance photos identified " + total.ToString() + " objectives, including " + totalPrimary.ToString() + " HQ has named as primary objectives, " + totalSecondary.ToString() + " HQ named as secondary objectives, and " + totalOthers.ToString() + " other important objectives.", new object[] { });
                    Timeout(1.5, () =>
                    {
                        twcLogServer(new Player[] { player }, ">>>> Among the objectives: " + totalRadar.ToString() + " radar installations, " + totalAirfield.ToString() + " airfields, " + totalFuel.ToString() + " fuel dumps, " + totalShip.ToString() + " ships, " + totalNeverScouted.ToString() + " objectives not previously identified, and confirmation of " + (total - totalNeverScouted).ToString() + " objectives previously identified.", new object[] { });
                    });
                    Timeout(3, () =>
                    {
                        twcLogServer(new Player[] { player }, ">>>> Precise mapping coordinates for your objectives will be available via Tab-4-8 in a few minutes, after headquarters has a chance to carefully analyze the photos.", new object[] { });
                    });

                }
                //Console.WriteLine("RCRec: #12");
            }
            catch (Exception ex)
            {
                Console.WriteLine("Record Scout Photo error 2 major!!! " + ex.ToString());
            }
        });
    }

    public void MO_RecordPlayerScoutPhotos(HashSet<Player> players)
    {

        foreach (Player player in players)
        {
            MO_RecordPlayerScoutPhotos(player);
        }

    }

    //note - only lists first 12 targets BY DEFAULT
    public string MO_ListRemainingPrimaryObjectives(Player player, int army, int numToDisplay = 24, double delay = 0.2, bool display = true, bool html = false, bool leak = false)
    {

        string newline = Environment.NewLine;
        if (html) newline = "<br>" + Environment.NewLine;
        string retmsg = "";
        string msg = "";

        Player[] recipients = new Player [] { };
        if (player != null) recipients = new Player[] { player };

        if (leak) recipients = AllPlayersInArmyArray(3 - army); //Leak displays the enemy's current target list to the opposite army players

        int numDisplayed = 0;
        double totDelay = 0;        

        if (MO_BRBumrushActive())
        {
            if (leak) return "";//No need for leaks in bumrush stage
            msg = ArmiesL[army].ToUpper() + " SOLE REMAINING OBJECTIVE:";
                        
            if (display) twcLogServer(recipients, msg, new object[] { });
            retmsg = msg + newline;

            int ar = 1;
            if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) ar = 2;

            string msg1 = "*****" + ArmiesL[ar] + " is attempting to overrun " + MO_BRBumrushInfo[(ArmiesE)ar].BumrushAirportName + " with ground troops and clear all enemy ground units from the area. " + ArmiesL[ar] + " must support and " + ArmiesL[3 - ar]
                + " must try to repel the ground attack" + " (" + MO_BRBumrushTimeLeft_min_string() + " min.)";
            if (MO_BRBumrushInfo[(ArmiesE)ar].BumrushStatus % 2 == 0)
                msg1 = "*****" + ArmiesL[3 - ar] + " is attempting to recapture " + MO_BRBumrushInfo[(ArmiesE)ar].BumrushAirportName + " with ground troops. " + ArmiesL[3 - ar] + " must support and " + ArmiesL[ar]
                + " must try to repel the ground attack" + " (" + MO_BRBumrushTimeLeft_min_string() + " min.)"; 

            retmsg += msg1 + newline + newline;
            totDelay += delay;
            if (display)
            {
                Timeout(totDelay, () =>
                {
                    twcLogServer(recipients, msg1, new object[] { });
                });//timeout      
            }

            numDisplayed++;

            int brArmy = 1;

            if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) brArmy = 2;

            MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)brArmy].BumrushObjective;

            //NOTE: ---MUST synchronize these values with 
            //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.BumrushObjective.Pos, 2500, army, AiGroundGroupType.Vehicle);
            int redFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 1, type: "Vehicle");
            int redFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 1, type: "Artillery");
            int redClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: 1, type: "Vehicle");
            int redFar = redFarArtillery + redFarVehicle;


            int blueFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 2, type: "Vehicle");
            int blueFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 2, type: "Artillery");
            int blueClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: 2, type: "Vehicle");
            int blueFar = blueFarArtillery + blueFarVehicle;

            if (blueClose > 1)
            {
                msg1 = String.Format("Blue has " + blueClose.ToString() + " attack vehicles occupying the target airport ({0:F0}m radius); Red has " + redFar.ToString() + " attack vehicles/artillery in the area surrounding ({1:F0}m radius)", MO_BRBumrushAirbaseOccupyDistance_m, MO_BRBumrushAirbaseClearPerimeterDistance_m);

                //If there are only a couple of enemy holdouts left we start giving a hint as to where they are
                string addM = "";
                if (redFar < 3)
                {
                    AiActor a = Calcs.GetGroundActorNear(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 1);
                    if (a != null) addM = " (" + Calcs.correctedSectorNameDoubleKeypad(this, a.Pos()) + ")";
                }

                retmsg += msg1 + addM + newline;
                totDelay += delay;
                if (display)
                {
                    Timeout(totDelay, () =>
                    {
                        twcLogServer(recipients, msg1, new object[] { });
                    });//timeout      
                }
                numDisplayed++;
            }

            if (redClose > 1)
            {
                msg1 = String.Format("Red has " + redClose.ToString() + " attack vehicles occupying the target airport ({0:F0} m); Blue has " + blueFar.ToString() + " attack vehicles/artillery in the area surrounding ({1:F0}m.", MO_BRBumrushAirbaseOccupyDistance_m, MO_BRBumrushAirbaseClearPerimeterDistance_m);

                //If there are only a couple of enemy holdouts left we start giving a hint as to where they are
                string addM = "";
                if (blueFar < 3)
                {
                    AiActor a = Calcs.GetGroundActorNear(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 2);
                    if (a != null) addM = " (" + Calcs.correctedSectorNameDoubleKeypad(this, a.Pos()) + ")";
                }

                retmsg += msg1 + addM + newline;
                totDelay += delay;
                if (display)
                {
                    Timeout(totDelay, () =>
                    {

                        twcLogServer(recipients, msg1, new object[] { });

                    });//timeout      
                }
                numDisplayed++;
            }

        }
        
        if (!MO_BRBumrushActive() || army != MO_BRObjectivesAchievedArmy()) //We'll display the objectives if bumrush is inactive, but also when it IS active, for the army that does not have objectives achieved
        {
            msg = "REMAINING " + ArmiesL[army].ToUpper() + " PRIMARY OBJECTIVES:";
            if (leak) msg = "REMAINING " + ArmiesL[army].ToUpper() + " PRIMARY OBJECTIVES (INTELLIGENCE LEAK from low-level General Staff recon photos):";
            if (display) twcLogServer(recipients, msg, new object[] { });
            retmsg = msg + newline;
            if (!leak)
            {

                msg = ">>> NOTE: Last scouted position/time shown. If recon areas are listed, those sectors need to be scouted.";
                if (display) twcLogServer(recipients, msg, new object[] { });
                retmsg += msg + newline;

                msg = ">>> Scout the areas and take recon photos - Tab-4-9. HQ will then identify specific targets & details.";
                if (display) twcLogServer(recipients, msg, new object[] { });
                retmsg += msg + newline;
            }

            foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
            {

                if (numDisplayed >= numToDisplay) break;
                MissionObjective mo = entry.Value;
                if (!mo.ObjectiveAchievedForPoints && mo.AttackingArmy == army && mo.IsPrimaryTarget)
                {

                    string msg1 = "Recon area: " + mo.bigSector;
                    if (mo.Scouted)
                    {
                        string pc = "";
                        if (mo.DestroyedPercent > 0) pc = ", " + (mo.DestroyedPercent * 100.0).ToString("F0") + "%";
                        string dl = " Priority " + mo.Points.ToString();
                        string ls = "";
                        if (mo.lastTimeScouted_dt.HasValue)
                        {
                            TimeSpan diff = DateTime.UtcNow - mo.lastTimeScouted_dt.Value;
                            string excl = "";
                            if (diff.TotalHours > 15 && mo.isMobile()) excl = "!";
                            ls = " " + excl + (Math.Round(diff.TotalHours * 2.0) / 2.0).ToString("F0") + "hr" + excl;
                        }

                        msg1 = mo.lastScoutedSector + " " + mo.Name + " (" + mo.lastScoutedPos.x.ToString("F0") + ", " + mo.lastScoutedPos.y.ToString("F0") + ", " + mo.lastScoutedPos.z.ToString("F0") + ")" + ls + dl + pc;
                    }
                    retmsg += msg1 + newline;
                    totDelay += delay;
                    if (display)
                    {
                        Timeout(totDelay, () =>
                        {

                        //+ " (" + mo.Pos.x + "," + mo.Pos.y + ")" //to display x,y coordinates
                        twcLogServer(recipients, msg1, new object[] { });

                        });//timeout      
                    }

                    numDisplayed++;

                }
            }
        }

        return retmsg;
    }

    public string MO_SectorOfRandomRemainingPrimaryObjective(int army)
    {

        var remainingMOs = new List<MissionObjective>();

        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {

            MissionObjective mo = entry.Value;
            if (!mo.ObjectiveAchievedForPoints && mo.AttackingArmy == army && mo.IsPrimaryTarget && mo.IsEnabled)
            {
                remainingMOs.Add(mo);
            }
        }

        if (remainingMOs.Count <= 0) return "";

        MissionObjective m = remainingMOs.OrderBy(x => Guid.NewGuid()).FirstOrDefault();

        return Calcs.correctedSectorNameKeypad(this, m.Pos);
    }

    public void MO_WriteOutAllMissionObjectives(string filename, bool misformat = true, bool triggersonly = false)
    {


        List<string> keys = MissionObjectivesList.Keys.ToList();
        //keys.Sort();       //unfortunately sorting just actually scrambles them hopelessly
        string op = "";
        DateTime utcDate = DateTime.UtcNow;
        op += utcDate.ToString("u") + Environment.NewLine;
        if (!misformat) op += "Can view with text editor or Excel (tab-delimited text file). If you open in Excel, save immediately with a new name so you don't block this file being re-written by a new mission." + Environment.NewLine;

        if (!misformat) op += "ID\tName\tAttackingArmy\tOwnerArmy\tIsEnabled\tMOObjectiveType\tMOTriggerType\tIsPrimaryTarget\tPrimaryTargetWeight\tPoints\tDestroyed\tPos.x\tPos.y\tSector\tRadarEffectiveRadius\tTriggerName\tTriggerType\tTriggerPercent\tTriggerDestroyRadius\tStaticPercentageRequired\tStaticRemoveDelay_sec\tStaticRemoveSpread_sec\tComment\tHUDMessage\tLOGMessage\tStaticNames\tStaticRemoveNames" + Environment.NewLine;


        //foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        foreach (string k in keys)
        {


            MissionObjective mo = MissionObjectivesList[k];
            if (triggersonly && !mo.MOTriggerType.Equals(MO_TriggerType.Trigger)) continue;
            if (misformat)
            {
                op += mo.ToString(misformat) + Environment.NewLine;
            }
            else
            {
                op += mo.ToString(misformat) + Environment.NewLine;
            }

        }

        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX6 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
        try
        {
            string filepath = CLOD_PATH + FILE_PATH + @"/" + filename;
            //File.WriteAllText(filepath, op);
            Calcs.WriteAllTextAsync(filepath, op);
        }
        catch (Exception ex) { Console.WriteLine("MO_WriteOutAll: " + ex.ToString()); }
    }

    HashSet<string> MO_flakMissionsLoaded = new HashSet<string>();
    public bool MO_LoadAllPrimaryObjectiveFlak(Dictionary<string, string> flakMissions)
    {


        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {
            MissionObjective mo = entry.Value;
            if (mo.IsPrimaryTarget && mo.IsEnabled)
            {
                string flakID = mo.FlakID;
                string flakMission = "";

                if (flakMissions.Keys.Contains(flakID)) flakMission = flakMissions[flakID];
                else Console.WriteLine("LoadFlak: No flak found for " + mo.Name + "  " + flakID);

                if (MO_flakMissionsLoaded.Contains(flakID)) continue;  //Make sure we load each mission just once at most
                MO_flakMissionsLoaded.Add(flakID);

                if (File.Exists(CLOD_PATH + FILE_PATH + "/" + flakMission)) {
                    Timeout(48, () =>
                    {
                        GamePlay.gpPostMissionLoad(CLOD_PATH + FILE_PATH + "/" + flakMission);
                        DebugAndLog(flakMission + " file loaded");
                        Console.WriteLine(flakMission + " file loaded");
                    });

                } else
                {
                    Console.WriteLine("LoadFlak: No flak file found for " + mo.Name + "  " + flakID + " " + flakMission);
                }
            }
        }
        return true;
    }

    //So apparently this messes up the count of postload static files by resetting the counter to 0 mid-calculation of those files.
    //so delaying the loading of these jerrycans solves the problem (kludge/temporary fix)
    public void MO_PlaceAppropriateJerrycan(MissionObjective mo)
    {
        //place a jerrycan in the middle of the area, covering it.  This allows stats to be counted for anything in this area, and also sets up smoke etc for any bombs hitting this area.
        if (mo.TriggerDestroyRadius < 1410)
        {
            string jerry = "JerryCan_GER1_1";
            if (mo.TriggerDestroyRadius > 71) jerry = "JerryCan_GER1_2";
            if (mo.TriggerDestroyRadius > 141) jerry = "JerryCan_GER1_3";
            if (mo.TriggerDestroyRadius > 282) jerry = "JerryCan_GER1_5";
            //if it's greater than 1410 we'll have to figure out something else to do, place several 1_5s around, probably.
            //The JerryCan_GER1_1 (static - environment - jerrycan) covers a radius of 71 meters which is just enough to fill a 100 meter square (seen in FMB at full zoom) to all corners if placed in the center of the 100m square.
            // JerryCan_GER1_2 covers 141m radius (covers 4 100m squares to the corners if placed in the center)
            // JerryCan_GER1_3 covers 282m radius (covers 16 100m squares to the corners if placed in the center)
            // JerryCan_GER1_5 covers 1410m radius (a 1km square to the corner if placed in the center)
            Timeout(random.Next(225, 300), () => //no rush here, better to wait a bit
            {
                Calcs.loadStatic(GamePlay, this, mo.Pos.x, mo.Pos.y, -2, "Stationary.Environment." + jerry);
            });
        }
        else
        {

            double searchRadius_m = MO_CalcMobileObjRadius_m(mo);
            double stretchA = 1;

            ISectionFile f = GamePlay.gpCreateSectionFile();            

            f = PlaceObjectsInCircles(f, MO_Jerrycan282, mo.Pos, searchRadius_m, 4.0 * searchRadius_m / 5.0, Convert.ToInt32(7 * Math.Pow(Math.Ceiling(searchRadius_m / 1000), 2)), mo.OwnerArmy, percentSide: 70, subHeading: -1, stretcherType: 1, stretcherAmt: stretchA, resetCount: false);

            Timeout(random.Next(225, 300), () => //no rush here, better to wait a bit
            {
                GamePlay.gpPostMissionLoad(f);

                f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/jerrycanobj_" + mo.ID); //testing)
            });
        }
    }

    //This needs to be run whenever the objectives list is reinitialized, but also after each mission restart, after the missionobjectiveslist has been reloaded from disk
    public void MO_InitializeAllObjectives()
    {

        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {

            MissionObjective mo = entry.Value;

            
            mo.IsEnabled = true;

            if (!mo.IsPrimaryTarget && mo.CanBeDisabled && random.Next(100) < MO_Objective_Percent_To_Disable) //randomly turn off say 20% of objectives each day.  But, can't turn off radar or airports, etc (if marked as 'can't be disabled'.  For now.
            {
                mo.IsEnabled = false;
                Console.WriteLine("Mo_InitializeAllObjectives: Objective {0} {1} is disabled/removed from the objectives list for this session", mo.ID, mo.Name);
                //MO_PlaceDetritusInObjectArea(mo); //if startup & !enabled, then just place the detritus
                MO_RemoveObjective(mo);
                RemoveSuggestedObjective(mo);
                //We could also do other things here such as removing all the nearby statics or whatever.  Or even just some types of statics.
            }

            MO_HandleMobileObjectivePlacement(mo, startup: true); //place all mobile objectives at start of mission.  We should send all objectives through this, even if disabled as a thing happens even to disabled objectives.

            if (mo.MOTriggerType == MO_TriggerType.TemporaryLandingGround) landinggroundmission.renewTempLandingGround(mo);
                        
            //Console.WriteLine("Initialize - checking " + mo.ID + " " + mo.Name + " {0} {1} {2}", mo.AutoFlak, mo.AutoFlakIfPrimary, mo.IsPrimaryTarget);
            if (mo.IsEnabled)
            {


                //load submission if requested
                if (mo.InitSubmissionName != null && mo.InitSubmissionName.Length > 0)
                {
                    string s = CLOD_PATH + FILE_PATH + "/" + mo.InitSubmissionName;
                    try
                    {
                       Timeout(5, () =>
                       {
                           GamePlay.gpPostMissionLoad(s);
                           Console.WriteLine(s.Replace(CLOD_PATH + FILE_PATH, "") + " file loaded");
                       });
                    } catch (Exception ex) { Console.WriteLine("MO_InitializeAllObjectives ERROR InitSubmission for Objective NOT loaded: {0} \n\n {1}", s, ex.ToString()); }

                }
                if (mo.MOTriggerType == MO_TriggerType.PointArea )
                {
                    MO_PlaceAppropriateJerrycan(mo);
                }

                bool isMobile = false;
                if ((mo.MOMobileObjectiveType != null && mo.MOMobileObjectiveType != MO_MobileObjectiveType.None)) isMobile = true;

                //for Blue radars, but only non-mobile radar types and not the mini/local radars
                if (mo.MOObjectiveType == MO_ObjectiveType.Radar && mo.OwnerArmy == 2 && !isMobile  && mo.RadarEffectiveRadius > 9999 )
                { //create another radar just at the radius of the trigger area, that also must be destroyed. Then adjust points in addradarpointarea to match 90% of the total objects that are there.
                    //Going to be hard.
                    double angle = random.NextDouble() * 2 * Math.PI;
                    double x = Math.Cos(angle) * (5*mo.TriggerDestroyRadius/6) + mo.Pos.x; //place another radar SOMEWHERE INSIDE the triggerradius;
                    double y = Math.Sin(angle) * (5*mo.TriggerDestroyRadius/6) + mo.Pos.y;

                    ISectionFile f = GamePlay.gpCreateSectionFile();
                    f = Calcs.makeStatic(f, GamePlay, this, x, y, mo.Pos.z, "Stationary.Radar.Wotan_II", side: "de", resetCount: true);
                    f = Calcs.makeStatic(f, GamePlay, this, x + 0.5, y + 0.2, mo.Pos.z, "Stationary.Environment.JerryCan_GER1_1", side: "de");//Give them a couple small black dots to find

                    //so it actually seems more interesting to just leave them be with, if you hit the two radars you knock it out & otherwise, not.  The extra "objects" don't really seem to add that much.
                    //Also if they can' get both items they can still get the objective by piling enough KG near the target.
                    /*                    
                    f = Calcs.makeStatic(f, GamePlay, this, x - 3.7, y +4.5, mo.Pos.z, "Stationary.Environment.JerryCan_GER1_1", side: "de");
                    f = Calcs.makeStatic(f, GamePlay, this, x - 4.6, y - 4.6, mo.Pos.z, "Stationary. Environment.JerryCan_GER1_1", side: "de");
                    f = Calcs.makeStatic(f, GamePlay, this, x + 5.2, y - 5.6, mo.Pos.z, "Stationary.Environment.JerryCan_GER1_1", side: "de");
                    
                    f = Calcs.makeStatic(f, GamePlay, this, x + 3, y + 3, mo.Pos.z, "Stationary.Weapons_.Bomb_B_SD-500_E", side: "de");//Give them a couple small black dots to find
                    f = Calcs.makeStatic(f, GamePlay, this, x - 3.5, y + 3, mo.Pos.z, "Stationary.Weapons_.Bomb_B_SD-500_E", side: "de");
                    f = Calcs.makeStatic(f, GamePlay, this, x - 3.5, y - 4, mo.Pos.z, "Stationary.Weapons_.Bomb_B_SD-500_E", side: "de");
                    f = Calcs.makeStatic(f, GamePlay, this, x + 5, y - 4.5, mo.Pos.z, "Stationary.Weapons_.Bomb_B_SD-500_E", side: "de");
                    */
                    

                    GamePlay.gpPostMissionLoad(f);
                    f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/blueradarUPDATE_FILE_" + mo.ID + ".txt"); //testing

                    //TESTING BIRTHPLACES                  
                    /*  
                    ISectionFile f2 = GamePlay.gpCreateSectionFile();
                    f2 = Calcs.CreateBirthPlace(f2, mo.ID + "_airspawn", mo.Pos.x, mo.Pos.y, 666, mo.AttackingArmy);
                    GamePlay.gpPostMissionLoad(f2);
                    */

                    //takes a while to gpload files, so must wait a bit.
                    Timeout(60, () =>
                    {
                        double numTargets = 0;
                        GroundStationary[] gs = GamePlay.gpGroundStationarys(mo.Pos.x, mo.Pos.y, mo.TriggerDestroyRadius);
                        if (gs != null) numTargets = gs.Length;
                        //int targetsRequired = Convert.ToInt32((Math.Floor(numTargets * 0.7))); // require 70% of the groundstationaries in the target area.  This should be fairly hard.
                        int targetsRequired = 2;
                        if (numTargets < targetsRequired) targetsRequired = Convert.ToInt32(numTargets);

                        //NOTE!!!! Ignoring the given ortgg for now & just using 80% of the existing targets in the area.

                        mo.ObjectsRequiredToTrigger_num = targetsRequired;

                        Console.WriteLine("UPDATED BLUE RADAR {0} new radar angle {1} x,y: {2},{3} numTargets in radius {4}, num required: {5})", mo.Name, angle, x, y, numTargets, targetsRequired);

                    });


                }
                if (mo.AutoFlak || (mo.AutoFlakIfPrimary && mo.IsPrimaryTarget)) MO_AutoFlakPlacement(mo);
            }
        }
    }

    //This needs to be run after each mission restart, after the missionobjectiveslist has been reloaded from disk
    //It accounts for the fact that MissionObjectivesList was saved to disk and now reloaded, but in the meanwhile we might have changed (for example) class MissionObjective
    //to include some new values.  They will all be set to FALSE or 0 or whatever if we just continue with the saved version.
    //On the other hand, we can't just reload the new version because we will lose current state of targets destroyed, targets for which
    //points have been awards, scouted objectives, etc. 
    //So we make a brand-new MissionObjectivesList but then we copy over any values that should persist.
    //Also adds any NEW objectives added in the .cs and removes any that were deleted
    public void updateMissionObjectivesListOnReload(MissionObjectives m_os)
    {
        Dictionary<string, MissionObjective> MissionObjectivesList_OLD = new Dictionary<string, MissionObjective>(MissionObjectivesList);
        MissionObjectivesList = new Dictionary<string, MissionObjective>();  //zero out the mission objectives list (otherwise when we run the routine below they will ADD to anything already there)
        //Console.WriteLine("#1" + (mission_objectives == null).ToString());
        //m_os.RadarPositionTriggersSetup();
        //Console.WriteLine("#2");
        //m_os.MissionObjectiveTriggersSetup();
        //Console.WriteLine("#3");
        //New way with TOBRUK campaign objectives system

        try
        {
            twc_tobruk_campaign_mission_objectives.BumRushCampaignValuesSetup();
            twc_tobruk_campaign_mission_objectives.RadarPositionTriggersSetup(addNewOnly: false);
            //RadarPositionTriggersSetup();
            twc_tobruk_campaign_mission_objectives.MissionObjectiveTriggersSetup(addNewOnly: false);
            Console.WriteLine("TTCMO loaded bumrush, radar, objective dictionaries (2)");
        }
        catch (Exception ex)
        {
            Console.WriteLine("twc_tobruk_campaign_mission_objectives SETUP MAJOR ERROR: " + ex.ToString());
        }

        MO_MissionObjectiveAirfieldsSetup(this, GamePlay, addNewOnly: false); //must do this after the Radar & Triggers setup, as it uses info from those objectives
                                                                              //Also, confusing, we must run this TWICE: Once before the routine below to UPDATE the MOs, because otherwise there is nothing to update.
                                                                              //But a 2nd time, after the update, because that is what transfers airport destroyed etc info from the MOList to the airport list.
                                                                              //Arrgh.
                                                                              //AND... Bumrush airport updates must be run AFTER the first time and BEFORE the second time...
                                                                              //Console.WriteLine("#4");



        //UPDATE newly constructed MOList with the vital data needed from the OLD_MOList
        //This allows us to keep the needed data from session to session, the "current/changeable" data - but ALSO to update the basic data for every trigger simply by changing it in this .cs file.
        //It would be interesting to have some way to mark or formalize which of these items are re-loaded from the disk save file & which refreshed from the .cs on each restart.
        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjectivesList[ID].IsPrimaryTarget = false;  //we reset this every time we load from disk, because later we'll read the primary objectives file & set this = true if it is a primary objective based on that.  We want the objectives .ini file, not this saved dictionary, to be the ultimate source of what is/is not a primary objective.  That way we can edit/change the .ini file as needed and it will affect the game later whenever it restarts.
            //Console.WriteLine("#5");
            if (!MissionObjectivesList_OLD.ContainsKey(ID)) continue;
            MissionObjective mo = MissionObjectivesList[ID];
            MissionObjective mo_old = MissionObjectivesList_OLD[ID];
            if (mo_old.Destroyed) Console.WriteLine("Destroyed: {0}", mo.Name);
            Console.WriteLine("{0} {1} {2} ", ID, mo.Name, mo.Scouted);
            //Console.WriteLine("{0} {1} ", mo.Name, mo.TimeToUndestroy_UTC.Value);
            // if (mo_old.TimeToUndestroy_UTC.HasValue) Console.WriteLine("Destroyed: {0} {1:HHmm} ", mo.Name, mo_old.TimeToUndestroy_UTC.Value);
            //if (mo_old.LastHitTime_UTC.HasValue) Console.WriteLine("Destroyed: {0} {1:HHmm}", mo.Name, mo_old.LastHitTime_UTC.Value);

            mo.Destroyed = mo_old.Destroyed;
            mo.DestroyedPercent = mo_old.DestroyedPercent;
            mo.ObjectiveAchievedForPoints = mo_old.ObjectiveAchievedForPoints;
            mo.TimeToUndestroy_UTC = mo_old.TimeToUndestroy_UTC;
            mo.LastHitTime_UTC = mo_old.LastHitTime_UTC;
            mo.AirfieldDamagePoints = mo_old.AirfieldDamagePoints;

            //If the item is damaged at all & for some reason the lasthittime isn't set, we just set it to something somewhat reasonable.  Otherwise it shows as 0, not good.
            if ((mo.DestroyedPercent > 0 || mo.Destroyed || mo.ObjectsDestroyed_num > 0 || mo.OrdnanceOnTarget_kg >0 || mo.AirfieldDamagePoints > 0)
                  && !mo.LastHitTime_UTC.HasValue)
                mo.LastHitTime_UTC = DateTime.UtcNow.AddHours(-random.Next(1,5));

            //So converting these next values over from an old ver. of the save files that didn't have these values is problematic. 
            //ifs below should fix that.
            if (mo.PlayersWhoContributedNames != null) mo.PlayersWhoContributedNames = mo_old.PlayersWhoContributedNames;

            if (mo.BirthplaceACTypes != null) mo.BirthplaceACTypes = mo_old.BirthplaceACTypes;

            //This is mostly for a transition from old files to new ones that had these new variables.  They were all just appearing as blank, and it didn't look good.
            mo.Scouted = mo_old.Scouted;
            if (mo.Scouted && !Calcs.Point3dEqual(mo_old.lastScoutedPos, new Point3d(0, 0, 0))) mo.lastScoutedPos = mo_old.lastScoutedPos;
            if (mo.Scouted && mo_old.lastScoutedSector != null && mo_old.lastScoutedSector != "") mo.lastScoutedSector = mo_old.lastScoutedSector;

            if (mo.Scouted && mo_old.PlayersWhoScoutedNames != null) mo.PlayersWhoScoutedNames = mo_old.PlayersWhoScoutedNames;
            if (mo.Scouted && mo_old.numTimesScouted > 0) mo.numTimesScouted = mo_old.numTimesScouted;
            if (mo.Scouted && mo_old.lastTimeScouted_dt.HasValue) mo.lastTimeScouted_dt = mo_old.lastTimeScouted_dt;

            if (mo.MOMobileObjectiveType != null && mo.MOMobileObjectiveType != MO_MobileObjectiveType.None)
            {
                double z = Calcs.LandElevation_m(mo_old.Pos); //saving altitude/elevation of the objective. //saving altitude/elevation of the objective.
                if (mo.AttackingArmy == 1) z = Calcs.meters2feet(z); //(in feet for Red army)
                mo.Pos = new Point3d(mo_old.Pos.x, mo_old.Pos.y, z) ; //Only transfer pos across IF the item is a mobile objective.  For all other objectives, that allows us to change the location by just updating the objectives list in this .cs files
                mo.Sector = mo_old.Sector;
                mo.bigSector = mo_old.bigSector;
            }

            //EXPERIMENT to update elevation fo all objs. 2020/09/10
            //So this is perhaps a good thing to do in case map elevation changes or ???
            double zz = Calcs.LandElevation_m(mo.Pos); 
            if (mo.AttackingArmy == 1) zz = Calcs.meters2feet(zz); //(in feet for Red army)
            mo.Pos = new Point3d(mo.Pos.x, mo.Pos.y, zz); 

            mo.OrdnanceOnTarget_kg = mo_old.OrdnanceOnTarget_kg;
            mo.ObjectsDestroyed_num = mo_old.ObjectsDestroyed_num;

            mo.MobileNextMoveTime_dt = mo_old.MobileNextMoveTime_dt;


        }
        MO_MissionObjectiveAirfieldsSetup(this, GamePlay, addNewOnly: true); //must do this both BEFORE and AFTER the UPDATE ^^^^ setup, as now the AirportList info needs to be updated to reflect destroyed, damaged, etc.
                                                                                //First time addNewOnly: FALSE to get ALL airports, 2nd time TRUE to get only the NEW airports                                                                     
                                                                                //Also after restoring damaged & destroy info (^^^^) because it will damage/destroy airports based on that info.

        //BUMRUSH!!!!! Here is where we set the level of the Bumrush airport.
        //Set up focus airfields for Bumrush mission
        //So this generally tweaks ONLY objective points, which is a primary objective, which has a higher priority for primary objective selection etc.  But it COULD
        //tweak almost anything related to the MissionObjective, so we should just do it last so as to not disturb whatever the mission designer is doing there.
        try
        {
            twc_tobruk_campaign_mission_objectives.MissionObjectiveAirfieldFocusBumrushSetup();
        }
        catch (Exception ex)
        {
            Console.WriteLine();
            Console.WriteLine("*****************************************twc_tobruk_campaign_mission_objectives.MissionObjectiveAirfieldFocusBumrushSetup MAJOR ERROR!!!!!!!!!!!: " + ex.ToString());
            Console.WriteLine();
        }

        //We are restoring, succesfully, from saved state here, so we must also restore the BumrushState & put ourselves in the correct phase.
        MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus = MO_BRBumrushInfoRestored[ArmiesE.Blue].BumrushStatus;
        MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus = MO_BRBumrushInfoRestored[ArmiesE.Red].BumrushStatus;
        if (MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus > 0)
        {
            Console.WriteLine("Restoring Bumrush current status for BLUE: " + MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus.ToString());
            MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus--; //BumrushStatus is the status @ end of last mission.  StartBumrushPhase will ++ this variable, so we'll end up the same place we were @ end of last mission.
            MO_BRStartBumrushPhase((int)ArmiesE.Blue); 
        } else if (MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus > 0)
        {
            Console.WriteLine("Restoring Bumrush current status for RED: " + MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus.ToString());
            MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus--; //BumrushStatus is the status @ end of last mission.  StartBumrushPhase will ++ this variable, so we'll end up the same place we were @ end of last mission.
            MO_BRStartBumrushPhase((int)ArmiesE.Red);
        }

    }



    public List<string> MO_ListAllPrimaryObjectives(int army)
    {
        var list = new List<string>() { };

        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {
            MissionObjective mo = entry.Value;
            if (mo.AttackingArmy == army && mo.IsPrimaryTarget && mo.IsEnabled)
            {
                list.Add(mo.ID);
                //Console.WriteLine("MLAPO " + mo.ID);
            }
        }
        return list;
    }


    public int MO_NumberPrimaryObjectivesComplete(int army)
    {

        int numComplete = 0;


        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {

            MissionObjective mo = entry.Value;
            if (mo.ObjectiveAchievedForPoints && mo.AttackingArmy == army && mo.IsPrimaryTarget && mo.IsEnabled)
            {

                numComplete++;

            }
        }
        return numComplete;
    }

    int[] MO_numberprimaryobjectives = new int[3] { 0, 0, 0 };

    public int MO_NumberPrimaryObjectives(int army)
    {

        if (MO_numberprimaryobjectives[army] > 0) return MO_numberprimaryobjectives[army]; //Once we have figured this out, >0, it won't change

        int num = 0;

        foreach (KeyValuePair<string, MissionObjective> entry in MissionObjectivesList)
        {

            MissionObjective mo = entry.Value;
            if (mo.AttackingArmy == army && mo.IsPrimaryTarget && mo.IsEnabled)
            {

                num++;

            }
        }
        MO_numberprimaryobjectives[army] = num;
        return num;
    }

    public double MO_PercentPrimaryObjectives(int army)
    {
        int npo = MO_NumberPrimaryObjectives(army);
        if (npo == 0) return 0;
        double x = MO_NumberPrimaryObjectivesComplete(army);
        return (x / (double)npo * (double)100.0);
    }
    public double MO_PrimaryObjectivesRemaining(int army)
    {
        int npo = MO_NumberPrimaryObjectives(army);
        double x = MO_NumberPrimaryObjectivesComplete(army);
        return (npo - x);
    }

    public string MO_PlayersWhoScoutedObjectivesList(string winner)
    {
        string output = "";
        //Console.WriteLine("Checking scouts for " + winner);
        int army = 0;
        if (winner == "Red") army = 1;
        if (winner == "Blue") army = 2;
        if (army == 0) return output;

        var contribs = new HashSet<string>();

        foreach (MissionObjective mo in MissionObjectivesList.Values)
        {
            //Console.WriteLine("Checking scouts for " + mo.Name);
            if (mo.AttackingArmy != army) continue;
            if (!mo.ObjectiveAchievedForPoints) continue;
            if (mo.PlayersWhoScoutedNames == null) continue;

            var sortedList = mo.PlayersWhoScoutedNames.ToList();
            sortedList.Sort((pair1, pair2) => pair1.Value.CompareTo(pair2.Value)); //This puts the Dict into a list & then sorts it by value, which is the order scouted. So we'll list first scouter first, second scouter 2nd, etc.  Probably could have been a List<string,int> in the first place or whatever.
            //Console.WriteLine("Listing scouts for " + mo.Name);
            output += " - " + mo.Name + ": ";
            int count = 0;
            //foreach (string name in mo.PlayersWhoScoutedNames.Keys)
            foreach (KeyValuePair<string, int> entry in sortedList)
            {
                string name = entry.Key;
                if (count != 0) output += ", ";
                output += name;
                //if (mo.PlayersWhoScoutedNames[name] > 1) output += " (" + mo.PlayersWhoScoutedNames[name].ToString("F0") + ")";
                //Aha, actually the mo.PlayersWhoScoutedNames[name] is the ORDER in which people scouted, ie 0 = t he first, 1 = the second, 2 = the third, etc.  So that we can award points based on that.
                count++;
                contribs.Add(name);
                Console.WriteLine("Listing scouts, adding " + name);
            }

            output += "<br>" + Environment.NewLine;
        }

        if (contribs.Count > 0) output += "<br>" + Environment.NewLine + (contribs.Count).ToString("F0") + " players contributed to scouting objectives that contributed to this victory.<br>" + Environment.NewLine;

        return output;

    }


    public string MO_PlayersWhoContributedToObjectivesList(string winner)
    {
        string output = "";

        int army = 0;
        if (winner == "Red") army = 1;
        if (winner == "Blue") army = 2;
        if (army == 0) return output;

        var contribs = new HashSet<string>();

        foreach (MissionObjective mo in MissionObjectivesList.Values)
        {
            if (mo.AttackingArmy != army) continue;
            if (!mo.Destroyed) continue;
            if (mo.PlayersWhoContributedNames == null || mo.PlayersWhoContributedNames.Count == 0) continue;

            output += " - " + mo.Name + ": ";
            int count = 0;
            foreach (string name in mo.PlayersWhoContributedNames)
            {
                if (count != 0) output += ", ";
                output += name;
                count++;
                contribs.Add(name);
            }

            output += "<br>" + Environment.NewLine;
        }

        if (contribs.Count > 0) output += "<br>" + Environment.NewLine + (contribs.Count).ToString("F0") + " players contributed to destroying objectives that contributed to this victory.<br>" + Environment.NewLine;
        return output;
    }

    //Autosends generic scores needed by all objective types.
    //Send the score as 1/kill - this figures if they need to be multiplied by 100 or not
    public void MO_AddStatPoints(Player player, double score, List<int> ids) {
        ids.Add(798); //This is a value /100 like the others in ids

        int scoreX100_int = Convert.ToInt32(Math.Round(score * 100.0));
        int score_int = Convert.ToInt32(Math.Round(score));


        foreach (int id in ids)
        {
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddSessStat(player, id, scoreX100_int);
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, id, scoreX100_int);
        }

        ids = new List<int> { 647, 648, 649, 794, 799 }; //These are all values NOT /100 - just done straight

        foreach (int id in ids)
        {
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddSessStat(player, id, score_int);
            if (TWCSaveIPlayerStat != null) TWCSaveIPlayerStat.StbSis_AddToMissionStat(player, id, score_int);
        }

        //return (Value[647] + Value[648] + Value[649] + Value[794]); - kill/any participation for aircraft / aa=artillery-tank / ships=naval / ground
        //NOT multiplied by 100

        //798 = total kill PERCENTAGE /100
        // 799 = num of total victories, NOT /100
    }

    public void MO_AddPlayerStatsScoresForObjectiveDestruction(Player player, string name, MissionObjective mo, double score)
    {
        //798-799 all types combined (total) -806/807 AA/Artillery/Tanks, 810/811 Naval/ship, 814/815 Other 
        //ground recon photos taken, 849 # of objectives photographed

        if (player == null) player = Calcs.PlayerFromName(this, name);

        //If the player isn't online we substitute in its place the 'stub' Player p1.  It only has the name & army of the player, but that is all that is needed by stats (thanks to 
        //clever hacking/tweaking of the stats routines).
        if (player == null)
        {
            aPlayer p1 = new aPlayer(name, mo.AttackingArmy);
            player = p1 as Player;
        }

        if (mo.MOObjectiveType == MO_ObjectiveType.AA
            )
        {

            List<int> scoreIDs = new List<int> { 806, 807 };
            MO_AddStatPoints(player, score, scoreIDs);

        }
        else if (mo.MOObjectiveType == MO_ObjectiveType.Ship
                )
        {

            List<int> scoreIDs = new List<int> { 810, 811 };
            MO_AddStatPoints(player, score, scoreIDs);

        }
        else
        /* covers these & a bunch more - all just classed as ground targets:
         *  (mo.MOObjectiveType == MO_ObjectiveType.Aircraft ||
             mo.MOObjectiveType == MO_ObjectiveType.ArmyBase ||
             mo.MOObjectiveType == MO_ObjectiveType.Dam ||
             mo.MOObjectiveType == MO_ObjectiveType.Dock
             //We're counting aircraft killed on the ground as ground targets, because they're not flying at the time

             )
             */
        {

            List<int> scoreIDs = new List<int> { 814, 815 };
            MO_AddStatPoints(player, score, scoreIDs);

        }

    }

    public void MO_AddAllPlayersStatAndContributedScoredForObjectiveDamageDestruction(MissionObjective OldObj, double score)
    {
        Task.Run(() =>
        {
            try
            {

                if (GamePlay.gpRemotePlayers() != null) foreach (Player player in GamePlay.gpRemotePlayers())
                    {
                        if (player == null || player.Place() == null) continue;

                        if (OldObj.AttackingArmy == player.Army() &&
                        player.Place() != null &&
                        Calcs.CalculatePointDistance(player.Place().Pos(), OldObj.Pos) < 10000)
                        {
                            MO_AddPlayerStatsScoresForObjectiveDestruction(player, player.Name(), OldObj, score);
                            OldObj.PlayersWhoContributedNames.Add(player.Name());
                        }
                    }

            }
            catch (Exception ex) { Console.WriteLine("MO_AddAllPlayersCredit ERROR: " + ex.Message); };

            try
            {
                //**add player stat points for any players who scouted/recon photo for this objective
                //It is max for first player to recon, then reduced by 50% for each succeeding player who also reconned it
                if (OldObj.PlayersWhoScoutedNames != null) foreach (string playerName in OldObj.PlayersWhoScoutedNames.Keys)
                    {
                        MO_AddPlayerStatsScoresForObjectiveDestruction(null, playerName, OldObj, score / (2 ^ OldObj.PlayersWhoScoutedNames[playerName]));
                        OldObj.PlayersWhoContributedNames.Add(playerName);  //they get a piece of the credit for object destruction
                    }

            }
            catch (Exception ex) { Console.WriteLine("MO_AddAllPlayersCredit ERROR2: " + ex.Message); };
        });
    }

    //Destroys the objective with the given ID and takes other related actions, such as 
    //adding points, displaying messages, reducing radar coverage
    public bool MO_DestroyObjective(string ID, bool active = true, double percentdestroyed = 0, double timetofixFromNow_sec = 0, DateTime? TimetoUndestroy_UTC = null, double AirfieldDamagePoints = 0, double AirfieldDamagePointsAdded = 0, double messageDelay_sec = 0)
    {
        try
        {
            Console.WriteLine(" MO_DestroyObjective1: {0} {1} {2} {3} {4}", ID, active, percentdestroyed, timetofixFromNow_sec, TimetoUndestroy_UTC);
            if (!active) return false;  //If a trigger is passed with flag active=false that (generally) means the trigger has already been activated once before & we don't want to repeat it again
                                        //this is passed when coming from onTrigger, otherwise it should just be TRUE by default

            
            var OldObj = new MissionObjective(this);

            if (!MissionObjectivesList.TryGetValue(ID, out OldObj))
            {
                return false;
                //OldObj = new MissionObjective(msn);
            }

            DateTime currTime_dt = DateTime.UtcNow;
            double repairSpeedupFactor = 1;
            if (MissionObjectivesTimes[(ArmiesE)OldObj.OwnerArmy].ContainsKey("RepairCrewEndTime_dt") && MissionObjectivesTimes[(ArmiesE)OldObj.OwnerArmy]["RepairCrewEndTime_dt"] > currTime_dt) repairSpeedupFactor = 4;


            //Turn off the trigger so it won't trigger again - IF this objective type is a trigger
            if (OldObj.MOTriggerType == MO_TriggerType.Trigger && GamePlay.gpGetTrigger(ID) != null)
            {
                Console.WriteLine("MO_DestroyObjective: Disabling trigger " + ID);
                GamePlay.gpGetTrigger(ID).Enable = false;
            }

            if (OldObj.IsEnabled) {
                if (percentdestroyed > 0) OldObj.DestroyedPercent = percentdestroyed;
                if (AirfieldDamagePoints > 0) OldObj.AirfieldDamagePoints = AirfieldDamagePoints;

                //Soo . . if we have a damage time to add, we EITHER add it to the current time, if there is no time to undestroy OR it is in the past
                //OR we add it to the current time to undestroy, extending the destruction time by that much (but at at discounted rate, since this is adding destruction to something already destroyed)
                //Note that this is overridden below in the case that th e object just became destroyed (in that case we use the default timetoundestroy for that objective)
                if (timetofixFromNow_sec > 0)
                {
                    if (!OldObj.TimeToUndestroy_UTC.HasValue || OldObj.TimeToUndestroy_UTC.Value.CompareTo(DateTime.UtcNow) < 0) {
                        OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timetofixFromNow_sec);
                    } else
                    {
                        OldObj.TimeToUndestroy_UTC = OldObj.TimeToUndestroy_UTC.Value.AddSeconds(timetofixFromNow_sec / 2);
                    }
                }

                if (TimetoUndestroy_UTC.HasValue) OldObj.TimeToUndestroy_UTC = TimetoUndestroy_UTC.Value; //OR, if the timetoundestroy is specified for us (could happen via an airport, for example), we just take that.  Usually it is NOT specified though.

                OldObj.LastHitTime_UTC = DateTime.UtcNow;
            }

            if (!OldObj.IsEnabled) return false; //This is disabled

            bool alreadyCounted = false;
            bool alreadyDestroyed = false;
            bool percentSpecified = (percentdestroyed > 0); //airports etc specify a specific percentage destroyed.  Everything else, we assume is 100%.

            Console.WriteLine(" MO_DestroyObjective1: {0} {1} {2} {3}", ID, alreadyCounted, alreadyDestroyed, percentSpecified);

            if (OldObj.ObjectiveAchievedForPoints) alreadyCounted = true; //The object has already been destroyed; don't need to do it again; we only give points/credit for destroying any given objective once
            if (OldObj.Destroyed) alreadyDestroyed = true; //The object has already been destroyed; don't need to do it again; we only give full points/credit for destroying any given objective once between times when the map is turned.  But we do give some lower point values for re-damaging it if it reaches certain levels.


            OldObj.Destroyed = true;
            OldObj.ObjectiveAchievedForPoints = true;

            //So what can happen is, the objective was destroyed (and is still destroyed) after a previous mission, and/or it was destroyed and points received before.
            //But on new mission it looks like it's been rebuilt and the trigger is active again.  So you can bomb it again.
            //So bombing and objective again while its under repair still damages it, but we'll say it doesn't add the full repair time again, but say 1/4th.

            //RADAR
            if (OldObj.MOObjectiveType == MO_ObjectiveType.Radar)
            {
                if (OldObj.OwnerArmy == 1) DestroyedRadar[(ArmiesE.Red)].Add(OldObj);
                if (OldObj.OwnerArmy == 2) DestroyedRadar[(ArmiesE.Blue)].Add(OldObj);
                if (!alreadyDestroyed)
                {
                    OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(OldObj.TimetoRepairIfDestroyed_hr / repairSpeedupFactor);
                    if (percentSpecified) OldObj.DestroyedPercent = percentdestroyed; //Hopefully this is 100% but we leave it to the calling subroutine
                    else OldObj.DestroyedPercent = 1;
                }
                else
                {
                    if (percentSpecified) OldObj.DestroyedPercent += percentdestroyed / 4; //we'll assume calling routine doesn't now it has already been destroyed so we should reduce accordingly
                    else OldObj.DestroyedPercent += 0.25; //we'll say re-destroying it adds 25% more damage & 1/4 as much more time to repair
                    //OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(OldObj.TimetoRepairIfDestroyed_hr / 4.0); //handling this above now
                }
            } else
            //EVERYTHING ELSE (except airports, which are handled via MO_DestroyObjective_addpercentage, and radar, handled above
            {
                if (!alreadyDestroyed)
                {
                    OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(OldObj.TimetoRepairIfDestroyed_hr/repairSpeedupFactor);
                    if (percentSpecified) OldObj.DestroyedPercent = percentdestroyed; //Hopefully this is 100% but we leave it to the calling subroutine
                    else OldObj.DestroyedPercent = 1;
                    Console.WriteLine(" MO_DestroyObjective1: not already destroyed");
                }
                else
                {
                    if (percentSpecified) OldObj.DestroyedPercent += percentdestroyed / 2; //we'll assume calling routine doesn't now it has already been destroyed so we should reduce accordingly
                    else OldObj.DestroyedPercent += 0.5; //we'll say re-destroying it adds 50% more damage & 50% as much more time to repair
                    //OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(OldObj.TimetoRepairIfDestroyed_hr / 4.0); //handling this above now.
                    Console.WriteLine(" MO_DestroyObjective1: already destroyed");
                }

            }

            //ADD TEAM POINTS
            if (!alreadyCounted)
            {
                Console.WriteLine(" MO_DestroyObjective1: not already counted");
                if (OldObj.AttackingArmy == 1)
                {
                    MissionObjectivesCompletedString[ArmiesE.Red] += " - " + OldObj.Name;

                    Console.WriteLine("MO_DestroyObjective: Name " + OldObj.Name);
                    Console.WriteLine("MO_DestroyObjective: String " + MissionObjectivesCompletedString[ArmiesE.Red]);
                    MissionObjectiveScore[ArmiesE.Red] += OldObj.Points;
                }
                if (OldObj.AttackingArmy == 2)
                {
                    MissionObjectivesCompletedString[ArmiesE.Blue] += " - " + OldObj.Name;
                    Console.WriteLine("MO_DestroyObjective: Name " + OldObj.Name);
                    Console.WriteLine("MO_DestroyObjective: String " + MissionObjectivesCompletedString[ArmiesE.Blue]);

                    MissionObjectiveScore[ArmiesE.Blue] += OldObj.Points;
                }
            }
            else //Maybe due to error or ? the list of completed objectives doesn't include this; we'll just double check & add if necessary.
                 //It's confusing if you bomb & hit something and it doesn't show up on the list.

            {
                Console.WriteLine(" MO_DestroyObjective1: already counted");

                if (OldObj.AttackingArmy == 1)
                {
                    if (!MissionObjectivesCompletedString[ArmiesE.Red].Contains(OldObj.Name))
                    {
                        MissionObjectivesCompletedString[ArmiesE.Red] += " - " + OldObj.Name;
                    }

                }
                if (OldObj.AttackingArmy == 2)
                {
                    if (!MissionObjectivesCompletedString[ArmiesE.Blue].Contains(OldObj.Name))
                    {
                        MissionObjectivesCompletedString[ArmiesE.Blue] += " - " + OldObj.Name;
                    }

                }

                //ALREADY DESTROYED/COUNTED BUT WE CAN ADD PARTIAL POINTS IN MANY SITUATIONS
                //This has already been counted for map turning/primary target purposes but  has become undestroyed in the meanwhile
                //so it counts just as much as any other secondary target at this point:
                if (!alreadyDestroyed)
                {
                    Console.WriteLine(" MO_DestroyObjective1: already counted, not already destroyed (ie, probably destroyed earlier but now repaired");
                    //Full points for this; it's been repaired again.  But it doesn't count as a primary objective again.
                    double percCount = OldObj.DestroyedPercent;
                    if (percCount > 1) percCount = 1; //Increase it by max equivalent to 100% additional destruction
                    if (percentSpecified)
                        MissionObjectiveScore[(ArmiesE)OldObj.AttackingArmy] += OldObj.Points * percCount; //scaled by the percentage killed 
                    else
                        MissionObjectiveScore[(ArmiesE)OldObj.AttackingArmy] += OldObj.Points;
                }
                else
                {
                    Console.WriteLine(" MO_DestroyObjective1: already counted, already destroyed");
                    //Here they are re-damaging it for the first time this session, which gets them a little extra points and extends the repair time some, but neither as much as if fully repaired
                    double pointsToAdd = 0;
                    double percCount = percentdestroyed;
                    if (percCount > 1) percCount = 1; //Increase it by max equivalent to 100% additional destruction
                    if (percentSpecified) pointsToAdd = OldObj.Points * percCount / 4.0; //scaled by the percentage killed 
                    else pointsToAdd = OldObj.Points / 4.0;
                    if (pointsToAdd < 0.3) pointsToAdd = 0.3; //always give at least a little bit
                    MissionObjectiveScore[(ArmiesE)OldObj.AttackingArmy] += pointsToAdd;
                }
            }

            string pom = "";
            if (OldObj.IsPrimaryTarget && !alreadyCounted) pom = "Primary objective! ";

            string mes = ArmiesL[OldObj.AttackingArmy] + " destroyed " + OldObj.Name;
            if (OldObj.HUDMessage != null && OldObj.HUDMessage.Length > 0) mes = OldObj.HUDMessage;

            if (( alreadyCounted || alreadyDestroyed) && OldObj.MOTriggerType != MO_TriggerType.TemporaryLandingGround) mes = ArmiesL[OldObj.AttackingArmy] + " damaged " + OldObj.Name;

            Timeout(messageDelay_sec, () =>
            {
                GamePlay.gpHUDLogCenter(mes);
            });

            string mes1 = "";
            if (OldObj.LOGMessage != null && OldObj.LOGMessage.Length > 0) mes1 = OldObj.LOGMessage;
            if ((alreadyCounted || alreadyDestroyed) && OldObj.MOTriggerType != MO_TriggerType.TemporaryLandingGround) mes1 = ArmiesL[OldObj.AttackingArmy] + " has further damaged " + OldObj.Name;

            Timeout(messageDelay_sec, () =>
            {
                twcLogServer(null, mes1, new object[] { });
                twcLogServer(null, pom + "All involved have received commendations and promotions.", new object[] { });
                
            });

            MissionObjectivesList[ID] = OldObj; //So this line WAS just above ^^^ in the Timeout.  Not sure if there was a reason for that?  Maybe we want the actual MO destruction save to be delayed but just a little bit??? But for TempLGs it was preventing their planeset from being saved properly.  So, changing it.

            //now update related player scores

            //**add player points for any players on the side that destroyed this objective, who are within 10km of this spot
            List<String> mos = new List<String>();
            try
            {
                mos = MO_ListSuggestedObjectives(null, OldObj.AttackingArmy, display: false); //Get the current list of MissionObjectivesSuggested[(ArmiesE)OldObj.AttackingArmy];
            }
            catch (Exception ex) { Console.WriteLine("MO_Destroy error 3.5 - listsuggestedobjectives: " + ex.Message); };

            double score = 5;        //Remember that stats kill scores are /100.  But the routines above will do that calculation; we just need the kill points here.
            if (alreadyDestroyed) score = score / 2;
            if (mos.Contains(ID) && !alreadyCounted) score *= 2; //secondary objective
            if (OldObj.IsPrimaryTarget && !alreadyCounted) score *= 3;

            MO_AddAllPlayersStatAndContributedScoredForObjectiveDamageDestruction(OldObj, score);

            MO_CheckObjectivesComplete();

            return true;
        }
        catch (Exception ex) { Console.WriteLine("MO_Destroy error4: " + ex.Message); return true; };
    }

    //Adds additional destruction/percent/time out of commission to objects that are already destroyed
    //string ID, bool active = true, double percentdestroyed = 0, double timetofix_s = 0 , DateTime? TimetoUndestroy_UTC = null
    //Only used by airfields for now, when they are bombed additionally beyond 100%
    public bool MO_DestroyObjective_addTime(string ID, double percentdestroyed = 0, double timetofixFromNow_sec = 0, DateTime? TimetoUndestroy_UTC = null,
        DateTime? TimeLastHit_UTC = null, double AirfieldDamagePoints = 0, double AirfieldDamagePointsAdded = 0, double messageDelay_sec = 0)
    {
        try
        {

            var OldObj = new MissionObjective(this);

            if (!MissionObjectivesList.TryGetValue(ID, out OldObj))
            {
                return false;
                //OldObj = new MissionObjective(msn);
            }

            //Add the extra time/destruction percent and/or update the time when the object will be undestroyed
            if (OldObj.IsEnabled)
            {
                //If we hit 200% destroyed it can count as a mission objective destroyed, again, for points.
                if (!OldObj.ObjectiveAchievedForPoints && percentdestroyed >= 2.0)
                {
                    MO_DestroyObjective(ID, true, percentdestroyed, timetofixFromNow_sec, TimetoUndestroy_UTC);
                    return true;
                }
                if (!OldObj.ObjectiveAchievedForPoints && AirfieldDamagePointsAdded > 0) //if it is an airfield & we have passed another 100% - 200% - 300%-etc type threshold & it is not counted as an objective for scoring, we can count it
                {
                    int roundnd = Convert.ToInt32(Math.Floor(AirfieldDamagePoints));
                    int roundod = Convert.ToInt32(Math.Floor(AirfieldDamagePoints - AirfieldDamagePointsAdded));
                    if (roundnd > roundod) MO_DestroyObjective(ID, true, percentdestroyed, timetofixFromNow_sec, TimetoUndestroy_UTC, AirfieldDamagePoints: AirfieldDamagePoints, messageDelay_sec: messageDelay_sec);
                    return true;
                }
                if (percentdestroyed > 0) OldObj.DestroyedPercent = percentdestroyed;
                if (timetofixFromNow_sec > 0) OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timetofixFromNow_sec);
                if (TimetoUndestroy_UTC.HasValue) OldObj.TimeToUndestroy_UTC = TimetoUndestroy_UTC.Value;

                if (TimeLastHit_UTC.HasValue) OldObj.LastHitTime_UTC = TimeLastHit_UTC.Value;
                else OldObj.LastHitTime_UTC = DateTime.UtcNow;

                if (AirfieldDamagePoints > 0) OldObj.AirfieldDamagePoints = AirfieldDamagePoints;

            }

            return true;

        }
        catch (Exception ex) { Console.WriteLine("MO_Destroy_addTime ERROR: " + ex.Message); return true; }
    }

    public void restoreAirfield(MissionObjective mo, int percentToRestore = 100)
    {
        if (mo != null) restoreAirfield(mo.ID, mo.Name, mo.OwnerArmy, mo.Pos, mo.radius, mo, percentToRestore);
    }

    public void restoreAirfield(string ID, string Name, int OwnerArmy, Point3d Pos, double radius = 3000, MissionObjective mo = null, int percentToRestore = 100)
    {
        Task.Run(() =>
        {
            if (percentToRestore >= 100)
            {
                //If it doesn't have a spawnpoint, we give it one.  Even if it didn't have one before.  This . . . could cause some problems.  We'll see.
                double dist_m = Calcs.distanceToNearestBirthplace(GamePlay, mo.Pos, mo.OwnerArmy);
                Console.WriteLine("RestoreAirfield: Checking distance from {0}: {1} ({2:F0},{3:F0})", mo.Name, dist_m, mo.Pos.x, mo.Pos.y);
                if (dist_m > 5000)
                {
                    ISectionFile f2 = GamePlay.gpCreateSectionFile();
                    int maxLen = 14;
                    if (ID.Length < 14) maxLen = ID.Length;
                    string bname = ID.Substring(0, maxLen) + " (temp) " + random.Next(10, 99).ToString("F0");
                    f2 = Calcs.CreateBirthPlace(f2, bname, Pos.x, Pos.y, 0, OwnerArmy);
                    GamePlay.gpPostMissionLoad(f2);
                    f2.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/" + bname);
                }
                MO_MissionObjectiveAirfieldsArmyReset(this, GamePlay, OwnerArmy, apID: ID);
            }
            removeSmokeFireCraters(Pos, radius, percentToRestore);
            Console.WriteLine("Removing craters from: " + Name);
        });

    }

    public void restoreRadar(MissionObjective mo)

    {
        //restoreRadar(mo.ID, mo.Name, mo.OwnerArmy, mo.Pos);
        if (DestroyedRadar[(ArmiesE)mo.OwnerArmy].Contains(mo)) DestroyedRadar[(ArmiesE)mo.OwnerArmy].Remove(mo);
    }
    
    /*  AACk this doesn't work
    public void restoreRadar(string ID, string Name, int OwnerArmy, Point3d Pos)
    {
        //if (OwnerArmy < 1 || OwnerArmy > 2) return;//can't do anything . . . 

        //if (DestroyedRadar[(ArmiesE)OwnerArmy].Contains(mo)) DestroyedRadar[(ArmiesE)OwnerArmy].Remove(mo);
    }
    */

    private bool MO_ObjectiveUndestroy_recurs_firstrun = true;

    //Undestroys & also checks up on any mobile objective moves needed.
    public void MO_ObjectiveUndestroy_recurs()
    {
        Timeout(316.3, () => { MO_ObjectiveUndestroy_recurs(); });
        Task.Run( ()=> {
            Timeout(94.2341, () => { MO_DisplayGeneralStaffIntelligenceLeaks();  });
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MMOXX1 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
            DateTime currTime_UTC = DateTime.UtcNow;
            List<string> molk = new List<string>(MissionObjectivesList.Keys.ToList());
            foreach (string ID in molk)
            {

                MissionObjective mo = MissionObjectivesList[ID];
                MO_HandleMobileObjectivePlacement(mo, startup: false);
                if ((mo.Destroyed && mo.TimeToUndestroy_UTC.HasValue && mo.TimeToUndestroy_UTC.Value.CompareTo(currTime_UTC) < 0)  //it's time to undestroy
                    || (mo.Destroyed && !mo.TimeToUndestroy_UTC.HasValue && MO_ObjectiveUndestroy_recurs_firstrun))  //it's destroyed but no time to undestroy.  Undestroy it on first run of the session; not sure what else to do.  This shouldn't happen but probably does once in a while.


                {
                    string time = "No value";
                    if (mo.TimeToUndestroy_UTC.HasValue) time = mo.TimeToUndestroy_UTC.ToString();
                    Console.WriteLine("Undestroying: {0} {1} {2:F0} {3} ", mo.Name, mo.Destroyed, mo.DestroyedPercent * 100.0, time);

                    //must do these items BEFORE calling restoreAirfield because it copies a bunch of info from the MO to airfieldslist
                    mo.Destroyed = false;
                    mo.DestroyedPercent = 0;
                    mo.TimeToUndestroy_UTC = null;
                    mo.LastHitTime_UTC = null;
                    mo.ObjectsDestroyed_num = 0;
                    mo.OrdnanceOnTarget_kg = 0;
                    mo.AirfieldDamagePoints = 0;

                    if (mo.MOObjectiveType == MO_ObjectiveType.Airfield) restoreAirfield(mo);
                    if (mo.MOObjectiveType == MO_ObjectiveType.Radar) restoreRadar(mo);

                    twcLogServer(null, mo.Name + " has been repaired and returned to service.");

                    time = "No value";
                    if (mo.TimeToUndestroy_UTC.HasValue) time = mo.TimeToUndestroy_UTC.ToString();
                    Console.WriteLine("Undestroying after: {0} {1} {2:F0} {3} ", mo.Name, mo.Destroyed, mo.DestroyedPercent * 100.0, time);

                }

                //for airfields, start removing the craters bit by bit starting 2 hours before the undestroy time.
                if (mo.Destroyed && mo.MOObjectiveType == MO_ObjectiveType.Airfield &&
                    mo.TimeToUndestroy_UTC.HasValue && mo.TimeToUndestroy_UTC.Value.CompareTo(currTime_UTC.AddHours(2)) < 0) {
                    restoreAirfield(mo, 5); //remove just 5% each time.
                }
            }
            MO_ObjectiveUndestroy_recurs_firstrun = false;
        });
    }


    /*************************************************************************;
     * TOBRUK CAMPAIGN - HANDLE BUMRUSH PORTION
     * 
     * This is the final portion of the campaign
     *  #1. Each side has one "Focus Airport" - it is their mission goal to drive the enemy from that airport & then send a convoy to take over control of that airport
     *  #2. Each side has 6 primary objectives & the 1 focus airport
     *  #3. Other objectives are still in place & can be taken out, with whatever knock-off effect that has (airport out of commission, radar down, etc) but they don't count for much at all interms of the ultimate campaign goal
     *  #4. Once the 6 primary objectives & focus airport have been knocked out, then the 'Bum Rush' portion starts
     *  #5. First the attackers launch a convoy rush towards the Focus Airport.  They have 90 minutes to complete the takeover.  To achieve takeover, they must get 10 (?) of their attack vehicles onto the airfield, all at one time (?), ie, if you get one on the airfield & the other side kills it, that doesn't count.  You have to have a force of 10 vehicles ON THE AIRFIELD at ONE SINGLE POINT IN TIME to successfully complete the mission & take over that airfield.  The attackers have a certain time period, 90 minutes (?)
     *  #6. If the attackers fail, then the defenders launch a similar convoy towards the same focus airfield, to attempt to re-capture the airfield.  They have the same goal & time frame (10 vehicles, 90 minutes).  If they recapture the mission ends with the defenders re-securing the airfield.
     *  #7. If they fail the attackers send another convoy, same goal & time frame, and try again.  This continues in see-saw fashion until one side or the other captures/re-captures the focus airfield.
     *  #8. This might even continue over mission re-starts or perhaps it will only continue until the mission turns over, in which case the attackers have failed and the airport reverts to the defenders.  This is TBD.
     * 
     * 
     * 
     * ************************************************************************/

    //Better system for repeatedly calling a routine, than Timeout
    //Note: myTimer.Change(Timeout.Infinite, Timeout.Infinite); will stop it (though not stop a currently running thread started by it)
    public System.Threading.Timer MO_BRAdvanceBumrushPhaseTimer;
    public System.Threading.Timer MO_BRBumrushCheckTimer;
    public System.Threading.Timer MO_BRBumrushAIAttackTimer;
    public readonly int MO_BRBumrushPhaseTimer_period_min = 90;
    public readonly int MO_BRBumrushAIAttackTimer_period_sec = 270;
    public int MO_BRCurrentBumrushArmy = 0;
    public DateTime MO_BRLastBumrushStartTime;
    public DateTime MO_BRNextBumrushStartTime;
    public DateTime MO_BRBumrushAirportHeldStartTime = DateTime.MaxValue; //How long since the attacking army has been occupying the airport with sufficient vehicles
    public readonly double MO_BRBumrushAirbaseOccupyTimeRequired_sec = 300; //How long the attacking army must hold the center area to declare victory
    public readonly double MO_BRBumrushAirbaseOccupyDistance_m = 500; //attacking vehicles must get this close to center of airbase to officially "occupy" it
    public readonly double MO_BRBumrushAirbaseClearPerimeterDistance_m = 3500; //defending vehicles must be cleared out this far center of airbase for a victory

    private bool MO_BRBumrushPhase_lock = false;

    public void MO_BRStartBumrushPhase(int army)
        
    {
        MO_BRCurrentBumrushArmy = army;
        //Prevent this from running more than once concurrently
        //If we want to stop & restart over a single session/mission we'll have to do some rejiggering
        if (MO_BRBumrushPhase_lock) return;
        MO_BRBumrushPhase_lock = true;

        MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective;
        Console.WriteLine("Bumrush: Starting timer for BumrushPhase! " + DateTime.UtcNow.ToString("T"));
        MO_BRLastBumrushStartTime = DateTime.UtcNow;
        MO_BRNextBumrushStartTime = MO_BRLastBumrushStartTime.AddMinutes(MO_BRBumrushPhaseTimer_period_min);

        MO_BRAdvanceBumrushPhaseTimer = new System.Threading.Timer(
            MO_BRAdvanceBumrushPhase,
            //new Tuple<int,MissionObjective>(army, mo),
            new Tuple <int, bool>(army,false), //bool is whether or not thMO_BRAdvanceBumrushPhaseTimer must be restarted; ie TRUE = an interrupted timer/early restart 
            dueTime: 100, //wait time @ startup (ms).  So run it once in just 100ms; this starts the bumrush
            period: MO_BRBumrushPhaseTimer_period_min * 60 * 1000); //periodically call the callback at this interval to advance the bumrush to next phase.  Every 90 minutes = 540 seconds.

        MO_BRBumrushCheckTimer = new System.Threading.Timer(
            MO_BRBumrushCheck,
            //new Tuple<int, MissionObjective>(army, mo),
            //army,
            new Tuple<int, bool, int>(army, false, 0),
            dueTime: 300000, //wait time @ startup (ms).   We're going to wait 5 minutes before starting to check because  why not
            period: Convert.ToInt32((MO_BRBumrushAirbaseOccupyTimeRequired_sec /4.0 + 1) *1000)); //periodically call the callback at this interval to advance the bumrush to next phase.  Every 76 seconds.  4*76 = 304 

        MO_BRBumrushAIAttackTimer = new System.Threading.Timer(
            MO_BRBumrushAIAttack,
            new Tuple<int, bool>(army, false), //false = the routine is NOT being called from itself recursively
            //army,
            //dueTime: 300000, //wait time @ startup (ms).   We're going to wait 5 minutes before starting to check because  why not
            dueTime: 23000, //wait time @ startup (ms).   We're going to wait 5 minutes before starting to check because  why not
            period: MO_BRBumrushAIAttackTimer_period_sec*1000); //periodically call the callback at this interval call in an AI airmission to try to kill the advancing bumrush.  Every 5 minutes.

    }
    public void MO_BRStopBumrushPhase(int army)
    {
        MO_BRStopBumrushPhaseTimers(army);

        //reseting both sides (just to be safe) to bumrushstatus 0
        
        MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus = 0;
        MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus = 0;
        MO_BRCurrentBumrushArmy = 0;

        Console.WriteLine("Bumrush: Ending Bumrush phase, stopping all Bumrush timers" + DateTime.UtcNow.ToString("T"));

        //TODO: Here is where we could advance everything to the next bumrush airport, setup the new MO_BRBumrushInfo for the new airports, etc.
        //for now the mission just re-starts at the zero point once achieved.
        //The other thing we need to do is, make sure in the checkwinners business, to NOT go to bumrush mode in
        //case the score is > campaignwinners #.  Otherwise bumrush will re-start

    }

    public void MO_BRStopBumrushPhaseTimers(int army)

    {
  
        MO_BRBumrushPhase_lock = false;

        MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective;
        Console.WriteLine("Bumrush: Stopping timers for BumrushPhase! " + DateTime.UtcNow.ToString("T"));

        //Turn off the timers/stop them executing
        MO_BRAdvanceBumrushPhaseTimer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
        MO_BRBumrushCheckTimer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
        MO_BRBumrushAIAttackTimer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
        MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus = 0;

    }

    public void MO_BRExtendBumrushPhaseTimer_ifneeded(int army, int duetime_sec)
    {

        //TimeSpan duetime_ts = until_dt - DateTime.UtcNow;
        if (DateTime.UtcNow.AddSeconds(duetime_sec) <= MO_BRNextBumrushStartTime )
        {
            Console.WriteLine("Bumrush ExtendPhaseTimer: No extension needed, now: " + DateTime.UtcNow.ToString("T") + " next phase: " + MO_BRNextBumrushStartTime.ToString("T") + " duetime secs: " + (duetime_sec).ToString("N0"));
            return;
        }

        //Console.WriteLine("Bumrush: Extending timer for BumrushPhase " + DateTime.UtcNow.ToString("T") + " to " + until_dt.ToString("T") + " duetime " + duetime_ts.TotalMilliseconds);
        Console.WriteLine("Bumrush ExtendPhaseTimer: Extending timer for BumrushPhase " + DateTime.UtcNow.ToString("T") + " duetime secs " + (duetime_sec).ToString("N0") );

        MO_BRNextBumrushStartTime = (DateTime.UtcNow.AddSeconds(duetime_sec));

        adjustTimeLeft(duetime_sec/60, force:true);  //Will adjust time left to acommodate extended bumrush period

        //Extend the next phase change to the until date/time
        MO_BRAdvanceBumrushPhaseTimer.Change(
            //dueTime: duetime_ts.TotalMilliseconds,
            dueTime: duetime_sec * 1000,
            period: MO_BRBumrushPhaseTimer_period_min * 60 * 1000
        );
       

    }

    public void MO_BRAdvanceBumrushPhase(object obj)
    {
        try
        {
            //Tuple<int,MissionObjective> tup = obj as Tuple<int, MissionObjective>;

            //TODO!!!!!!! Must cleanup any vehicles, flak etc from OLD bumrush mission before loading the new one.
            //   --DONE?! (check it really works, though.  2020/08/29)
            //#########################################
            //TODO!!!!!!! Make auto-launch bomber  missions to attack convoys
            //   ---DONE.

            Tuple<int, bool> tup = (Tuple<int, bool>)obj;
            int army = tup.Item1;
            bool resetTimer = tup.Item2;

            if (resetTimer)
            {
                //We're advancing the Bumrush Phase early so we have to reset the timer, too, to give the next army their full period
                Console.WriteLine("Advance Bumrush Phase for " + ArmiesL[army] + " - also restarting Bumrush Timer due to early interruption of Bumrush");
                MO_BRAdvanceBumrushPhaseTimer.Change(MO_BRBumrushPhaseTimer_period_min * 60 * 1000, MO_BRBumrushPhaseTimer_period_min * 60 * 1000);
            }

            Console.WriteLine("Bumrush: AdvanceBumrushPhase now, re-starting timers, LastStartTime, NextStartTime for BumrushPhase! " + DateTime.UtcNow.ToString("T"));
            MO_BRLastBumrushStartTime = DateTime.UtcNow;            
            MO_BRNextBumrushStartTime = MO_BRLastBumrushStartTime.AddMinutes(MO_BRBumrushPhaseTimer_period_min);

            bool enoughTime = adjustTimeLeft(MO_BRBumrushPhaseTimer_period_min);  //Will either adjust time left to acommodate entire bumrush period (if possible) OR return FALSE and then we can just end it.

            if (!enoughTime) EndMission(endseconds: 1 * 60);


            MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective;

            //Timeout(90 * 60, ()=> { MO_BRStartOrAdvanceBumrushPhase(army); }); //In 90 minutes we'll move to the next Bumrushphase.
            Console.WriteLine("Advancing Bumrush Phase for " + ArmiesL[army] + " - current BumrushStatus=" + MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus.ToString() + " - will be: " + (MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus + 1).ToString());



            MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus += 1;

            //These are the NEW attacking/defending armies, after the bumrush ADVANCE +=1
            int objectivesAchievedArmy = army;
            int attackingArmy = objectivesAchievedArmy;
            int defendingArmy = 3 - objectivesAchievedArmy;
            if (MO_BRBumrushInfo[(ArmiesE)objectivesAchievedArmy].BumrushStatus % 2 == 0)
            {
                attackingArmy = 3 - objectivesAchievedArmy;
                defendingArmy = objectivesAchievedArmy;
            }

            if (MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus > 1)
            {
                Timeout(1, () =>
                {
                    GamePlay.gpHUDLogCenter("The " + ArmiesL[defendingArmy] + " attack on " + mo.Name + " failed."); //they were the ATTACKING army but now DEFENDING becuase they failed
                });

                Timeout(8, () =>
                {
                    GamePlay.gpLogServer(null, ArmiesL[attackingArmy] + " units defending the airfield area were low on ammo and fuel. They were forced to withdraw." , null); //they were the ATTACKING army but now DEFENDING because they failed
                });

                Timeout(15, () =>
                {
                    GamePlay.gpLogServer(null, "With short supplies forcing the " + ArmiesL[attackingArmy] + " ground units to withdraw from the area, " + ArmiesL[defendingArmy] + " was able to place a few rearguard defending ground units around the airport.  Attackers, beware!", null); //they were the ATTACKING army but now DEFENDING becuase they failed
                });
            }
            Timeout(20, () =>
            {
                GamePlay.gpHUDLogCenter("The " + ArmiesL[attackingArmy] + " attack on " + mo.Name + " has begun.");
                GamePlay.gpLogServer(null, ArmiesL[attackingArmy] + " attack on " + mo.Name + " has begun", null);
                GamePlay.gpLogServer(null, ArmiesL[attackingArmy] + " support the attack! " + ArmiesL[defendingArmy] + " repel the attack!", null);
            });

            //TODO: Not sure if this removal thing is really working right.  2020-09 - now it seems to be working OK.
            //It spreads the deletes over 30 seconds.
            Timeout(01, () =>
            {
              if (MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus > 1) Calcs.removeArtilleryAAGroundVehicles(GamePlay, this, AllGroundDict, mo.Pos.x, mo.Pos.y, 8000); //increasing radius to 8.0km for safety...
            });

            //MO_BRLaunchABumrush(attackingArmy, MO_BRBumrushInfo[(ArmiesE)army].BumrushAirportName);            
            // (attackingArmy, army, MO_BRBumrushInfo[(ArmiesE)army].BumrushAirportName);
            //Because deleting old stuf takes 30 secs we wait a bit longer than that to load the new stuff
            Timeout(80, () =>
            {
                twc_tobruk_campaign_mission_objectives.LaunchABumrush(objectivesAchievedArmy: army, attackingArmy: attackingArmy, AirportName: MO_BRBumrushInfo[(ArmiesE)army].BumrushAirportName);
            });

        }
        catch (Exception ex) { Console.WriteLine("AdvanceBumrushPhase: ERROR! " + ex.ToString()); }

    }



    public void MO_BRBumrushAIAttack(object obj)
    {
        try
        {
            Console.WriteLine("MO_BRBumrushAttack starting at {0:HHmmss}", DateTime.UtcNow);
            var tup = (Tuple<int, bool>)obj;
            //int army = (int)obj;
            int army = tup.Item1;
            bool recursiveRoutineCall = tup.Item2; //If the routine was called by itself; in that case we want ot avoid calling it AGAIN recursively.

            MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective;

            int attackingArmy = army;
            if (MO_BRBumrushInfo[(ArmiesE)army].BumrushStatus % 2 == 0) attackingArmy = 3 - army;
            int enemyArmy = 3 - attackingArmy;

            int numFriendlyPlayers = Calcs.gpNumberOfPlayersActive(GamePlay, attackingArmy);
            int numEnemyPlayers = Calcs.gpNumberOfPlayersActive(GamePlay, enemyArmy);

            //phase this out as the # of enemy players increases from 5 to 20
            double cutoff = 5;
            if (numFriendlyPlayers > numEnemyPlayers + 5) cutoff = 10; //if way more (breather) airport attackers (ie, supporting ground attack) than defenders we'll keep the attacks coming a bit longer, to keep things hot for the attackers & make it more difficult to take over the airfield.
            double highCutoff = 15;
            if (numFriendlyPlayers > numEnemyPlayers + 10) highCutoff = 25;
            if (numEnemyPlayers > cutoff && ((double)numEnemyPlayers - cutoff) / highCutoff > random.NextDouble()) return;

            //AiGroundGroup nearestGG = nearestGroundGroup(GamePlay, mo.Pos, 7000, army, AiGroundGroupType.Vehicle);

            //So, try the next bit a few times as it seems we are often running into invalid groups/actors.  Probably because they ahve been killed?
            bool success = false;
            bool launchextra = false;
            AiGroundGroup actualNearestGG = null;
            Point3d actualNearestGGpos;
            double actualNearestGGDistance_m = 10000000;
            AiGroundGroup nearestGG = null;
            AiGroundGroup anotherRandomGG = null;

            List<AiActor> GroundActorsInBullseye = Calcs.GetGroundActorsNear(GamePlay, this, AllGroundDict, mo.Pos, radius_m: 600, matcharmy: attackingArmy, type: "Vehicle");

            int attackingClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: MO_BRCurrentAttackingArmy(), type: "Vehicle");

            AiGroundGroup GroundActorGrpInBullseye = null;
            AiActor GroundActorInBullseye = null;

            if (attackingClose > 2 && GroundActorsInBullseye.Count > 0)
            {
                for (int i = 0; i < 10; i++)
                {
                    int index = random.Next(GroundActorsInBullseye.Count);
                    GroundActorInBullseye = GroundActorsInBullseye[index];
                    if (GroundActorInBullseye != null && GroundActorInBullseye is AiGroundActor && GamePlay.gpActorIsValid(GroundActorInBullseye))
                    {
                        GroundActorGrpInBullseye = GroundActorInBullseye.Group() as AiGroundGroup;
                        break;
                    }
                }
            }

            for (int i = 0; i < 15; i++)
            {
                //Find out where the ACTUAL closest GG to the target is.
                //If the nearest GG is IN THE AIRPORT we don't fool around, we just send the planes to KILL IT.
                actualNearestGG = Calcs.nearestGroundGroup(GamePlay, mo.Pos, 20000.0, attackingArmy, AiGroundGroupType.Vehicle, randomness: i);


                if (actualNearestGG == null || actualNearestGG.GetItems().Length == 0)
                {
                    Console.WriteLine("MO_BRBumrushAttack - no ground group to attack, try again {0}", i);
                    continue;
                }

                actualNearestGGpos = new Point3d(-100000, -100000, -100000);
                actualNearestGG.GetPos(out actualNearestGGpos);
                actualNearestGGDistance_m = Calcs.CalculatePointDistance(mo.Pos, actualNearestGGpos);
                if (actualNearestGGDistance_m < 600) launchextra = true;

                int rness = 20;
                if (actualNearestGGDistance_m < 2500) rness = 10;
                if (actualNearestGGDistance_m < 1000) rness = 1;

                nearestGG = Calcs.nearestGroundGroup(GamePlay, mo.Pos, 20000.0, attackingArmy, AiGroundGroupType.Vehicle, randomness: rness);

                //So choose ONE of the groups in the bullseye most of the time if there are more than a couple actors in it
                //But if 5 or more attack it EVERY time.
                //This is differnt from the old method, in that we get all the ACTORS in the bullseye & then choose randomly from them
                //so we don't get stuck on just one group that is perhaps in a difficult place or otherwise  problematic
                if (attackingClose > 2 && random.Next(0, 100) > 20) nearestGG = GroundActorGrpInBullseye;
                else if (attackingClose > 4 && random.Next(0, 100) > 3) nearestGG = GroundActorGrpInBullseye;

                anotherRandomGG = Calcs.nearestGroundGroup(GamePlay, mo.Pos, 20000.0, attackingArmy, AiGroundGroupType.Vehicle, randomness: 20);
                if (nearestGG == anotherRandomGG) anotherRandomGG = Calcs.nearestGroundGroup(GamePlay, mo.Pos, 20000.0, attackingArmy, AiGroundGroupType.Vehicle, randomness: 30);
                if (nearestGG == anotherRandomGG) anotherRandomGG = Calcs.nearestGroundGroup(GamePlay, mo.Pos, 20000.0, attackingArmy, AiGroundGroupType.Vehicle, randomness: 98);

                if (nearestGG == null || nearestGG.GetItems().Length == 0)
                {
                    Console.WriteLine("MO_BRBumrushAttack - no ground group to attack, try again {0}", i);
                    continue;
                }

                if (!GamePlay.gpActorIsValid(nearestGG))
                {
                    Console.WriteLine("MO_BRBumrushAttack - no ground group to attack, the actor was 'invalid'. try again {0}", i);
                    continue;

                }
                Console.WriteLine("MO_BRBumrushAttack - ground group found to attack, took {0} tries", i);
                success = true;
                break;
            }

            //If the enemy is close to/in the center launch and extra attack @ double the regular time
            //if (launchextra &&) Timeout(MO_BRBumrushAIAttackTimer_period_sec/2, ()=> { MO_BRBumrushAIAttack(obj); });

            if (!success)
            {
                Console.WriteLine("MO_BRBumrushAttack - no ground group to attack was found after many tries, no attack launched, exiting");
                return;
            }

            Console.WriteLine("MO_BRBumrushAttack - Ground Group will be attacked, " + (nearestGG as AiActor).Name()); // + " " + nearestGG.ID()); 

            //Timeout(random.Next(10, 6*60), ()=> {
            //Hmm, we have calced the target position above & if we wait at all it gets really stale.  So, don't
            Timeout(random.Next(0, 2), () =>
            {
                try
                {
                    if (nearestGG == null) return;
                    Console.WriteLine("MO_BRBumrushAttack - Starting Ground Group attack for " + (nearestGG as AiActor).Name() + " " + nearestGG.ID());
                    int moPosz_int = Convert.ToInt32(mo.Pos.z);
                    double alt_m = random.Next(moPosz_int + 200, moPosz_int + 500);
                    int numWayPoints = 1;
                    string gat_targ = "";

                    //int attackingClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: MO_BRCurrentAttackingArmy(), type: "Vehicle");

                    int defendingFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: MO_BRCurrentDefendingArmy(), type: "Vehicle");
                    int defendingFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: MO_BRCurrentDefendingArmy(), type: "Artillery");

                    int defendingFar = defendingFarArtillery + defendingFarVehicle;

                    //Make the attack flights larger as the enemy gets closer & more of them in the center (vs fewer of the enemy in the defending area)
                    //Also make the attack altitude lower, which improves accuracy by a lot
                    int numInFlight = random.Next(1, 5);
                    //if (actualNearestGGDistance_m < 2500) numInFlight *= 1.05;
                    if (actualNearestGGDistance_m < 1500) { numInFlight++; alt_m = random.Next(moPosz_int + 100, moPosz_int + 300); }
                    if (actualNearestGGDistance_m < 1000) { alt_m = random.Next(moPosz_int + 50, moPosz_int + 200); }
                    if (actualNearestGGDistance_m < 500) { numInFlight++; alt_m = random.Next(moPosz_int + 50, moPosz_int + 100); }
                    if (attackingClose > 2) { alt_m -= 50; }
                    if (attackingClose > 5) { numInFlight++; alt_m -= 50; }
                    if (attackingClose > 8) { alt_m -= 50; }
                    if (attackingClose > 5 && defendingFar < 5) { numInFlight++; alt_m -= 50; }

                    if (alt_m < mo.Pos.z) alt_m = mo.Pos.z;

                    if (recursiveRoutineCall) numInFlight = random.Next(1, 3); //just one or two in this case, because recursive calls are  more frequent, thus need to be smaller

                    //SOMETIMES when things are getting real close, launch an extra mission or TWO in between the next two regular missions.
                    //BUT keep track of whether this attack was called recursively in a similar way and if so, don't recursively continue that. Or we get like 5 missions called all at once and then that continues recursively, not good
                    //Also recursively called missions will be small

                    //Hmm, on trials, perhaps more frequent small missions are the solution.  One Ju88 or BR20 or a couple of Blenheims take out a whole column IF they get there.  Don't need 12 of them.
                    if (!recursiveRoutineCall)
                    {
                        if (attackingClose > 5)
                        {
                            Timeout(MO_BRBumrushAIAttackTimer_period_sec / 7.0 + random.NextDouble() * MO_BRBumrushAIAttackTimer_period_sec / 4.0, () => { MO_BRBumrushAIAttack(new Tuple<int, bool>(army, true) as object); });
                            Timeout(MO_BRBumrushAIAttackTimer_period_sec / 2.0 + random.NextDouble() * 5.0 * MO_BRBumrushAIAttackTimer_period_sec / 12.0, () => { MO_BRBumrushAIAttack(new Tuple<int, bool>(army, true) as object); });
                            if (numInFlight > 2) numInFlight = 2;  //we're adding more flights, so limit size of the flight we're sending now.  More frequent but smaller flights is the plan.
                        }
                        else
                        if ((attackingClose > 3 && defendingFar < 6) || attackingClose > 5)
                        {
                            Timeout(3.0 * MO_BRBumrushAIAttackTimer_period_sec / 8.0 + random.NextDouble() * MO_BRBumrushAIAttackTimer_period_sec / 4.0, () =>
                                {
                                    MO_BRBumrushAIAttack(new Tuple<int, bool>(army, true) as object);  //true meaning, this routine is calling itself recursively
                                });
                            if (numInFlight > 3) numInFlight = 3;  //we're adding more flights, so limit size of the flight we're sending now.  More frequent but smaller flights is the plan.
                        }
                    }



                    //If attacking army is red, then bombers will be blue.  Blue bombers come more from the west & Red bombers more from the east.
                    //This will add/subtract from the targetposition to start the bombers east OR west as appropriate.
                    double direction = -1;
                    if (army == 1) direction = 1;

                    Point3d gat = new Point3d(mo.Pos.x + random.Next(1000, 3000), mo.Pos.y + random.Next(1000, 3000), alt_m);
                    if (nearestGG != null && nearestGG.GetItems().Length > 0)
                    {
                        numWayPoints = nearestGG.GetItems().Length;
                        //gat_targ = nearestGG.ID();
                        //gat_targ = (nearestGG as AiActor).Name() + " " + (numWayPoints - 1).ToString();
                        gat_targ = (nearestGG as AiActor).Name();
                        Point3d grouppos = new Point3d(-100000, -100000, -100000);
                        nearestGG.GetPos(out grouppos);
                        gat = new Point3d(grouppos.x, grouppos.y, alt_m);
                    }
                    Point3d gap = mo.Pos;
                    gap.z = alt_m;
                    string gap_targ = "";

                    if (anotherRandomGG != null && GamePlay.gpActorIsValid(anotherRandomGG) && anotherRandomGG.GetItems().Length > 0 && anotherRandomGG != nearestGG)
                    {
                        Point3d grouppos = new Point3d(-100000, -100000, -100000);
                        anotherRandomGG.GetPos(out grouppos);
                        gap = grouppos;
                        gap.z = alt_m;
                        gap_targ = (anotherRandomGG as AiActor).Name();

                    }

                    Point3d p1 = new Point3d(gat.x + direction * random.Next(7000, 9000), gat.y + random.Next(-3500, 3500), random.Next(250, 350));
                    Point3d p2 = new Point3d(gat.x - gap.x + gat.x, gat.y - gap.y + gat.y, alt_m); //point in same direction of vector from a/p to ground vehicles, and 2X as far from the a/p 
                    Point3d p4 = new Point3d((gat.x - gap.x) * 0.2 + gap.x, (gat.y - gap.y) * 0.2 + gap.y, alt_m); //a point between ground attack (vehicles) &  point attack (airport) but closer to the airport

                    Point3d p6 = new Point3d(gap.x - gat.x + gap.x, gap.y - gat.y + gap.y, alt_m); //point in same direction of vector from a/p to ground vehicles, but on opposite side of airport
                    Point3d lan = new Point3d(gat.x + direction * random.Next(340000, 433000), gat.y + random.Next(-280000, 290000), random.Next(250, 350)); //take it right off the map if nothing else

                    //Bomb the center of the a/p more frequently when the time is low & when convoys are nearby
                    double airportBombChance = 0.15;
                    double timeleft = MO_BRBumrushTimeLeft_min_double();
                    if (timeleft < 20) airportBombChance = 1 - (timeleft / 20) * 0.85;
                    if (Calcs.CalculatePointDistance(gat, gap) < 1200) airportBombChance *= 2;
                    if (Calcs.CalculatePointDistance(gat, gap) < 500) airportBombChance = 1;
                    if (actualNearestGGDistance_m < 500) airportBombChance = 1;

                    try
                    {
                        //Note that alt_m is pretty much ignored, the actual .z value is used
                        ISectionFile f = Calcs.BuildBomber(GamePlay, this, bomberArmy: enemyArmy, vel_kmh: 300, alt_m: alt_m, p1: p1, p2: p2, gat: gat, p4: p4, gap: gap, p6: p6, lan: lan, gat_targ: gat_targ, gap_targ: gap_targ, attack_type: "LEVEL", airportBombChance: airportBombChance, numInFlight: numInFlight);
                        f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/bomberbuild" + random.Next(10, 99).ToString()); //testing)
                        GamePlay.gpPostMissionLoad(f);

                        Console.WriteLine("MO_BRBumrushAttack - Ground Group attack for " + (nearestGG as AiActor).Name() + " " + nearestGG.ID() + " gat: {0:N0} {1:N0} {2:N0} gap: {3:N0} {4:N0} {5:N0} apbombchance: {6:N2} numInflight: {7:N2} ",
                            new object[] { gat.x, gat.y, gat.z, gap.x, gap.y, gap.z, airportBombChance, numInFlight });
                    }
                    catch (Exception ex) { Console.WriteLine("Bumrush Bomber Load 2 ERROR! " + ex.ToString()); }

                    //Now, sometimes & if there are just a few live players online resisting the airfield attack, call in some FIGHTER COVER as well
                    if (!recursiveRoutineCall && random.Next(5) > -1 && random.Next(5) < 10 - numEnemyPlayers)
                    {

                        Timeout(random.Next(10, 45), () =>
                         {
                             try
                             {
                                 //BuildFighter(IGamePlay GamePlay, Mission mission, int planeArmy, double vel_kmh, double alt_m, Point3d p1, Point3d p2, Point3d gat, Point3d p4, Point3d gap, Point3d p6, Point3d lan, string gat_targ = "1_Chief 1", string gap_targ = "", int numInFlight = 2)
                                 //Note that alt_m is pretty much USED, the actually .z value is ignored
                                 ISectionFile f2 = Calcs.BuildFighter(GamePlay, this, planeArmy: enemyArmy, vel_kmh: 400, alt_m: alt_m + random.Next(200, 600), p1: p6, p2: gap, gat: gat, p4: p4, gap: mo.Pos, p6: p2, lan: lan, gat_targ: "", gap_targ: "", numInFlight: random.Next(1, 3));
                                 f2.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/fighterbuild" + random.Next(10, 99).ToString()); //testing)
                                     GamePlay.gpPostMissionLoad(f2);

                                 Console.WriteLine("MO_BRBumrushAttack - Fighter cover mission for " + (nearestGG as AiActor).Name() + " " + nearestGG.ID() + " gat: {0:N0} {1:N0} {2:N0} gap: {3:N0} {4:N0} {5:N0} ",
                            new object[] { gat.x, gat.y, gat.z, gap.x, gap.y, gap.z});

                             }
                             catch (Exception ex) { Console.WriteLine("Bumrush Fighter Load ERROR! " + ex.ToString()); }
                         });
                    }
                }
                catch (Exception ex) { Console.WriteLine("Bumrush Bomber Load ERROR! " + ex.ToString()); }


            });
        }
        catch (Exception ex) { Console.WriteLine("BumrushAttack: ERROR! " + ex.ToString()); }
    }

    //One side has achieved their initial objectives, or tried a bumrush & failed.  So now it's time to launch the first or another bum rush.
    public void MO_BRLaunchABumrush(int army, string airportname)
    {
        string aword = "Red";
        if (army == 2) aword = "Blue";
        Console.WriteLine("Starting a new Bumrush for " + aword + " at " + airportname);
        LoadRandomSubmission(fileID: MISSION_ID + "-Rush-" + aword + "-" + airportname, subdir: "Bumrushes");

    }
    
    bool MO_BRBumrushTestWin_Keeper = false;
    
    public void MO_BRBumrushCheck(object obj)
    {
        try
        {
            //Tuple<int, MissionObjective> tup = obj as Tuple<int, MissionObjective>;


            //MO_BRLastBumrushStartTime = DateTime.UtcNow;

            //int army = (int)obj;
            Tuple<int, bool, int> tup = (Tuple<int, bool, int>)obj;
            int army = tup.Item1;
            bool testBumrushwin = tup.Item2;
            int testBumrushWinningArmy = tup.Item3;

            if (testBumrushwin)
            {
                Console.WriteLine("Testing Bumrushwin for " + testBumrushWinningArmy.ToString());
                MO_BRBumrushTestWin_Keeper = true;
                Timeout(800, () => { MO_BRBumrushTestWin_Keeper = false; });
            }

            //So, don't even CHECK the BRstatus until the BR has been going for 5 min or more.  This should prevent...anamolies.
            TimeSpan TimeSinceLastBumrushStart = DateTime.UtcNow - MO_BRLastBumrushStartTime;
            if (TimeSinceLastBumrushStart.TotalSeconds < 300 && !testBumrushwin)
            {
                MO_BRBumrushAirportHeldStartTime = DateTime.MaxValue; 
                return;
            }
            
            MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective;

            //TODO - WARNING: Should somehow consolidate nearly identical code here & in BumrushSituationReport()
            //They calc the same thing & should always match

            int objectivesAchievedArmy = 1; //This is the one with all 6 objectives achieved & with the possibility to move the front forward
            if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) objectivesAchievedArmy = 2;

            int attackingArmy = objectivesAchievedArmy;
            int defendingArmy = 3 - objectivesAchievedArmy;
            if (MO_BRBumrushInfo[(ArmiesE)objectivesAchievedArmy].BumrushStatus % 2 == 0)
            {
                attackingArmy = 3 - objectivesAchievedArmy;
                defendingArmy = objectivesAchievedArmy;
            }

            //30km distant seems about the furthest we place any ground convoys.  Even if some are a bit higher than 30km there should always be some closer than that
            //from the start.  By time those are destroyed the >30km will be there etc.
            int attackingVeryFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, 30000, matcharmy: attackingArmy, type: "Vehicle");



            //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective.Pos, 2MO_BRBumrushAirbaseOccupyDistance_m army, AiGroundGroupType.Vehicle);
            int redClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: 1, type: "Vehicle");

            int blueClose = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseOccupyDistance_m, matcharmy: 2, type: "Vehicle");

            int redFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 1, type: "Vehicle");
            int redFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 1, type: "Artillery");

            int redFar = redFarArtillery + redFarVehicle;

            int blueFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 2, type: "Vehicle");
            int blueFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.Pos, MO_BRBumrushAirbaseClearPerimeterDistance_m, matcharmy: 2, type: "Artillery");

            int blueFar = blueFarArtillery + blueFarVehicle;

            //Put out the sitrep to the LOG every time we check.  So we know what happened EXACTLy if map turned, didn't turn, etc
            Console.WriteLine(MO_BRBumrushSituationReport(null, 100,0, display:false, html:false, silentIfInactive:false));

            string heldTime_string = "";
            double heldTime_sec = 0;
            TimeSpan heldTime_ts = new TimeSpan();

            if (MO_BRBumrushAirportHeldStartTime != DateTime.MaxValue)
            {
                heldTime_ts = DateTime.UtcNow - MO_BRBumrushAirportHeldStartTime;
                heldTime_sec = heldTime_ts.TotalSeconds;
                heldTime_string = string.Format(" ({0:N0} min of {1:N0})", heldTime_sec/60.0, MO_BRBumrushAirbaseOccupyTimeRequired_sec/60.0);
            }

            TimeSinceLastBumrushStart = DateTime.UtcNow - MO_BRLastBumrushStartTime;

            if (blueClose > 1)
            {
                twcLogServer(null, "Blue has " + blueClose.ToString() + " attack vehicles occupying the target airport; Red has " + redFar.ToString() + " attack vehicles/artillery in the area surrounding" + heldTime_string + ".");
            }

            if (redClose > 1)
            {
                twcLogServer(null, "Red has " + redClose.ToString() + " attack vehicles occupying the target airport; Blue has " + blueFar.ToString() + " attack vehicles/artillery in the area surrounding" + heldTime_string + ".");
            }

            if ((blueClose > 6 && redFar < 1 && attackingArmy == 2) || MO_BRBumrushTestWin_Keeper && attackingArmy == 2 || (testBumrushwin && testBumrushWinningArmy==2))  //We have a possible winner, BLUE!
            {

                if (MO_BRBumrushAirportHeldStartTime == DateTime.MaxValue)
                {
                    MO_BRBumrushAirportHeldStartTime = DateTime.UtcNow;
                    MO_BRExtendBumrushPhaseTimer_ifneeded(army, Convert.ToInt32(MO_BRBumrushAirbaseOccupyTimeRequired_sec + (MO_BRBumrushAirbaseOccupyTimeRequired_sec / 4.0 + 1 + 10))); //Extends the phase turn by time required to hold PLUS one extra winnercheckperiod PLUS 10 extra seconds just to be safe
                    twcLogServer(null, string.Format(ArmiesL[attackingArmy] + " is now occupying the base.  Must hold for {0:N0} minutes!", new object[] { MO_BRBumrushAirbaseOccupyTimeRequired_sec / 60.0 }));
                    GamePlay.gpHUDLogCenter(string.Format(ArmiesL[attackingArmy] + " occupying base - must hold {0:N0} min!", new object[] { MO_BRBumrushAirbaseOccupyTimeRequired_sec / 60.0}));
                }
                else if (heldTime_sec < MO_BRBumrushAirbaseOccupyTimeRequired_sec)
                {

                }
                else
                {

                    MO_BRStopBumrushPhase(army);
                    //they immediately win (even if no previous points earned) . . . but WHAT do they win?
                    //If they are the attacking army, they WIN THE MAP.
                    if (army == 2)
                    {
                        MissionObjectiveScore[ArmiesE.Blue] += MO_PointsRequiredToTurnMap[ArmiesE.Blue];
                        //This next bit is a little confusing/the army that just one MIGHT be the owner of this airport, so it amounts to destroying their own airport?!
                        Timeout(0.02, () => MO_DestroyObjective(MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective.ID, percentdestroyed: 100, timetofixFromNow_sec: 180000, messageDelay_sec: 52));
                    }
                    //If they are the DEFENDING ARMY they cause the other army to LOSE the same # of points they originally won to start the bumrush
                    //And they get all their own things REPAIRED and UNDAMAGED and the ENEMY GETS ALL NEW OBJECTIVES to complete
                    //Whereas the WINNERS get to KEEP their completed objectives and just finish off the REMAINDER of them
                    else
                    {
                        MissionObjectiveScore[ArmiesE.Red] -= MO_BRBumrushInfo[ArmiesE.Red].PointsRequiredToBeginBumrush; //MO_PointMO_PointsRequiredToTurnMap[ArmiesE.Blue]; }
                        Timeout(0.02, () => MO_CheckObjectivesComplete(BumrushRepelArmy: 2));
                        //EndMission();
                        //MO_CheckObjectivesComplete();
                    }
                }

            }
            else if ( (redClose > 6 && blueFar < 1 && attackingArmy == 1 ) || MO_BRBumrushTestWin_Keeper && attackingArmy == 1 || (testBumrushwin && testBumrushWinningArmy == 1))  //We have a possible winner, RED!
            {
                if (MO_BRBumrushAirportHeldStartTime == DateTime.MaxValue)
                {
                    MO_BRBumrushAirportHeldStartTime = DateTime.UtcNow;
                    MO_BRExtendBumrushPhaseTimer_ifneeded(army, Convert.ToInt32(MO_BRBumrushAirbaseOccupyTimeRequired_sec + (MO_BRBumrushAirbaseOccupyTimeRequired_sec / 4.0 + 1 + 10) )); //Extends the phase turn by time required to hold PLUS one extra winnercheckperiod PLUS 10 extra seconds just to be safe
                    twcLogServer(null, string.Format(ArmiesL[attackingArmy] + " is now occupying the base.  Must hold for {0:N0} minutes!", new object[] { MO_BRBumrushAirbaseOccupyTimeRequired_sec / 60.0 }));
                    GamePlay.gpHUDLogCenter(string.Format(ArmiesL[attackingArmy] + " occupying base - must hold {0:N0} min!", new object[] { MO_BRBumrushAirbaseOccupyTimeRequired_sec / 60.0 }));
                }
                else if (heldTime_sec < MO_BRBumrushAirbaseOccupyTimeRequired_sec)
                {

                }
                else
                {
                    MO_BRStopBumrushPhase(army);
                    if (army == 1)
                    {


                        //they immediately win (even if no previous points earned)
                        MissionObjectiveScore[ArmiesE.Red] += MO_PointsRequiredToTurnMap[ArmiesE.Red];

                        //This next bit is a little confusing/the army that just one MIGHT be the owner of this airport, so it amounts to destroying their own airport?!
                        Timeout(0.02, () => MO_DestroyObjective(MO_BRBumrushInfo[(ArmiesE)army].BumrushObjective.ID, percentdestroyed: 100, timetofixFromNow_sec: 180000, messageDelay_sec: 52));
                    }
                    //If they are the DEFENDING ARMY they cause the other army to LOSE the same # of points they originally won to start the bumrush
                    //And they get all their own things REPAIRED and UNDAMAGED and the ENEMY GETS ALL NEW OBJECTIVES to complete
                    //Whereas the WINNERS get to KEEP their completed objectives and just finish off the REMAINDER of them
                    else
                    {
                        MissionObjectiveScore[ArmiesE.Red] -= MO_BRBumrushInfo[ArmiesE.Blue].PointsRequiredToBeginBumrush; //MO_PointMO_PointsRequiredToTurnMap[ArmiesE.Blue]; }
                        Timeout(0.02, () => MO_CheckObjectivesComplete(BumrushRepelArmy: 1));
                        //EndMission();
                        //MO_CheckObjectivesComplete();
                    }
                }


            }
            else if (attackingVeryFarVehicle == 0 && MO_BRBumrushTimeLeft_min_double() > 1)
            {
                twcLogServer(null, ArmiesL[defendingArmy] + " has eliminated ALL enemy threats and attack vehicles near the target airport.");
                twcLogServer(null, ArmiesL[defendingArmy] + " will now commence a counterattact on the airport.");
                Timeout(0.02, () => GamePlay.gpHUDLogCenter(ArmiesL[defendingArmy] + " destroyed enemy ground attack - now counterattacking"));
                Timeout(20, () => { MO_BRAdvanceBumrushPhase(new Tuple<int, bool>(army, true)); });
                MO_BRBumrushAirportHeldStartTime = DateTime.MaxValue;

            } else
            {
                MO_BRBumrushAirportHeldStartTime = DateTime.MaxValue;
            }

        }
        catch (Exception ex) { Console.WriteLine("BumrushCheck: ERROR! " + ex.ToString()); }

    }

    public bool MO_BRBumrushActive()
    {
        if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus > 0 || MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) return true;
        else return false;

    }

    public string MO_BRBumrushTimeLeft_min_string()
    {
        /*if (!MO_BRBumrushActive()) return "0";
        TimeSpan timeleft = MO_BRNextBumrushStartTime - DateTime.UtcNow;
        return (timeleft.TotalMinutes.ToString("N0")); */
        return MO_BRBumrushTimeLeft_min_double().ToString("N0");        

    }

    public double MO_BRBumrushTimeLeft_min_double()
    {
        double timeLeft_min = 0;
        if (!MO_BRBumrushActive()) return 0;
        double missionTimeLeft_min = calcTimeLeft_min();
        TimeSpan timeLeft = MO_BRNextBumrushStartTime - DateTime.UtcNow;
        timeLeft_min = timeLeft.TotalMinutes;
        if (missionTimeLeft_min < timeLeft_min) timeLeft_min = missionTimeLeft_min; //If time left in mission is less then we'll show that instead.
        return (timeLeft_min);
    }

    //1, 2, or 0 if no current OBJECTIVESACHEIVEDARMY (ie, no current Bumrush)
    public int MO_BRObjectivesAchievedArmy()
    {
        int objectivesAchievedArmy = 0; //This is the one with all 6 objectives achieved & with the possibility to move the front forward
        if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus > 0) objectivesAchievedArmy = 1;
        else if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) objectivesAchievedArmy = 2;
        return objectivesAchievedArmy;
    }

    //1, 2, or 0 if no current ATTACKINGARMY for the BR
    public int MO_BRCurrentAttackingArmy()
    {
        
        int objectivesAchievedArmy = MO_BRObjectivesAchievedArmy();

        if (objectivesAchievedArmy == 0) return 0;

        int attackingArmy = objectivesAchievedArmy;
        int defendingArmy = 3 - objectivesAchievedArmy;
        if (MO_BRBumrushInfo[(ArmiesE)objectivesAchievedArmy].BumrushStatus % 2 == 0)
        {
            attackingArmy = 3 - objectivesAchievedArmy;
            defendingArmy = objectivesAchievedArmy;
        }

        return attackingArmy;
    }

    public int MO_BRCurrentDefendingArmy()
    {
        int caa = MO_BRCurrentAttackingArmy();
        if (caa == 0) return 0;
        return 3 - caa;
    }

    //The objective, or NULL if there isn't one
    public MissionObjective MO_BRCurrentBumrushMissionObjective()
    {
        MissionObjective mo = null;
        if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus > 0) mo = MO_BRBumrushInfo[(ArmiesE)1].BumrushObjective;
        if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) mo = MO_BRBumrushInfo[(ArmiesE)2].BumrushObjective;
        return mo;

    }

    public string MO_BRBumrushSituationReport(Player player, int numToDisplay = 12, double delay = 0.2, bool display = true, bool html = false, bool silentIfInactive=false)
    {
        try
        {
            string newline = Environment.NewLine;
            if (html) newline = "<br>" + Environment.NewLine;
            string retmsg = "";
            string msg = "";

            Player[] recipients = new Player[] { };
            if (player != null) recipients = new Player[] { player };

            int numDisplayed = 0;
            double totDelay = 0;


            if (MO_BRBumrushInfo[(ArmiesE)1].BumrushStatus == 0 && MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus == 0)
            {
                if (silentIfInactive) return "";
                msg = "AIRFIELD ATTACK SITUATION - NO AIRFIELD CURRENTLY UNDER GROUND ATTACK";
                if (display) twcLogServer(recipients, msg, new object[] { });
                retmsg = msg + newline;
                return retmsg;
            }

            string heldTime_string = "";
            double heldTime_sec = 0;
            TimeSpan heldTime_ts = new TimeSpan();

            if (MO_BRBumrushAirportHeldStartTime != DateTime.MaxValue)
            {
                heldTime_ts = DateTime.UtcNow - MO_BRBumrushAirportHeldStartTime;
                heldTime_sec = heldTime_ts.TotalSeconds;
                heldTime_string = string.Format(" ({0:N1} min of {1:N0})", heldTime_sec/60.0, MO_BRBumrushAirbaseOccupyTimeRequired_sec / 60.0);
            }

            //TODO - WARNING: Should somehow consolidate nearly identical code here & in BumrushCheck()
            //They calc the same thing & should always match

            int objectivesAchievedArmy = 1; //This is the one with all 6 objectives achieved & with the possibility to move the front forward
            if (MO_BRBumrushInfo[(ArmiesE)2].BumrushStatus > 0) objectivesAchievedArmy = 2;

            int attackingArmy = objectivesAchievedArmy;
            int defendingArmy = 3 - objectivesAchievedArmy;
            if (MO_BRBumrushInfo[(ArmiesE)objectivesAchievedArmy].BumrushStatus % 2 == 0)
            {
                attackingArmy = 3 - objectivesAchievedArmy;
                defendingArmy = objectivesAchievedArmy;
            }
            MissionObjective mo = MO_BRBumrushInfo[(ArmiesE)objectivesAchievedArmy].BumrushObjective;
            string objectiveID = mo.ID;
            Point3d objectivePos = mo.Pos;

            msg = "AIRFIELD ATTACK - CURRENT SITUATION REPORT (GROUND VEHICLES/AA) " + ArmiesL[attackingArmy] + " attacking " + mo.Name + " (" + MO_BRBumrushTimeLeft_min_string() + " min.)";
            if (display) twcLogServer(recipients, msg, new object[] { });
            retmsg = msg + newline;

            int redFarOld = 0;
            int blueFarOld = 0;
            int redFarOldVehicle = 0;
            int blueFarOldVehicle = 0;
            int redFarOldArtillery = 0;
            int blueFarOldArtillery = 0;

            bool resultbr = false;
            int start = Convert.ToInt32(MO_BRBumrushAirbaseOccupyDistance_m);
            int add = Convert.ToInt32(MO_BRBumrushAirbaseClearPerimeterDistance_m - MO_BRBumrushAirbaseOccupyDistance_m);
            int max = Convert.ToInt32(MO_BRBumrushAirbaseClearPerimeterDistance_m * 2);
            for (int i = start ; i < max; i += add )
            {
                //foreach (string s in MO_BRBumrushTargetAirfieldsList)

                {
                    //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, 1, AiGroundGroupType.Vehicle);
                    //int result1 = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, 2, AiGroundGroupType.Vehicle);
                    //int result = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, mo.BumrushObjective.Pos, 2500, army, AiGroundGroupType.Vehicle);
                    int redFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, matcharmy: 1, type: "Vehicle");
                    int redFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, matcharmy: 1, type: "Artillery");

                    int redFar = redFarArtillery + redFarVehicle;

                    int blueFarVehicle = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, matcharmy: 2, type: "Vehicle");
                    int blueFarArtillery = Calcs.CountGroundActors(GamePlay, this, AllGroundDict, objectivePos, i, matcharmy: 2, type: "Artillery");

                    int blueFar = blueFarArtillery + blueFarVehicle;

                    int redFarNew = redFar - redFarOld;
                    int blueFarNew = blueFar - blueFarOld;
                    int redFarNewVehicle = redFarVehicle - redFarOldVehicle;
                    int blueFarNewVehicle = blueFarVehicle - blueFarOldVehicle;
                    int redFarNewArtillery = redFarArtillery - redFarOldArtillery;
                    int blueFarNewArtillery = blueFarArtillery - blueFarOldArtillery;

                    redFarOld = redFar;
                    blueFarOld = blueFar;
                    redFarOldVehicle = redFarVehicle;
                    blueFarOldVehicle = blueFarVehicle;
                    redFarOldArtillery = redFarArtillery;
                    blueFarOldArtillery = blueFarArtillery;

                    if (redFarNew > 0 || blueFarNew > 0 || i==start)
                    {
                        string within = " within ";
                        if (i > start) within = String.Format(" {0}m-", i - add);
                        string msg1 = "Red: " + redFarNewVehicle.ToString("00") + "/" + redFarNewArtillery.ToString("00") 
                            + ",  Blue: " + blueFarNewVehicle.ToString("00") + "/" + blueFarNewArtillery.ToString("00")+ within + i.ToString() + "m";

                        if (i == start) msg1 += heldTime_string;
                        resultbr = true;
                        retmsg += msg1 + newline;
                        totDelay += delay;
                        if (display)
                        {
                            Timeout(totDelay, () =>
                            {
                                twcLogServer(recipients, msg1, new object[] { });
                            });//timeout      
                        }
                    }
                }
            }
            if (!resultbr)
            {

                msg = "No Red or Blue vehicles, artillery, or AA near the airfield.";
                retmsg += msg + newline;
                totDelay += delay;
                if (display)
                {
                    Timeout(totDelay, () =>
                    {
                        twcLogServer(recipients, msg, new object[] { });
                    });//timeout      
                }
            }
            return retmsg;
        }
        catch (Exception ex) { 
            Console.WriteLine("BumrushSituationReport: ERROR! " + ex.ToString());
            return "[[[BumrushSituationReport: ERROR!]]]";
        }
    }


    public void MO_CallMisTrigger(string tr)
    {
        if (GamePlay.gpGetTrigger(tr) != null)
        {
            GamePlay.gpGetTrigger(tr).Enable = true;
            //GamePlay.gpGetTrigger(tr).Active = true;

            Console.WriteLine("Enabled trigger " + tr);
        }
    }

    public void MO_CheckObjectivesComplete(int TestingOverrideArmy = 0, int BumrushRepelArmy = 0)
    {

        double bp = MO_PercentPrimaryObjectives((int)ArmiesE.Blue);
        double rp = MO_PercentPrimaryObjectives((int)ArmiesE.Red);

        //Turn the map by completing ALL primary objectives
        //or perhaps some secondaries; enough to reach the total required points.  (6 objectives X 5 points each, plus 1 primary airport target @ 30 points = 60 points)
        //THEN the Final rush is launched.
        //THEN you need another 60 points to successfully turn the map
        if ((MissionObjectiveScore[ArmiesE.Blue] >= MO_PointsRequiredToTurnMap[ArmiesE.Blue])
            //|| bp >= MO_PercentPrimaryTargetsRequired[ArmiesE.Blue] && MissionObjectiveScore[ArmiesE.Blue] >= MO_PointsRequiredWithMissingPrimary[ArmiesE.Blue]
            || TestingOverrideArmy == 2 || BumrushRepelArmy == 2)// Blue battle Success

        {
            //WriteResults_Out_File("2");
            Task.Run(() => WriteResults_Out_File("2"));
            Timeout(10, () =>
            {
                if (BumrushRepelArmy == 2)
                {
                    twcLogServer(null, "Blue has successfully repelled the attack and taken over the airport!!!", new object[] { });
                    GamePlay.gpHUDLogCenter("Blue has Successfully Retaken the Airport!!!");
                    MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Blue, BumrushRepelVictory: true);
                }
                else
                {
                    twcLogServer(null, "Blue has successfully turned the map and taken over the airport!!!", new object[] { });
                    GamePlay.gpHUDLogCenter("Blue has Successfully Turned the Map!!!");
                    //EndMission(70, "Blue");
                    MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Blue);
                }
            });



        }
        else if ((MissionObjectiveScore[ArmiesE.Red] >= MO_PointsRequiredToTurnMap[ArmiesE.Red])
           || TestingOverrideArmy == 1 || BumrushRepelArmy == 1)// Red battle Success
        {
            //WriteResults_Out_File("1");
            Task.Run(() => WriteResults_Out_File("1"));
            if (BumrushRepelArmy == 1)
            {
                twcLogServer(null, "Red has successfully repelled the attack and taken over the airport!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Red has Successfully Retaken the Airport!!!");
                MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Red, BumrushRepelVictory: true);
            }
            else
            {
                twcLogServer(null, "Red has successfully turned the map and taken over the airport!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Red has Successfully Turned the Map!!!");
                MO_MissionObjectiveRollingWinnerHandler(ArmiesE.Red);
            }
            //EndMission(70, "Red");

        }
        else

      //Turned airport & 6 main objectives, so now we unleash the final bum rush
      //OR most primary objectives (greater than specified percentage) plus reaching the higher point level required in that situation
      //NEVER do this in case the Bumrush attack has just been repelled
      if ((BumrushRepelArmy == 0 && MissionObjectiveScore[ArmiesE.Blue] >= MO_BRBumrushInfo[ArmiesE.Blue].PointsRequiredToBeginBumrush && bp > MO_PercentPrimaryTargetsRequired[ArmiesE.Blue] && MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus < 1 && MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus < 1 && MissionObjectiveScore[ArmiesE.Blue] < MO_PointsRequiredToTurnMap[ArmiesE.Blue])
      || TestingOverrideArmy == 2) // Blue first stage complete
        {
            //WriteResults_Out_File("2");
            Task.Run(() => WriteResults_Out_File("2"));
            Timeout(10, () =>
            {
                twcLogServer(null, "Blue has launched ground columns now trying to overrun the target airport!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Blue making a run on the airport to turn the map!!!");
            });

            MO_BRStartBumrushPhase((int)ArmiesE.Blue);



        }
        else


      //Turned airport & 6 main objectives, so now we unleash the final bum rush
      //OR most primary objectives (greater than specified percentage) plus reaching the higher point level required in that situation
      //NEVER do this in case the Bumrush attack has just been repelled
      if ((BumrushRepelArmy == 0 && MissionObjectiveScore[ArmiesE.Red] >= MO_BRBumrushInfo[ArmiesE.Red].PointsRequiredToBeginBumrush && rp > MO_PercentPrimaryTargetsRequired[ArmiesE.Red] && MO_BRBumrushInfo[ArmiesE.Blue].BumrushStatus < 1 && MO_BRBumrushInfo[ArmiesE.Red].BumrushStatus < 1
          && MissionObjectiveScore[ArmiesE.Red] < MO_PointsRequiredToTurnMap[ArmiesE.Red])
          || TestingOverrideArmy == 1) // Red first stage complete
        {
            //WriteResults_Out_File("2");
            Task.Run(() => WriteResults_Out_File("2"));
            Timeout(10, () =>
            {
                twcLogServer(null, "Red has launched ground columns now trying to overrun the target airport!!!", new object[] { });
                GamePlay.gpHUDLogCenter("Red making a run on the airport to turn the map!!!");
            });
            MO_BRStartBumrushPhase((int)ArmiesE.Red);

        }



        //Console.WriteLine("Figuring leaks:  {0} {1} {2} {3}", MissionObjectiveScore[ArmiesE.Red], MO_PointsRequired[ArmiesE.Red], bp, MO_PrimaryObjectivesRemaining( (int)ArmiesE.Red));


        if (MO_PrimaryObjectivesRemaining((int)ArmiesE.Red) <= 3)
        {
            MO_IntelligenceLeakNearMissionEnd[ArmiesE.Blue] = "Intelligence sources indicate the enemy may be attacking sector " + MO_SectorOfRandomRemainingPrimaryObjective((int)ArmiesE.Red) + " soon";
            //Console.WriteLine("Figuring Leaks: " + MO_IntelligenceLeakNearMissionEnd[ArmiesE.Blue] + " " + MO_IntelligenceLeakNearMissionEnd[ArmiesE.Red]);
        }
        else if (MO_PrimaryObjectivesRemaining((int)ArmiesE.Red) <= 3)
        {
            MO_IntelligenceLeakNearMissionEnd[ArmiesE.Red] = "Intelligence sources indicate the enemy may be attacking sector " + MO_SectorOfRandomRemainingPrimaryObjective((int)ArmiesE.Blue) + " soon"; ;
        }
    }

    //So inland, on home soil, both sides used observation networks to locate enemy aircraft & activity
    public bool MO_IsPointInHomeSoilObservationArea(Point3d pos, int attackingArmy)
    {
        if (GamePlay == null) return false;
        if (attackingArmy != 1 && attackingArmy != 2) return false;

        int terr = GamePlay.gpFrontArmy(pos.x, pos.y);

        if (terr != attackingArmy) return false; //On enemy territory you never have an observer network

        maddox.game.LandTypes landType = GamePlay.gpLandType(pos.x, pos.y);       
        if (landType == maddox.game.LandTypes.WATER) return false; // no observation network on water

        double chanceOfMissing = 33;

        if (pos.z > 4000) chanceOfMissing += 66 * (pos.z - 4000) / 8000;  //so chance of seeing becomes less starting at 4000m & down to zero at 8000m = 27000-ish ft.

        if (pos.z < 500) chanceOfMissing += 66* (500-pos.z)/400;  //so chance of seeing becomes less if under 500m.  chance of being within sight of a spotting station smaller.
        if (pos.z < 100) chanceOfMissing = 97;  //chance of being spotted less than 90m alt is slim.


        if (random.Next(100) < chanceOfMissing) return false; //So the observer network is a bit more sparse/less reliable than radar

        return true;
    }

    public bool MO_IsPointInDestroyedRadarArea(Point3d p, int army)
    {
        var DR = new List<MissionObjective>();

        if (army == 1 || army == 2) DR = DestroyedRadar[(ArmiesE)army];
        else return false;

        foreach (MissionObjective value in DR)
        {
            for (int i = 0; i < 2; i++) {

                //So we take 2 circles starting at the radar location and moving towards heading 315 for Blue radars & 135 for Red radars
                //this works pretty well for the Channel map.
                double xadd = (double)i * value.RadarEffectiveRadius;
                double yadd = -(double)i * value.RadarEffectiveRadius;
                if (army == 2) {
                    xadd = -(double)i * value.RadarEffectiveRadius;
                    yadd = (double)i * value.RadarEffectiveRadius;
                }

                Point3d calcPos = new Point3d(value.Pos.x + xadd, value.Pos.y + yadd, p.z);

                double dist = Calcs.CalculatePointDistance(p, calcPos);
                //Console.WriteLine(value.Name + " " + army.ToString() + " " + dist.ToString("F0") + " " + value.RadarEffectiveRadius.ToString("F0") + " " + p.x.ToString("F0") + " " + p.y.ToString("F0") + " " + value.Pos.x.ToString("F0") + " " + value.Pos.y.ToString("F0"));
                if (dist < value.RadarEffectiveRadius) return true;
            }
        }
        return false;
    }

    public bool MO_IsPointInDestroyedRadarArea_TOBRUK(Point3d p, int army)
    {
        var DR = new List<MissionObjective>();

        if (army == 1 || army == 2) DR = DestroyedRadar[(ArmiesE)army];
        else return false;

        foreach (MissionObjective value in DR)
        {

                Point3d calcPos = new Point3d(value.Pos.x, value.Pos.y, p.z);

                double dist = Calcs.CalculatePointDistance(p, calcPos);
                //Console.WriteLine(value.Name + " " + army.ToString() + " " + dist.ToString("F0") + " " + value.RadarEffectiveRadius.ToString("F0") + " " + p.x.ToString("F0") + " " + p.y.ToString("F0") + " " + value.Pos.x.ToString("F0") + " " + value.Pos.y.ToString("F0"));
                if (dist < value.RadarEffectiveRadius) return true;

        }
        return false;
    }

    //TOBRUK - radar coverage is based on distance from nearest objective
    //This provides the distance to the nearest objective of the army given
    public double MO_DistanceFromNearestRadarUnit(Point3d p, int army)
    {
        double closestDist_m = 1000000;
        bool first = true;
        foreach (MissionObjective mo in MissionObjectivesList.Values)
        {
            if (!mo.IsEnabled || mo.OwnerArmy != army || mo.Destroyed) continue;
            double dist_m = Calcs.CalculatePointDistance(p, mo.returnCurrentPosWithChief());

            if (first || dist_m< closestDist_m) { first = false; closestDist_m = dist_m; }
            
        }
        return closestDist_m;
    }

    public bool MO_isRadarEnabledByArea_TOBRUK(Point3d pos, bool admin = false, int radarArmy = 0)
    {
        try
        {
            if (admin || radarArmy == 0 || radarArmy > 2) return true;

            if (mission_objectives == null) { Console.WriteLine("#1.51  Mission Objectives really doesn't exist!"); return true; }

            if (MO_IsPointInDestroyedRadarArea_TOBRUK(pos, radarArmy)) return false;

            //things that are just out of range of our mobile radar units
            double dist_m = MO_DistanceFromNearestRadarUnit(pos, radarArmy);
            if (dist_m > 145000) return false;  //Basing this in Freya, service range 130km https://en.wikipedia.org/wiki/Radar_in_World_War_II#Transportable_Radio_Unit
            if (dist_m > 120000 && random.Next(25000) < (dist_m - 120000)) return false;  //Phases in gradually 120000-145000

            //OK< we don't have to worry about the "close to the ground/radar clutter" aspect because that is all covered by the belowRadar routine.
            //This routine just answers the question, is this objective in an area where radar coverage is possible.
            /*
            //Things that are right on top of an objective
            if (dist_m < 4000) return true; //Always detect if very close to an objective.  Let's say, observers etc

            //Things in the "clutter zone" ie relatively close to an objective
            double elev_m = Calcs.LandElevation_m(pos);
            if (dist_m < 50000 && (pos.z - elev_m) < 80) return false; //always below radar <70m AGL
            if (dist_m < 50000 && posz - elev_m < 160 && random.Next(80) > ((posz - elev_m)-80)) return false; //phase out rdar 70m-140m
            */

            //things that are at the radar horizon or beyond but still within range of the radar
            double minHeight_m = MO_minHeightForRadarDetection(dist_m);
            if (dist_m >= 50000 && pos.z < minHeight_m) return false; //This is in the radar shadow area, "below the horizon" from the point of view of the radar
            return true;
        }
        catch (Exception ex) { Console.WriteLine("MO_isRadarEnabledByArea_TOBRUK ERROR: "+ex.ToString()); return true; }
    }

    //Figure out which radar areas are disabled depending on army, admin radar, which objectives have been destroyed, etc.
    //Returns TRUE if radar is enabled for that area/army, returns FALSE if radar is disabled/out for that area/army
    //radarArmy 1 = red, 2=blue, 0=admin, anything else is not allowed (in practice this will ignore any radar outages)
    public bool MO_isRadarEnabledByArea_CLOD(Point3d pos, bool admin = false, int radarArmy = 0)
    {
        if (admin || radarArmy == 0 || radarArmy > 2) return true;

        //Console.WriteLine("#1 " + pos.x.ToString() + " " + pos.y.ToString() + " " + radarArmy.ToString());
        //WITHIN AN AREA WHERE THE RADAR HAS BEEN DESTROYED?
        //Finds if the point/ac is in an area with destroyed radar for either/both sides
        //if (mission_objectives != null) { if (MO_IsPointInDestroyedRadarArea(pos, radarArmy)) return false; }
        //else Console.WriteLine("#1.5111  Mission Objectives doesn't exist!!!!!");

        if (mission_objectives == null) Console.WriteLine("#1.51  Mission Objectives really doesn't exist!");
        else {
            if (MO_IsPointInHomeSoilObservationArea(pos, radarArmy)) return true; //So if it is on home ground & detected by the observer network, then it is on the charts
            if (MO_IsPointInDestroyedRadarArea(pos, radarArmy)) return false;
        }

        if (mission_objectives == null) Console.WriteLine("#1.52  Mission Objectives really doesn't exist!");
        //Console.WriteLine("#2.123 " + pos.x.ToString() + " " + radarArmy.ToString());

        //RED army areas where radar horizon is in effect
        //We just draw some simple lines to determine areas inside the radar horizon (generally, close enough to radar towers or on friendly territory where observer networks apply)
        //On the far side of those lines we apply the formula for lowest altitude a radar station can see, beyond it's radar horizon, depending on distance from the tower
        if (radarArmy == 1)
        {

            if (pos.x <= 170000)  //for the portion of the map where x< 170000 (the westernmost part) we just draw a straight line across at y=130000 and count the distance from there
            {
                if (pos.y >= 145000) return true; //This is within the radar horizon, so we're just ignoring it here.
                double dist_m = 145000 - pos.y;  //we count the line y=145                                    000 as the radar horizon; the radar horizon is ~ 45km from the radar device.  So we add the 45km distance back in.
                double minHeight_m = MO_minHeightForRadarDetection(dist_m + 45000);
                //Console.WriteLine("Red Radar Area (west): {0:F0} {1:F0} {2:F0} {3:F0} {4:F0}", pos.x, pos.y, pos.z, dist_m, minHeight_m);
                if (pos.z < minHeight_m) return false;
                else return true;
            }
            else //for the easternmost  part of the map we draw line between point 1 & point 2, coordinates below, and count thedistance northwesterly from that line as the critical distance.
            {
                //(295347, 220011)
                //(170000,145000)


                Point2d p1 = new Point2d(170000, 145000); //we reverse the direction compared with the Blue line, so that points to the south/east of this line will return a positive distance.
                Point2d p2 = new Point2d(295347, 220011);
                double dist_m = Calcs.PointToLineDistance(p1, p2, pos);
                if (dist_m <= 0) return true; //on the "home base" side of the line, meaning that radar (and/or observer network) is always good/active
                double minHeight_m = MO_minHeightForRadarDetection(dist_m + 45000);
                //Console.WriteLine("Red Radar Area (east): {0:F0} {1:F0} {2:F0} {3:F0} {4:F0}", pos.x, pos.y, pos.z, dist_m, minHeight_m);
                if (pos.z > minHeight_m) return true; //we count the line defined by p1 & p2 as the radar horizon; the radar horizon is ~ 45km from the radar device.  So we add the 45km back in here.
                else return false; //the object is below the minimum height for radar detection.                
            }
        }

        //BLUE army areas where radar horizon is in effect
        //We just draw some simple lines to determine areas inside the radar horizon (generally, close enough to radar towers or on friendly territory where observer networks apply)
        //On the far side of those lines we apply the formula for lowest altitude a radar station can see, beyond it's radar horizon, depending on distance from the tower        
        //Freya Radar had a range of 200km.  That is essentially enough to cover our entire map from the French coast.
        //Freya would have had a radar horizon of roughly 45 miles, meaning it could see everything down to a few meters elevation, out to that point.
        //After that the radar shadow (below the horizon) gradually rises in height.  the formula is
        // minimum height for detection = (distance - sqrt(2Xheight of radarXradius of earthX 4/3)^2/(2XRadius of earth X 4/3)
        // https://en.wikipedia.org/wiki/Radar_horizon
        else if (radarArmy == 2)
        {
            if (pos.x <= 170000)  //for the portion of the map where x< 170000 (the westernmost part) we just draw a straight line across at y=130000 and count the distance from there
            {
                if (pos.y <= 130000) return true; //This is within the radar horizon, so we're just ignoring it here.
                double dist_m = pos.y - 130000;  //we count the line y=130000 as the radar horizon; the radar horizon is ~ 45km from the radar device.  So we add the 45km distance back in.
                double minHeight_m = MO_minHeightForRadarDetection(dist_m + 45000);
                //Console.WriteLine("Blue Radar Area (west): {0:F0} {1:F0} {2:F0} {3:F0} {4:F0}", pos.x, pos.y, pos.z, dist_m, minHeight_m);
                if (pos.z < minHeight_m) return false;
                else return true;
            } else //for the easternmost  part of the map we draw line between point 1 & point 2, coordinates below, and count thedistance northwesterly from that line as the critical distance.
            {
                //point 1: 227132, 243249
                //point 2: 170000, 130000 
                //(243249-130000)/(227132-170000) x + 
                //double a = 243249 - 139000;
                //double b = 170000 - 227132;
                //double c = b / -a * 130000 / 170000;

                Point2d p1 = new Point2d(227132, 243249);
                Point2d p2 = new Point2d(170000, 130000);
                double dist_m = Calcs.PointToLineDistance(p1, p2, pos);
                if (dist_m <= 0) return true; //Negative values mean it is on the side of the line where the radar stations are; ie, no radar shadow
                double minHeight_m = MO_minHeightForRadarDetection(dist_m + 45000);
                //Console.WriteLine("Blue Radar Area (east): {0:F0} {1:F0} {2:F0} {3:F0} {4:F0}", pos.x, pos.y, pos.z, dist_m, minHeight_m);
                if (pos.z > minHeight_m) return true; //we count the line defined by p1 & p2 as the radar horizon; the radar horizon is ~ 45km from the radar device.  So we add the 45km back in here.
                else return false; //the object is below the minimum height for radar detection.                
            }

            /*
            //BLUE radar only goes approx to English Coast.
            //This approximates that by taking a line between these points

            //  250000  313000  TopR of map, direct north of Hellfire Corner
            //  250000  236000  hellfire corner
            //  170000  194000  Eastbourne
            //  8000    180000  Edge of map near Bournemouth
            //TODO: We could make this more realistic in various ways, perhaps extending some high-level radar partially into UK or the like

            //if (pos.x > 170000 && pos.x <= 250000)
            //if (pos.x > 170000 && pos.x <= 225000)
            if (pos.x > 170000 && pos.x <= 190000)
            {
                //if ((pos.x - 170000) / 80000 * 42000 + 194000 < pos.y) return false;
                //if ((pos.x - 170000) / 80000 * 42000 + 219000 < pos.y) return false;
                if ((pos.x - 170000) / 80000 * 42000 + 250000 < pos.y) return false;
            }
            if (pos.x > 8000 && pos.x <= 170000)
            {
                //if ((pos.x - 8000) / 162000 * 14000 + 180000 < pos.y) return false;
                //if ((pos.x - 8000) / 162000 * 14000 + 205000 < pos.y) return false;
                if ((pos.x - 8000) / 162000 * 14000 + 236000 < pos.y) return false;
            }
            return true;
            */
        }
        return true;

    }
    public static double RADAR_RADIUS_OF_EARTH_m = 8494666.667;

    //(distance - sqrt(2Xheight of radarXradius of earthX 4/3)^2/(2XRadius of earth X 4/3)
    //Radar height 120 meters is a reasonable guess for both British & German radar.
    //They usually had bluffs of around 100 meters in height to place them on.
    //Freya radar was at least 20 meters tall above that; British masts were probably a bit taller but the practical difference is small, because ground clutter, details of topography, exact
    //implementation of radar etc all tend to be just as important
    //On the other hand, the 120 meter height was probably nicely operative over the ocean.  But what we're more worried about here is the
    //penetration into the other side's land area.  There, the effective height is more like 20 meters or maybe less, because both sides are about equally high and have various hills, bluffs, etc rising 100-120 meters or so above sea level.  So we're going with the 20 meter distance which is more realistic as to how hard it was then to pick things up close to teh ground (except for, over nice flat water).
    //https://en.wikipedia.org/wiki/Radar_horizon
    public double MO_minHeightForRadarDetection(double distance_m, double radarHeight_m = 20)
    {
        return Math.Pow((distance_m - Math.Sqrt(2 * radarHeight_m * RADAR_RADIUS_OF_EARTH_m)), 2) / 2 / RADAR_RADIUS_OF_EARTH_m;
    }

    public string ListRadarTargetDamage(Player player = null, int army = -1, bool all = false, bool display = true)
    {
        try
        {
            int count = 0;
            string returnmsg = "";
            double delay = 0.1;

            var DR = new List<MissionObjective>();

            List<int> armies;
            if (army == 1) armies = new List<int>() { 1 };
            else if (army == 2) armies = new List<int>() { 2 };
            else armies = new List<int>() { 1, 2 };

            foreach (int a in armies)
            {
                DR = DestroyedRadar[(ArmiesE)a];

                foreach (MissionObjective mo in DR)
                {
                    string msg2 = " (unknown)";
                    if (mo.TimeToUndestroy_UTC.HasValue)
                    {

                        double days = Math.Ceiling((mo.TimeToUndestroy_UTC.Value.Subtract(DateTime.UtcNow)).TotalDays * 2.0) / 2.0; //round to the half day
                        msg2 = "(" + days.ToString("F1") + " days)";
                    }
                    string msg = mo.Name + " destroyed " + msg2;
                    returnmsg += msg + "\n";

                    if (display)
                    {
                        delay += 0.02;
                        Timeout(delay, () => { twcLogServer(new Player[] { player }, msg, new object[] { }); });
                    }

                    count++;
                }
            }
            if (count == 0)
            {
                string msg = "No radar currently damaged or destroyed";
                if (display) twcLogServer(new Player[] { player }, msg, new object[] { });
                returnmsg = ""; //In case of display == false we just don't return any message at all, allowing this bit to simply be omitted
            }

            return returnmsg;
        }
        catch (Exception ex) { Console.WriteLine("MO_RadarList Error: " + ex.ToString()); return ""; };
    }

    public void MO_addDamagersToListOfPlayersWhoContributed(List<DamagerScore> damages, MissionObjective mo)
    {
        Task.Run(() =>
        {
            try
            {

                foreach (DamagerScore ds in damages)
                {
                    //if (ds != null && ds.initiator !=null && ds.initiator.Player != null || ds.initiator.Player.Name() != null)
                    //    mo.PlayersWhoContributedNames.Add(ds.initiator.Player.Name());
                    if (ds == null) continue;
                    if (ds != null && ds.initiator != null) MO_addInitiatorToListOfPlayersWhoContributed(ds.initiator, mo);
                }
            }
            catch (Exception ex) { Console.WriteLine("MO_addDamagersToListOfPlayersWhoContributed ERROR : {0} ", ex.ToString()); }
        });
    }

    public void MO_addInitiatorToListOfPlayersWhoContributed(AiDamageInitiator initiator, string ID)
    {
        if (MissionObjectivesList.ContainsKey(ID)) MO_addInitiatorToListOfPlayersWhoContributed(initiator, MissionObjectivesList[ID]);
        else Console.WriteLine("MO_addInitiatorToListOfPlayersWhoContributed ERROR: Couldn't find Mission Objective ID: " + ID);
    }

    public void MO_addInitiatorToListOfPlayersWhoContributed(AiDamageInitiator initiator, MissionObjective mo)
    {
        try
        {
            if (initiator == null) return;
            if (initiator.Player == null) return;
            if (initiator.Player.Name() == null) return;
            if (initiator != null && initiator.Player != null && initiator.Player.Name() != null)
            {
                mo.makeScoutedFromBombRun(initiator.Player);
                mo.PlayersWhoContributedNames.Add(initiator.Player.Name());
            }
        }
        catch (Exception ex) { Console.WriteLine("MO_addInitiatorToListOfPlayersWhoContributed: {0}", ex.ToString()); }
    }

    //FOR AIACTOR TARGETS DESTROYED
    public void MO_HandlePointAreaObjectives(AiActor actor, List<DamagerScore> damages)
    {
        try
        {
            if (actor == null || actor.Army() < 1 || actor.Army() > 2 || (actor as AiPerson ) != null) return;  //we don't count people/person's killed & it causes "object reference" errors below

            //Console.WriteLine("AreaPoint Actor: {0}, {1}, {2}", actor.Name(), actor.Army(), (actor as AiCart).InternalTypeName());
            //TODO: Could easily combine this with the GroundStationaries route, 95% the same

            DateTime currTime_dt = DateTime.UtcNow;
            double repairSpeedupFactor = 1;

            //Console.WriteLine("main_PointArea_actor");

            foreach (string ID in MissionObjectivesList.Keys)
            {


                MissionObjective mo = MissionObjectivesList[ID];
                if (actor.Army() != mo.OwnerArmy) continue;
                if (mo.MOTriggerType != MO_TriggerType.PointArea || !mo.IsEnabled) continue;
                double dist = Calcs.CalculatePointDistance(actor.Pos(), mo.Pos);
                if (dist > mo.radius) continue;

                string type = "";
                if ((actor as AiCart) != null && (actor as AiCart).InternalTypeName() != null) type = (actor as AiCart).InternalTypeName();

                string groundType = "";
                if (actor as AiGroundActor != null) groundType = (actor as AiGroundActor).Type().ToString();



                mo.LastHitTime_UTC = DateTime.UtcNow;
                MO_addDamagersToListOfPlayersWhoContributed(damages, mo);

                if (MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy].ContainsKey("RepairCrewEndTime_dt") && MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy]["RepairCrewEndTime_dt"] > currTime_dt) repairSpeedupFactor = 4;

                double oldOONT_num = mo.ObjectsDestroyed_num;

                //Damage bonuses for various specific types.  This is hard to do systematically.
                //type - should contain the string found in the .mis file for objects, such as Environment.TelegaBallon_UK1
                //groundType is the enum list  of type maddox.game.world.AiGroundActorType which has a bunch of the things listed below plus more

                double damageCount = 1;
                if (type.Contains("Barge")) damageCount = 7;
                else if (type.Contains("Tanker") || type.Contains("Cruiser")) damageCount = 12;
                else if (groundType.Contains("ShipCarrier") || groundType.Contains("ShipCruiser") || groundType.Contains("ShipDestroyer") || groundType.Contains("warship")) damageCount = 20;
                else if (groundType.ToLower().Contains("ship")) damageCount = 9;
                else if (groundType.Contains("AAGun") || groundType.Contains("Artillery") || groundType.Contains("Tank") || groundType.Contains("Armored") || groundType.Contains("Amphibian")) damageCount = 4;
                else if (groundType.ToLower().Contains("truck") || groundType.ToLower().Contains("tractor") || groundType.ToLower().Contains("trailer")) damageCount = 2;
                else if (groundType.ToLower().Contains("radar")) damageCount = 6;
                else if (groundType.ToLower().Contains("plane")) damageCount = 3;
                else if (groundType.ToLower().Contains("bridge")) damageCount = 10;


                if (dist > mo.TriggerDestroyRadius) damageCount *= 0.333; //less damage effectiveness if inside radius but outside triggerradius
                mo.ObjectsDestroyed_num += damageCount;

                double divisor = 1;
                if (mo.OrdnanceRequiredToTrigger_kg > 0 && mo.ObjectsRequiredToTrigger_num > 0) divisor = 2; //If both objects & KG required to trigger, we give each of them 50% of the required 100% for destruction.

                //So this is a bit complicated, but percentage destroyed due to ordinance & KG can't go above 50% UNLESS the other type of objective is completed also.
                //The prevents, ie, showing 125% destroyed purely by bombing KG, when 0 of the 10 required targets have been killed.
                //In that case it will show 50% complete, not 125%
                //Now, once both sides are complete (KG & objects) then additional KG or objects killed will add more percent
                double dst_pc_ord = 0;
                if (mo.OrdnanceRequiredToTrigger_kg > 0) dst_pc_ord = mo.OrdnanceOnTarget_kg / mo.OrdnanceRequiredToTrigger_kg / divisor;
                double dst_pc_obj = 0;
                if (mo.ObjectsRequiredToTrigger_num > 0) dst_pc_obj = mo.ObjectsDestroyed_num / mo.ObjectsRequiredToTrigger_num / divisor;

                if (dst_pc_obj > 0.5 && mo.OrdnanceRequiredToTrigger_kg > mo.OrdnanceOnTarget_kg) dst_pc_obj = 0.5;

                //So if the KG requirement has been met, but not the OBJ requirement, we cap the KG contribution to the % total at 50%.  Except . . . if the KG contribution
                //goes over 100% then we start to add it back in at 1/3 rate.
                if (dst_pc_ord > 0.5 && mo.ObjectsDestroyed_num < mo.ObjectsRequiredToTrigger_num)
                {
                    double orig_dst_pc_ord = dst_pc_ord;
                    dst_pc_ord = 0.5;
                    double add_dst_pc_ord = 0;
                    if (mo.OrdnanceRequiredToTrigger_kg > 100 && orig_dst_pc_ord > 1) add_dst_pc_ord = (orig_dst_pc_ord - 0.5) / 3;
                    dst_pc_ord += add_dst_pc_ord;
                }

                double oldDestroyedPercent = mo.DestroyedPercent;
                mo.DestroyedPercent = dst_pc_obj + dst_pc_ord;

                Console.WriteLine("PointArea Actor: {0:F0}% objects, {1:F0}% KG, {2:F0}% Tot, {3:F0} KG KGreq: {4:F0} Numreq: {5:F0} {6}", dst_pc_obj * 100, dst_pc_ord * 100, mo.DestroyedPercent * 100, mo.OrdnanceOnTarget_kg, mo.OrdnanceRequiredToTrigger_kg, mo.ObjectsRequiredToTrigger_num, mo.Name);

                //if (mo.ObjectsDestroyed_num > mo.ObjectsRequiredToTrigger_num)
                if ((!mo.Destroyed || !mo.ObjectiveAchievedForPoints) && mo.DestroyedPercent >= 1)
                    MO_DestroyObjective(ID, true, percentdestroyed: mo.DestroyedPercent, timetofixFromNow_sec: mo.TimetoRepairIfDestroyed_hr * 3600 / repairSpeedupFactor); // 1 because, we always get 1 object here. //hnMO_DestroyObjective(ID, true, percentdestroyed: mo.DestroyedPercent, timetofix_s: mo.TimetoRepairIfDestroyed_hr * 3600); //Note - MUST use >= here as it covers the case where ordnanceKG and/or object_numrequired = 0
                else if (mo.DestroyedPercent > 100 && mo.ObjectsRequiredToTrigger_num > 0)
                {
                    mo.DestroyedPercent = 1 + damageCount / mo.ObjectsRequiredToTrigger_num / 4.0 / divisor;  // so if it's above 100% destroyed additional bombs/ordnance still add more "dead points" but not as many/ assuming much of it is already destroy, so like 1/4 as much.
                    double timeToFix_hr = (mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent);
                    if (mo.TimeToUndestroy_UTC.HasValue) mo.TimeToUndestroy_UTC.Value.AddHours(mo.TimetoRepairIfDestroyed_hr * damageCount / mo.ObjectsRequiredToTrigger_num / 4.0 / repairSpeedupFactor);  //just add time proportional to how many objects required to kill it 100%.  But divided by 4 since we are discounting the destruction
                    else mo.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent / repairSpeedupFactor);
                    MO_DestroyObjective_addTime(ID, percentdestroyed: mo.DestroyedPercent);
                }
                else if (Math.Floor(oldDestroyedPercent * 100.0 / 25.0) % 2 != Math.Floor(mo.DestroyedPercent * 100.0 / 25.0) % 2) //if crossing threshold @ 25, 50, 75% give a message with status update of objective
                {
                    twcLogServer(null, "{0} damaged: {1}% destroyed, {2} items damaged, {3} kg on target", new object[] { mo.Name, (mo.DestroyedPercent * 100).ToString("F0"), mo.ObjectsDestroyed_num.ToString("F0"), mo.OrdnanceOnTarget_kg.ToString("F0") });
                }

                ///!!!!!!!!!!!!!!!!!!! might still need ot do more things here, check the missionobjectives class.
                ///
                /*
                 * 
               if (percentdestroyed > 0) OldObj.DestroyedPercent = percentdestroyed;
                    if (timetofix_s > 0) OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timetofix_s);
                    if (TimetoUndestroy_UTC.HasValue) OldObj.TimeToUndestroy_UTC = TimetoUndestroy_UTC.Value;
                    if (TimeLastHit_UTC.HasValue) OldObj.LastHitTime_UTC = TimeLastHit_UTC.Value;    
             */

            }        
        } catch (Exception ex) { Console.WriteLine("MO_HandlePointAreaObjectives (actor) ERROR: " + ex.ToString()); }


    }

    //FOR STATIONARY TARGETS DESTROYED ***OR*** BUILDINGS
    //if st==null then it is a BUILDING instead of a groundstationary object
    public void MO_HandlePointAreaObjectives(GroundStationary st, AiDamageInitiator initiator, string title = null, Point3d? BuildingPos = null)
    {
        
        Point3d pos = new Point3d(-1, -1, -1);       

        if (st != null) pos = st.pos;
        else if (BuildingPos.HasValue) pos = BuildingPos.Value;
        else return; //both are null, so can't really do anything here as we don't have a position

        string name = "";
        if (st != null) name = st.Name;
        else if (title != null) name = title;

        //Console.WriteLine("main_PointArea_stationary " + name + " " + title);

        DateTime currTime_dt = DateTime.UtcNow;
        double repairSpeedupFactor = 1;        

        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];
            if (mo.MOTriggerType != MO_TriggerType.PointArea || !mo.IsEnabled) continue;
            double dist = Calcs.CalculatePointDistance(pos, mo.Pos);

            if (dist<10000) try
                {
                    Console.WriteLine("MO_HandlePointAreaObjectives stationary/building CLOSE: " + name + " " + st.country + " " + st.pos.x.ToString("F0") + " " + st.pos.y.ToString("F0") + " " + st.Title + " " + st.Type.ToString() + " " + dist.ToString("F0") + " " + mo.radius.ToString("F0"));
                }
                catch (Exception ex) { }

            if (dist > mo.radius) continue;

            try
            {
                Console.WriteLine("MO_HandlePointAreaObjectives stationary/building HIT: " + name + " " + st.country + " " + st.pos.x.ToString("F0") + " " + st.pos.y.ToString("F0") + " " + title + " " + st.Type.ToString());
            }
            catch (Exception ex) { }

            mo.LastHitTime_UTC = DateTime.UtcNow;            

            double oldOONT_num = mo.ObjectsDestroyed_num;

            MO_addInitiatorToListOfPlayersWhoContributed(initiator, mo);

            double damageCount = 1;
            if (name.Contains("Barge") || name.Contains("Tanker") || name.Contains("Cruiser")) damageCount = 10;
            
            if (dist > mo.TriggerDestroyRadius) damageCount *= 0.333; //less damage effectiveness if inside radius but outside triggerradius
            mo.ObjectsDestroyed_num += damageCount;

            if (MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy].ContainsKey("RepairCrewEndTime_dt") && MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy]["RepairCrewEndTime_dt"] > currTime_dt) repairSpeedupFactor = 4;

            double divisor = 1;
            if (mo.OrdnanceRequiredToTrigger_kg > 0 && mo.ObjectsRequiredToTrigger_num > 0) divisor = 2; //If both objects & KG required to trigger, we give each of them 50% of the required 100% for destruction.

            //So this is a bit complicated, but percentage destroyed due to ordinance & KG can't go above 50% UNLESS the other type of objective is completed also.
            //The prevents, ie, showing 125% destroyed purely by bombing KG, when 0 of the 10 required targets have been killed.
            //In that case it will show 50% complete, not 125%
            //Now, once both sides are complete (KG & objects) then additional KG or objects killed will add more percent
            double dst_pc_ord = 0;
            if (mo.OrdnanceRequiredToTrigger_kg > 0) dst_pc_ord = mo.OrdnanceOnTarget_kg / mo.OrdnanceRequiredToTrigger_kg / divisor;
            double dst_pc_obj = 0;
            if (mo.ObjectsRequiredToTrigger_num > 0) dst_pc_obj = mo.ObjectsDestroyed_num / mo.ObjectsRequiredToTrigger_num / divisor;

            if (dst_pc_obj > 0.5 && mo.OrdnanceRequiredToTrigger_kg > mo.OrdnanceOnTarget_kg) dst_pc_obj = 0.5;
        //So if the KG requirement has been met, but not the OBJ requirement, we cap the KG contribution to the % total at 50%.  Except . . . if the KG contribution
        //goes over 100% then we start to add it back in at 1/3 rate.
        if (dst_pc_ord > 0.5 && mo.ObjectsDestroyed_num < mo.ObjectsRequiredToTrigger_num)
        {
            double orig_dst_pc_ord = dst_pc_ord;
            dst_pc_ord = 0.5;
            double add_dst_pc_ord = 0;
            if (mo.OrdnanceRequiredToTrigger_kg > 100 && orig_dst_pc_ord > 1) add_dst_pc_ord = (orig_dst_pc_ord - 0.5) / 3;
            dst_pc_ord += add_dst_pc_ord;
        }

        double oldDestroyedPercent = mo.DestroyedPercent;
            mo.DestroyedPercent = dst_pc_obj + dst_pc_ord;

            Console.WriteLine("PointArea Stationary: {0:F0}% objects, {1:F0}% KG, {2:F0}% Tot, {3:F0} KG KGreq: {4:F0} Numreq: {5:F0} {6} ({7:F0},{8:F0})", dst_pc_obj * 100, dst_pc_ord * 100, mo.DestroyedPercent * 100, mo.OrdnanceOnTarget_kg, mo.OrdnanceRequiredToTrigger_kg, mo.ObjectsRequiredToTrigger_num, mo.Name, mo.Pos.x, mo.Pos.y);
            if (st!=null) Console.WriteLine("AreaPoint Stationary: {0}, {1}, {2}, {3}", st.Category, st.Name, st.Type, st.Title);
            else Console.WriteLine("AreaPoint Building: {0}", name);


            //if (mo.ObjectsDestroyed_num > mo.ObjectsRequiredToTrigger_num)
            //if ((!mo.Destroyed || !mo.ObjectiveAchievedForPoints) && mo.ObjectsDestroyed_num >= mo.ObjectsRequiredToTrigger_num && mo.OrdnanceOnTarget_kg >= mo.OrdnanceRequiredToTrigger_kg)
            if ((!mo.Destroyed || !mo.ObjectiveAchievedForPoints) && mo.DestroyedPercent >= 1)
                MO_DestroyObjective(ID, true, percentdestroyed: mo.DestroyedPercent, timetofixFromNow_sec: mo.TimetoRepairIfDestroyed_hr * 3600/repairSpeedupFactor); // 1 because, we always get 1 object here. //hnMO_DestroyObjective(ID, true, percentdestroyed: mo.DestroyedPercent, timetofix_s: mo.TimetoRepairIfDestroyed_hr * 3600); //Note - MUST use >= here as it covers the case where ordnanceKG and/or object_numrequired = 0
            else if (mo.DestroyedPercent > 100 && mo.ObjectsRequiredToTrigger_num > 0)
            {
                mo.DestroyedPercent = 1 + damageCount / mo.ObjectsRequiredToTrigger_num / 4.0 / divisor;  // so if it's above 100% destroyed additional bombs/ordnance still add more "dead points" but not as many/ assuming much of it is already destroy, so like 1/4 as much.
                double timeToFix_hr = (mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent);
                if (mo.TimeToUndestroy_UTC.HasValue) mo.TimeToUndestroy_UTC.Value.AddHours(mo.TimetoRepairIfDestroyed_hr * damageCount / mo.ObjectsRequiredToTrigger_num / 4.0 /repairSpeedupFactor);  //just add time proportional to how many objects required to kill it 100%.  But divided by 4 since we are discounting the destruction
                else mo.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent/repairSpeedupFactor);
                MO_DestroyObjective_addTime(ID, percentdestroyed: mo.DestroyedPercent);

            }
            else if (Math.Floor(oldDestroyedPercent * 100.0 / 25.0) % 2 != Math.Floor(mo.DestroyedPercent * 100.0/ 25.0) % 2) //if crossing threshold @ 25, 50, 75% give a message with status update of objective
            {
                twcLogServer(null, "{0} damaged: {1}% destroyed, {2} items damaged, {3} kg on target", new object[] { mo.Name, (mo.DestroyedPercent * 100).ToString("F0"), mo.ObjectsDestroyed_num.ToString("F0"), mo.OrdnanceOnTarget_kg.ToString("F0") });
            }

                ///!!!!!!!!!!!!!!!!!!! might still need ot do more things here, check the missionobjectives class.
                ///
                /*
                 * 
               if (percentdestroyed > 0) OldObj.DestroyedPercent = percentdestroyed;
                    if (timetofix_s > 0) OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timetofix_s);
                    if (TimetoUndestroy_UTC.HasValue) OldObj.TimeToUndestroy_UTC = TimetoUndestroy_UTC.Value;
                    if (TimeLastHit_UTC.HasValue) OldObj.LastHitTime_UTC = TimeLastHit_UTC.Value;    
             */

            }


    }


    //FOR BOMB EXPLOSIONS/Total up ordnance
    public void MO_HandlePointAreaObjectives(string title, double mass_kg, Point3d pos, AiDamageInitiator initiator)
    {
        //maddox.game.LandTypes landType = GamePlay.gpLandType(pos.x, pos.y);

        //For now, all things we handle below are on land, so if the land type is water we just
        //get out of here immediately
        //if (landType == maddox.game.LandTypes.WATER) return;  //Ok, doing ships & water type targets this doesn't really work.  So just X it out.

        //twcLogServer(null, "bombe 6", null);

        //So, if the damager is AI and damaging their own land area, we're not going to count it.
        //Reason is, some artillery continually hits the ground in the area where they're firing.

        //Console.WriteLine("main_PointArea_bomb");
        if (GamePlay == null) return;
        int terr = GamePlay.gpFrontArmy(pos.x, pos.y);
        if (initiator != null)
            if ( initiator.Player == null || initiator.Player.Name() == null) //It's AI        
                if (initiator.Actor != null && initiator.Actor.Army() == terr) return; //It's the same army as the territory that has been damaged
        


        bool blenheim = false;
        string acType = "";
        if (initiator != null)
        {
            AiAircraft aircraft = initiator.Actor as AiAircraft;
            acType = Calcs.GetAircraftType(aircraft);

        }
        if (acType.Contains("Blenheim")) blenheim = true;

        double aircraftCorrection = 1;

        //so these are all compared with a JU88 which carries 4X250kg + 28X50KG which is 2400kg or 5291 lb.
        //So these correction figures bring all these bombers up to par with the JU88 as far as kg-tonnage is concerned.
        //The JU88 will still be quite a lot more effective because it is actually dropping the 32 bombs & so hitting for more things over a wider area, more statationaries killed etc.
        //but this at least brings them to parity on the tonnage issue.  In real WWII British & German bombers were roughly on par.

        if (acType.Contains("Blenheim") || acType.Contains("Hurricane")) aircraftCorrection = 4.4;  //IV & IV late carry 4*250lb bombs plus 18x40lb bombs.  1200 poundds altogether
        if (acType.Equals("BlenheimMkI")) aircraftCorrection = 5.28;  //MkI carries just 4x250lb bombs, vs regular MkIV & IV_late care 1200lb bombs.  So 6/5* the regular Blenheim correction factor
        if (acType.Contains("Wellington")) aircraftCorrection = 2.6455; //Wellington carries 8X250lb bombs, so 2000lb altogether.
        if (acType.Contains("He-111")) aircraftCorrection = 1.5;
        if (acType.Contains("BR-20")) aircraftCorrection = 2;

        mass_kg = mass_kg * aircraftCorrection;

        DateTime currTime_dt = DateTime.UtcNow;
        double repairSpeedupFactor = 1;        

        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];
            if (mo.MOTriggerType != MO_TriggerType.PointArea || !mo.IsEnabled) continue;
            //if (mo.OrdnanceRequiredToTrigger_kg == 0) continue; //0 means, don't use ordinance KG to determine destruction [nevermind, we can still track it even though not actively using it.  If 0
            double dist = Calcs.CalculatePointDistance(pos, mo.Pos);
            if ( dist > mo.radius) continue;
            double oldOONTkg = mo.OrdnanceOnTarget_kg;

            MO_addInitiatorToListOfPlayersWhoContributed(initiator, mo);

            if (dist > mo.TriggerDestroyRadius) mass_kg *= 0.333; //less damage effectiveness if inside radius but outside triggerradius
            mo.OrdnanceOnTarget_kg += mass_kg;
            mo.LastHitTime_UTC = DateTime.UtcNow;

            if (MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy].ContainsKey("RepairCrewEndTime_dt") && MissionObjectivesTimes[(ArmiesE)mo.OwnerArmy]["RepairCrewEndTime_dt"] > currTime_dt) repairSpeedupFactor = 4;

            double divisor = 1;
            if (mo.OrdnanceRequiredToTrigger_kg > 0  && mo.ObjectsRequiredToTrigger_num > 0) divisor = 2; //If both objects & KG required to trigger, we give each of them 50% of the required 100% for destruction.

            //So this is a bit complicated, but percentage destroyed due to ordinance & KG can't go above 50% UNLESS the other type of objective is completed also.
            //The prevents, ie, showing 125% destroyed purely by bombing KG, when 0 of the 10 required targets have been killed.
            //In that case it will show 50% complete, not 125%
            //Now, once both sides are complete (KG & objects) then additional KG or objects killed will add more percent
            double dst_pc_ord = 0;
            if (mo.OrdnanceRequiredToTrigger_kg> 0) dst_pc_ord = mo.OrdnanceOnTarget_kg / mo.OrdnanceRequiredToTrigger_kg / divisor;
            double dst_pc_obj = 0;
            if (mo.ObjectsRequiredToTrigger_num > 0) dst_pc_obj= mo.ObjectsDestroyed_num / mo.ObjectsRequiredToTrigger_num / divisor;

            if (dst_pc_obj > 0.5 && mo.OrdnanceRequiredToTrigger_kg > mo.OrdnanceOnTarget_kg) dst_pc_obj = 0.5;

        //So if the KG requirement has been met, but not the OBJ requirement, we cap the KG contribution to the % total at 50%.  Except . . . if the KG contribution
        //goes over 100% then we start to add it back in at 1/3 rate.
        if (dst_pc_ord > 0.5 && mo.ObjectsDestroyed_num < mo.ObjectsRequiredToTrigger_num)
        {
            double orig_dst_pc_ord = dst_pc_ord;
            dst_pc_ord = 0.5;
            double add_dst_pc_ord = 0;
            if (mo.OrdnanceRequiredToTrigger_kg > 100 && orig_dst_pc_ord > 1) add_dst_pc_ord = (orig_dst_pc_ord - 0.5) / 3;
            dst_pc_ord += add_dst_pc_ord;
        }

        double oldDestroyedPercent = mo.DestroyedPercent;
            mo.DestroyedPercent = dst_pc_obj + dst_pc_ord;

            Console.WriteLine("PointArea Ordnance: {0:F0}% objects, {1:F0}% KG, {2:F0}% Tot, {3:F0} KG KGreq: {4:F0} Numreq: {5:F0} {6}", dst_pc_obj * 100, dst_pc_ord * 100, mo.DestroyedPercent * 100, mo.OrdnanceOnTarget_kg, mo.OrdnanceRequiredToTrigger_kg, mo.ObjectsRequiredToTrigger_num, mo.Name);

            //if ((!mo.Destroyed || !mo.ObjectiveAchievedForPoints) && mo.ObjectsDestroyed_num >= mo.ObjectsRequiredToTrigger_num && mo.OrdnanceOnTarget_kg >= mo.OrdnanceRequiredToTrigger_kg)
            if ((!mo.Destroyed || !mo.ObjectiveAchievedForPoints) && mo.DestroyedPercent >= 1)
                    MO_DestroyObjective(ID, true, percentdestroyed: mo.DestroyedPercent, timetofixFromNow_sec: mo.TimetoRepairIfDestroyed_hr*3600/repairSpeedupFactor); //Note - MUST use >= here as it covers the case where ordnanceKG and/or object_numrequired = 0
            else if (mo.DestroyedPercent > 100 && mo.OrdnanceRequiredToTrigger_kg > 0)
            {                
                mo.DestroyedPercent = 1 + (mo.OrdnanceOnTarget_kg - mo.OrdnanceRequiredToTrigger_kg) / mo.OrdnanceRequiredToTrigger_kg / 4.0;  // so if it's above 100% destroyed additional bombs/ordnance still add more "dead points" but not as many/ assuming much of it is already destroy, so like 1/4 as much.
                double timeToFix_hr = (mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent);
                if (mo.TimeToUndestroy_UTC.HasValue) mo.TimeToUndestroy_UTC.Value.AddHours(mo.TimetoRepairIfDestroyed_hr * mass_kg / mo.OrdnanceRequiredToTrigger_kg / 4.0/ repairSpeedupFactor);  //just add time proportional to this particular bomb's kg.  But divided by 4 since we are discounting the destruction
                else mo.TimeToUndestroy_UTC = DateTime.UtcNow.AddHours(mo.TimetoRepairIfDestroyed_hr * mo.DestroyedPercent/repairSpeedupFactor);
                MO_DestroyObjective_addTime(ID, percentdestroyed: mo.DestroyedPercent);
            } else if (Math.Floor(oldDestroyedPercent * 100.0 / 25.0) % 2 != Math.Floor(mo.DestroyedPercent * 100.0 / 25.0) % 2) //if crossing threshold @ 25, 50, 75% give a message with status update of objective
            {
                twcLogServer(null, "{0} damaged: {1}% destroyed, {2} items damaged, {3} kg on target", new object[] { mo.Name, (mo.DestroyedPercent * 100).ToString("F0"), mo.ObjectsDestroyed_num.ToString("F0"), mo.OrdnanceOnTarget_kg.ToString("F0") });
            }
            ///!!!!!!!!!!!!!!!!!!! might still need ot do more things here, check the missionobjectives class.
            ///
            /*
             * 
           if (percentdestroyed > 0) OldObj.DestroyedPercent = percentdestroyed;
                if (timetofix_s > 0) OldObj.TimeToUndestroy_UTC = DateTime.UtcNow.AddSeconds(timetofix_s);
                if (TimetoUndestroy_UTC.HasValue) OldObj.TimeToUndestroy_UTC = TimetoUndestroy_UTC.Value;
                if (TimeLastHit_UTC.HasValue) OldObj.LastHitTime_UTC = TimeLastHit_UTC.Value;    
         */

        }


    }

    public void MO_makeAllObjectivesScoutedFromPos(Point3d pos, Player player)
    {
        foreach (string ID in MissionObjectivesList.Keys)
        {
            MissionObjective mo = MissionObjectivesList[ID];
            mo.makeScoutedFromHit(pos, player); //makes the mo scouted if this hit is near the mo, less than 2k.  So will work for any hit like a bomb drop or killing a stationary or actor
        }
    }

    /******************************************************************************************************************** 
    * ****END****MISSION OBJECTIVES CLASSES & METHODS
    * **********************************************************************************************************************/


    //TOBRUK the map seems too busy.  So we cull the regular/hourly AI raids.
    //These have special name that ENDS WITH "HR" or "hr".  These denote hourly or timed raids.

    public bool tobrukCullAI(string triggername)
    {
        int nump = Calcs.gpNumberOfPlayers(GamePlay);
        Console.WriteLine("tobrukCullAI: " + nump.ToString() + " players currently online");


        if (!triggername.ToLower().EndsWith("hr")) return false; //Check if the trigger/action name ends with "hr" or "HR" or "Hr".  This denotes regular timed raids.

        //To reduce excessive random AI aircraft in Tobruk.
        //Usually keep just 33% of triggers.  However if a BUMRUSH is active keep only 10%.  
        //9/26/2020, adjusted to 60/25
        int pctToKeep = 60;
        if (MO_BRBumrushActive()) pctToKeep = 25;

        if (random.Next(100) > pctToKeep)
        {
            Console.WriteLine("stopAI: Stopping AI Trigger/cutting Tobruk triggers (NAME ENDING IN \"Hr\" {0}% to reduce excess traffic", 100-pctToKeep);
            return true;
        }


        Console.WriteLine("stopAI: NOT stopping AI Trigger/too few players online & NOT stopped by Tobruk special cull");
        return false;

    }

    //return TRUE if this action has been called within the past time_min minutes
    //otherwise FALSE.
    //Used to prevent actions from being called too frequently.  IE a trigger in the .mis that runs every time a player flies through a certain zone    
    
    Dictionary<string, DateTime> recentlyCalledActions_dict = new Dictionary<string, DateTime>();

    public bool recentlyCalled( string shortName, double time_min = 60)
    {
        if (!recentlyCalledActions_dict.ContainsKey(shortName))
        {
            recentlyCalledActions_dict[shortName] = DateTime.UtcNow;
            return false;
        }
        TimeSpan sinceCalled = DateTime.UtcNow - recentlyCalledActions_dict[shortName];
        recentlyCalledActions_dict[shortName] = DateTime.UtcNow;
        if (sinceCalled.TotalMinutes < time_min) return true;
        return false;
    }
        //return TRUE if AI spawns should be stopped bec of too many players
        //FALSE if AI/trigger missions can continue
        public bool stopAI()
    {        
        int nump = Calcs.gpNumberOfPlayers(GamePlay);

        //For TOBRUK< keeping the raids going when noi players online, because  they are multi-hour raids & when players do come in, there will be something going on.
        /*
        Console.WriteLine("stopAI: " + nump.ToString() + " players currently online");
        if (nump == 0 && !ON_TESTSERVER)
        {
            Console.WriteLine("stopAI: Stopping AI Trigger NO players online");
            return true;
        }
        */
        if (nump > 80 || (nump > 60 && random.NextDouble() > 0.65) || (nump > 40 && random.NextDouble() > 0.2))
        {
            Console.WriteLine("stopAI: Stopping AI Trigger/too many players online");
            return true;
        }    


        Console.WriteLine("stopAI: NOT stopping AI Trigger/too few players online & NOT stopped by Tobruk special cull");
        return false;

    }

    //The generic ONTRIGGER code often used to trigger all actions whenever a trigger is called
    /*
        public override void OnTrigger(int missionNumber, string shortName, bool active)
        {
            base.OnTrigger(missionNumber, shortName, active);
        Console.WriteLine("OnTrigger: Received trigger " + shortName + " mission#: " + missionNumber + " active: "+active.ToString());
        //AiAction action = GamePlay.gpGetAction(ActorName.Full(missionNumber, shortName));
        AiAction action = GamePlay.gpGetAction(shortName);
        if (action != null && active)
        {
            Console.WriteLine("OnTrigger: Activating action " + shortName + " from trigger " + shortName + " mission#: " + missionNumber);
            action.Do();
        }




            //AiAction action = GamePlay.gpGetAction(ActorName.Full(missionNumber, shortName));
            //if (action != null)
            //{
            //    action.Do();
            //}

        }
    */



    /*********************************************************************************************************************
     * *******************************************************************************************************************
     * ONTRIGGER
     * 
     * Handle bombing/objective destruction triggers as well as
     * triggers that launch various air raids and other events
     * 
     * In an action entry, the "1" indicates the action is enabled - 0 means disabled.  If set to disabled, then (it appears?)
     * the action wont activate if you call it.
     * 
     *  [Action]
     *    action1 ASpawnGroup 1 BoB_LW_KuFlGr_706.03    <--- WILL RUN
     *    action2 ASpawnGroup 0 BoB_LW_KuFlGr_706.04    <--- WILL ***NOT*** RUN!!!!
     * 
     * In OnTrigger, we can trigger any action if we know its name via action.Do() - it doesn't need to be the associated action in the .mis file
     * 
     * If there is no .cs file, CloD will automatically .Do() the action with the exact same name as the trigger when the trigger is called and the action is enabled. 
     * However, if you have .cs file then you must include OnTrigger include a bit of code to manually call the action with the same name as the trigger.  That is 
     * included below in the 'else' portion of the method.
     * 
     * You can call actions at any time; you don't need to rely on the trigger to set it off.  You only need to know the exact name of the 
     * trigger from the .mis file Sample:
     * 
     *      AiAction action = GamePlay.gpGetAction(tr);
     *      if (action != null) action.Do();
     * 
     * You can also call a Trigger at any time using this sample code:
     *             
     *             if (GamePlay.gpGetTrigger(tr) != null ) { 
     *                 GamePlay.gpGetTrigger(tr).Enable = true; //only needed if you want to be sure the Trigger is enabled               
     *                 Battle.OnEventGame(GameEventId.Trigger, tr, true, 1);
     *             }
     *             
     * You can call both triggers and actions from any mission--either the main mission file or any sub-mission loaded via gpPostMissionLoad.
     * You only need the EXACT name from the .mis file.
     *             
     * Also Timers should be named as timers with the time to launch in the title to avoid confusion
     * 
     * TGroundDestroyed type triggers ONLY DETECT OBJECTS KILLED if they are labelled as de or gb.  The nn objects are simply not counted.
     * 
     * 
     * ****************************************************************************************************************/
    string lastTrigger = "";

    //  First triggers are convoys*************************************************
    public override void OnTrigger(int missionNumber, string shortName, bool active)
    //public void bartOnTrigger(int missionNumber, string shortName, bool active)
    {
        base.OnTrigger(missionNumber, shortName, active);
        Console.WriteLine("OnTrigger: " + shortName + " " + missionNumber.ToString() + " Active: " + active.ToString());

        //So, we're getting the submission triggers twice ?!?
        //We'll stop it from double-triggering for 5 seconds

        string newTrigger = missionNumber.ToString() + ":" + shortName;

        bool res;

        if (lastTrigger != newTrigger)  res = MO_DestroyObjective(shortName, active);

        lastTrigger = newTrigger;
        Timeout(5, () => { lastTrigger = ""; });  //Just stop it from re-triggering for 5 seconds

        //Console.WriteLine("OnTrigger: " + shortName + " Active: " + active.ToString() + " MO_DestroyObjective result: " + res.ToString());


        //Console.WriteLine("OnTrigger: Now doing ActionTriggers: " + shortName + " Active: " + active.ToString() + " !stopAI()=" + (!stopAI()).ToString() + " zonedef: " + ("zonedefenseblue1".Equals(shortName) && active && !stopAI()).ToString());  

        ///Timed raids into enemy territory////////////////////////// using the action part of the trigger//

        //if you want any patrols etc to continue running even when the server is full of live players, just remove the  && !stopAI() of that trigger
        //stopAI will slow down AI patrols with 40 players online and stop them at 50 (adjustable above).
		//Begin convoys for both sides with pass thru zones
/*	
	
"Rouen_2_Lehavre",				       "Panzer_2_Calais",			
"Rouen_2_Brombos",				       "Opel_BlitzFuel1",			
"Dieppe_2_Lehavre",				       
"Bernay_2_Hornfleur",			       "Dunkirk_2_GrandFort",		
"Beaumont_2_Forges",			       "Onkel_Albert_Staff_Car",	
"Lehavre_2_Forges",				       "LeTreport_fuel_Convoy",	
"FuelBeauvis_2_Nuefchatel",		       "Abbeville_2_PoixDePicard",	
"Huate_from_Dieppe",			       "Amiens_2_MontDidiear",		
"Clermont_2_Dieppe",			       "Arras_2_WallyBeaucamp",	
"Opel_Blitz_fuel_1",			       "GER_Fuel_Column_1",		
"Rouen_2_Dieppe2",				       "GER_Fuel_Column_2",		
"Stelling_to_Dunkirk		       "GER_Fuel_Column_3",		
"General_Tiny_Barber",			
"Rouen_Fuel_Convoy_2Dieppe",	
"Les_Andeleys_2_Brombos",		
"Axis_War_Plans",				
	
*/		
        if ("Convoy_Timer1_10min".Equals(shortName) && active )//Ai activity reguardless of number of players
		
        {
            AiAction action = GamePlay.gpGetAction("Rouen_2_Lehavre");//Chief_0


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, " Rouen_2_Lehavre Convoy Launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
		}
        else if ("Convoy_Timer2_11min".Equals(shortName) && active )//Ai activity reguardless of number of players
		
        {
            AiAction action = GamePlay.gpGetAction("Panzer_2_Calais");//Chief_0


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(15, () => sendScreenMessageTo(1, " Panzer_2_Calais Convoy Launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
		}		
        else if ("Timer3_30min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Rouen_2_Brombos");//Chief_1


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Rouen_2_Brombos convoy launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer4_31min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Opel_Blitz_fuel_1 ");//Chief_10
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Abbeville .Ligescourt Cramont area refueling", null));			
          //  Timeout(3600, () => sendScreenMessageTo(2, "Rouen Fighters restset...Check time", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }		
        else if ("Timer5_45min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Dieppe_2_Lehavre");//Chief_2


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Dieppe to Le Havre Convoy launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Beckton_Sewage".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
        //    AiAction action = GamePlay.gpGetAction("Dieppe_2_Lehavre");//Chief_2


       //     if (action != null)
       //     {
       //         action.Do();
       //         Console.WriteLine("Triggered action " + action.Name);
       //     }
            Timeout(10, () => sendScreenMessageTo(2, "Beckton Sewage Treatment facility Destroyed", null));
            Timeout(20, () => sendScreenMessageTo(2, "Crap everywhere", null));
            Timeout(10, () => sendScreenMessageTo(1, "Beckton Sewage Treatment facility Destroyed,", null));
	        Timeout(20, () => sendScreenMessageTo(1, "Crap everywhere 3 sheets in the wind", null));		
		  GamePlay.gpGetTrigger(shortName).Enable = false;
		}
        else if ("D_Sewage".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
        //    AiAction action = GamePlay.gpGetAction("Dieppe_2_Lehavre");//Chief_2


       //     if (action != null)
       //     {
        //        action.Do();
        //        Console.WriteLine("Triggered action " + action.Name); 
       //     }
            Timeout(10, () => sendScreenMessageTo(2, "Sewage Treatment facility Destroyed in Dunkirk", null));
            Timeout(20, () => sendScreenMessageTo(2, "Crap everywhere ", null));
            Timeout(10, () => sendScreenMessageTo(1, "Allied Effort results in destruction of a sewage plant in Dunkirk,", null));
	        Timeout(20, () => sendScreenMessageTo(1, "Crap everywhere", null));		
		  GamePlay.gpGetTrigger(shortName).Enable = false;
		}		
        else if ("Timer6_46min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Dunkirk_2_GrandFort");//Chief_12


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Dunkirk_2_GrandFort Convoy launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
          //  GamePlay.gpGetTrigger(shortName).Enable = false;
        }		
        else if ("Timer7_60min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Bernay_2_Hornfleur");//Chief_3


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
           Timeout(10, () => sendScreenMessageTo(1, "Bernay_2_Hornfleur Convoy launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer8_61min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Onkel_Albert_Staff_Car");//Chief_14


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(40, () => sendScreenMessageTo(1, "German General on Inspection", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer9_90min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Beaumont_2_Forges");//Chief_4


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Beaumont_2_Forges Convoy launched", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }		
        else if ("Timer10_91min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("LeTreport_fuel_Convoy");//Chief_17


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "LeTreport_fuel_Convoy launched", null));
        //    Timeout(10, () => sendScreenMessageTo(1, "Friendly Resupply Convoy Spotted AC 6 headed to Carquebut area Someone check for vehicle spawn please", null));
            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }		
        else if ("Timer11_95min".Equals(shortName) && active && !stopAI())// Trigger F1e launches escorts to go with Do 17s from trigger F1 above
        {
            AiAction action = GamePlay.gpGetAction("Lehavre_2_Forges");//Chief_5


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
       Timeout(10, () => sendScreenMessageTo(2, "Critical Fuel Supplies Lehavre_2_Forges", null));
       Timeout(10, () => sendScreenMessageTo(1, "Friendly  Fuel Supplies Flowing Lehavre_2_Forges ", null));	   
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer12_96min".Equals(shortName) && active && !stopAI())// Trigger F1e launches escorts to go with Do 17s from trigger F1 above
        {
            AiAction action = GamePlay.gpGetAction("Abbeville_2_PoixDePicard");//Chief_19


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
       Timeout(10, () => sendScreenMessageTo(1, "Enemy Tanks Spotted Abbeville to Poix Nord", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer13_120min".Equals(shortName) && active && !stopAI())// Trigger F1c launches escorts to go with escorts from trigger F1e above
        {
            AiAction action = GamePlay.gpGetAction("FuelBeauvis_2_Nuefchatel");//Chief_6


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
			 Timeout(10, () => sendScreenMessageTo(1, "Fuel Supplies Beauvis to Nuefchatel", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer14_121min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Amiens_2_MontDidiear");//Chief_20
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Supplies from Amiens to Mt. Didiear.", null));
          //  Timeout(600, () => sendScreenMessageTo(2, "Wellingtons have been spotted over Dymchurch at 6000m heading east!!!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer15_125min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Huate_from_Dieppe");//Chief_7
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Supplies from Huate_from_Dieppe.", null)); 
         //    Timeout(600, () => sendScreenMessageTo(1, "Ju88s have been spotted over Oye-Plage @ 20K ft. heading west!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
		}	
        else if ("Timer16_126min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Arras_2_WallyBeaucamp");//Chief_21
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
 
            Timeout(60, () => sendScreenMessageTo(1, "Arras_2_WallyBeaucamp Supplies moving now!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;			
        }
        else if ("Timer17_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Clermont_2_Dieppe");//Chief_8
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

            Timeout(60, () => sendScreenMessageTo(2, "Clermont_2_Dieppe fuel supplies Spotted!!!.", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("Timer18_181min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("GER_Fuel_Column_1");//Chief 22
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(60, () => sendScreenMessageTo(2, "Liegescourt area fuel supplies Spotted!!!.", null));
        }
        else if ("Timer19_210min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Stelling_to_Dunkirk");//Chief_13
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(60, () => sendScreenMessageTo(2, "Stelling_to_Canterbury Dunkirk area in Britain moving now ", null));
        }		
       else if ("Timer20_211min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("GER_Fuel_Column_2");//Chief_
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
           Timeout(60, () => sendScreenMessageTo(1, " St omar to Colembert", null));
        }
       else if ("Timer21_240min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("General_Tiny_Barber");//Chief_23
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Scotish General touring front lines Le Havre to Dieppe.", null));
        }
				
        else if ("Timer22_241min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("GER_Fuel_Column_3");//Chief_24
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Fuel Supplies movingAbbeville to Arras!", null));
         //   Timeout(600, () => sendScreenMessageTo(2, "An eastbound formation of Wellingtons have been spotted over St. Mary's Bay @ 6km!", null));
        }
       else if ("Timer23_270min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Rouen_Fuel_Convoy_2Dieppe");//Chief_16
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Rouen_Fuel_Convoy_2Dieppe", null));
        //    Timeout(600, () => sendScreenMessageTo(1, "He-111s have been spotted over Calais @ 14K ft. heading west!", null));
        }
        else if ("Timer24_271min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Les_Andeleys_2_Brombos");//Chief_18
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Les_Andeleys_2_Brombos fuel trucks heading out.", null));
        }
        else if ("Timer25_300min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Axis_War_Plans");//Chief_25
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Enemy has our battle plans single vehicle BD5 to AY8", null));
          Timeout(30, () => sendScreenMessageTo(2, "Destroy the Vehicle with the plans!!", null));
        }
        else if ("Timer24_271min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Rouen_2_Dieppe2");//Chief_13
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Rouen_2_Dieppe2 fuel trucks heading out.", null));
        }

//Aircraft timers

		else if ("ATimer2_60min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("110_Escort_2_London");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
        //    Timeout(10, () => sendScreenMessageTo(1, "Heavy enemy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }	
        else if ("ATimer2_60min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("110_Escort_2_London");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
        //    Timeout(10, () => sendScreenMessageTo(1, "Heavy enemy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer2_60min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("109_Escort_2_London");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
         //   Timeout(10, () => sendScreenMessageTo(1, "Heavy enemy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }	
        else if ("ATimer1_60min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("Heavy_Bomber_Raid_2");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "#2 Heavy enemy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
          //  GamePlay.gpGetTrigger(shortName).Enable = false;
        }		
        else if ("ATimer1_210min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("110_Escort_2_London");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
          //  Timeout(10, () => sendScreenMessageTo(1, "#2 Heavy enemy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_210min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("109_Escort_2_London");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(40, () => sendScreenMessageTo(1, "Heavy raid with escorts moving North!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_210min".Equals(shortName) && active )//Ai activity reguardless of number of players
        {
            AiAction action = GamePlay.gpGetAction("109_late_raid_Jabo");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "109s heading north from moving Northwest from Merville!", null));

            
        //    Timeout(15, () => sendScreenMessageTo(1, " Testing...Do 17s have been spotted  east Calais @ 4000m heading west! Check for Escorts", null));
            GamePlay.gpGetTrigger(shortName).Enable = false;
        }		

        else if ("Timer_Convoy_Britian".Equals(shortName) && active && !stopAI())// Trigger F1e launches escorts to go with Do 17s from trigger F1 above
        {
            AiAction action = GamePlay.gpGetAction("TimedPanzerConvoy");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
       Timeout(10, () => sendScreenMessageTo(1, "Enemy Tanks Spotted AS 1 heading West", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_60min".Equals(shortName) && active && !stopAI())// Trigger F1c launches escorts to go with escorts from trigger F1e above
        {
            AiAction action = GamePlay.gpGetAction("StukaRaid");


            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_120min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("StukaRaid");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "test of timed operation.", null));
          //  Timeout(600, () => sendScreenMessageTo(2, "Wellingtons have been spotted over Dymchurch at 6000m heading east!!!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("StukaRaid2");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
 
         //    Timeout(600, () => sendScreenMessageTo(1, "Ju88s have been spotted over Oye-Plage @ 20K ft. heading west!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
		}	
        else if ("ATimer1_270min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("StukaRaid3");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
 
         //    Timeout(600, () => sendScreenMessageTo(1, "Ju88s have been spotted over Oye-Plage @ 20K ft. heading west!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;			
        }
        else if ("ATimer2_31min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Interior_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

         //   Timeout(600, () => sendScreenMessageTo(2, "A formation of eastbound Blenheims have been spotted over Lympe at 6000m!!!.", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer2_90min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Interior_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

        }
        else if ("ATimer1_240min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(600, () => sendScreenMessageTo(1, "Activity reported along Somme.", null));
        }		
       else if ("ATimer1_60min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");// every hour
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

        }
       else if ("ATimer1_120min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");//hour 2
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

        }
				
        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");//hour 3
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
         //   Timeout(10, () => sendScreenMessageTo(1, "Testing Somme Patrol Note time please", null));
         //   Timeout(600, () => sendScreenMessageTo(2, "An eastbound formation of Wellingtons have been spotted over St. Mary's Bay @ 6km!", null));
        }
       else if ("ATimer1_240min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");//4 hrs
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Enemy aircraft reported along Somme.", null));
        //    Timeout(600, () => sendScreenMessageTo(1, "He-111s have been spotted over Calais @ 14K ft. heading west!", null));
        }
        else if ("ATimer1_300min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Somme_Patrol");//Somme patrol at 5 hours
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
          //  Timeout(10, () => sendScreenMessageTo(1, "Testing Somme #3  Patrol Note time please.", null));
        }
        else if ("ATimer1_60min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("  Timed_B_Front_Patrol");//60 min after start second front patrol of 109's
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Fighters near front lines", null));
        //  Timeout(600, () => sendScreenMessageTo(2, "Our Fighters covering front lines", null));
        }		
        else if ("ATimer1_90min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Front_Patrol2");//90 min after start second front patrol then again every 90 min
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Fighters near front lines", null));
        //  Timeout(600, () => sendScreenMessageTo(2, "Our Fighters covering front lines", null));
        }
        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Front_Patrol3");// second 110 patrol 180 min later
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Beware of front line fighters!", null));
          Timeout(600, () => sendScreenMessageTo(2, "Again our fighters cover he front lines", null));
        }
        else if ("ATimer1_270min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_B_Front_Patrol4");// 3rd patrol of front using different aircraft
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Air trafic increase near front lines!", null));
            Timeout(600, () => sendScreenMessageTo(2, "Last flight of our fighters headed to front lines!", null));
        }
          else if ("ATimer1_92min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("StukaRaid2");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Heavy Stuka raid on front lines Escorts needed Launching Freecamp Now!!!.", null));
            Timeout(600, () => sendScreenMessageTo(1, "Activity in Le Havre Area!!", null));
        }
        else if ("ATimer1_95min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Blenhiem_Raid2");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(1, "Blenheims requesting escort. Heading to Rouen Fuel targets low and fast", null));
        //    Timeout(600, () => sendScreenMessageTo(2, "A formation of eastbound Blenheims have been spotted over Lympne at 6000m!!!.", null));
        }
        else if ("ATimer3_120min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Blenhiem_Raid3");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }
            Timeout(10, () => sendScreenMessageTo(2, "Spies report Blenheim aircraft heading East toward Rouen.", null));
        //    Timeout(600, () => sendScreenMessageTo(1, "BR.20Ms have been spotted over Boulogne @ 13K ft. heading west!", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_300min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Blenhiem_Raid");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
       else if ("Timer3_90min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_Rouen_Diep_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_Rouen_Diep_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

       //     Timeout(600, () => sendScreenMessageTo(1, "testing ", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }

        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_Rouen_Diep_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

         //   Timeout(600, () => sendScreenMessageTo(1, "testing ", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }			

        else if  ("ATimer1_30min".Equals(shortName) && active && !stopAI())
        {
			AiAction action = GamePlay.gpGetAction("Cher_Cover_Hi");
			if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

        //    Timeout(600, () => sendScreenMessageTo(1, "testing cher hi patrol", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
        else if ("ATimer1_180min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("Timed_Rouen_Diep_Patrol");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

        //    Timeout(600, () => sendScreenMessageTo(1, "testing ", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }
	        else if ("ATimer1_270min".Equals(shortName) && active && !stopAI())
        {
            AiAction action = GamePlay.gpGetAction("109_Escort_2_London");
            if (action != null)
            {
                action.Do();
                Console.WriteLine("Triggered action " + action.Name);
            }

            Timeout(600, () => sendScreenMessageTo(1, "Heavy Bomber Raid  heading West w/escorts", null));
            //GamePlay.gpGetTrigger(shortName).Enable = false;
        }			
  
        else
        {
            //This final ELSE ensures that any other triggers in the mission file (ie time triggers)
            //that have an action with matching name, and that are not handled individually in the code above
            //will still activate their triggers
            //
            //This way you can EITHER handle triggers & actions individually using code above, OR just
            //enter triggers & actions with exactly matching names in the .mis file (including submission files loaded later)
            //and they will still work.

            Console.WriteLine("OnTrigger: Received trigger " + shortName + " mission#: " + missionNumber);
            //AiAction action = GamePlay.gpGetAction(ActorName.Full(missionNumber, shortName));
            if (active) execAction(shortName, "OnTrigger");

        }



    }  //End OnTrigger

    public void execAction(string shortName, string origin = "") {
        
        AiAction action = GamePlay.gpGetAction(shortName);
        
        bool stopai = stopAI();
        bool tcull = tobrukCullAI(shortName);
        bool rcall = recentlyCalled(shortName, 60);
        
        if (action != null && !stopai && !tcull && !rcall)

        {
            Console.WriteLine(origin +": Activating action " + shortName + " from trigger " + shortName);
            action.Do();
        }  else
        {
            Console.WriteLine(origin + ": Skipping action " + shortName + " because null: {0} many players: {1} tobrukCull: {2} toorecentlycalled: {3} ", action==null, stopai, tcull, rcall);
        }
    }

//Save results to file that will be read by the WatchDog program.  1= red win, 2 = blue win, 3= tie
public bool WriteResults_Out_File(string result = "3")
    {
        try
        {
            if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("MXX4 " + DateTime.UtcNow.ToString("T")); //Testing for potential causes of warping
            using (StreamWriter file = new StreamWriter(RESULTS_OUT_FILE, false))
            {
                file.WriteLine(result);
            }
            //Console.WriteLine("WriteResults_Out_File - file & contents: " + RESULTS_OUT_FILE + " " + result);
            return true;

        }
        catch (Exception ex)
        {

            Console.WriteLine("WriteResults_Out_File( - Error writing Mission RESULTS_OUT_FILE: " + RESULTS_OUT_FILE + " " + ex.Message);
            return false;

        }
    }


} //class mission : amission



//Various helpful calculations & formulas
public static class Calcs
{

    private static Random clc_random = new Random();

    public static double distance(double a, double b)
    {

        return (double)Math.Sqrt(a * a + b * b);

    }

    public static double meters2miles(double a)
    {

        return (a / 1609.344);

    }

    public static double meterspsec2milesphour(double a)
    {
        return (a * 2.23694);
    }

    public static double meters2feet(double a)
    {

        return (a / 1609.344 * 5280);

    }
    public static double feet2meters(double a)
    {

        return (a * 1609.344 / 5280);

    }
    public static double DegreesToRadians(double degrees)
    {
        return degrees * (Math.PI / 180.0);
    }
    public static double RadiansToDegrees(double radians)
    {
        return radians * (180.0 / Math.PI);
    }
    public static double CalculateGradientAngle(
                              Point3d startPoint,
                              Point3d endPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = endPoint.x - startPoint.x;
        double diffY = endPoint.y - startPoint.y;

        //Calculates the Tan to get the radians (TAN(alpha) = opposite / adjacent)
        //Math.PI/2 - atan becase we need to change to bearing where North =0, East = 90 vs regular math coordinates where East=0 and North=90.
        double radAngle = Math.PI / 2 - Math.Atan2(diffY, diffX);

        //Converts the radians in degrees
        double degAngle = RadiansToDegrees(radAngle);

        if (degAngle < 0)
        {
            degAngle = degAngle + 360;
        }

        return degAngle;
    }
    //Equal in x & y, ignoring z
    public static bool Point3dEqualXY(
                              Point3d p1,
                              Point3d p2)
    {
        if (p1.x != p2.x || p1.y != p2.y) return false;
        else return true;

    }
    //Could make an extension method for this, or something?  Instead?  But this works:
    public static bool Point3dEqual(
                              Point3d p1,
                              Point3d p2)
    {
        if (p1.x != p2.x || p1.y != p2.y || p1.z != p2.z) return false;
        else return true;

    }
    //Could make an extension method for this, or something?  Instead?  But this works:
    public static bool Point3dEqual(
                              Vector3d p1,
                              Point3d p2)
    {
        if (p1.x != p2.x || p1.y != p2.y || p1.z != p2.z) return false;
        else return true;

    }
    //Could make an extension method for this, or something?  Instead?  But this works:
    public static bool Point3dEqual(
                              Point3d p1,
                              Vector3d p2)
    {
        if (p1.x != p2.x || p1.y != p2.y || p1.z != p2.z) return false;
        else return true;

    }
    //Could make an extension method for this, or something?  Instead?  But this works:
    public static bool Point3dEqual(
                              Vector3d p1,
                              Vector3d p2)
    {
        if (p1.x != p2.x || p1.y != p2.y || p1.z != p2.z) return false;
        else return true;

    }

    public static double CalculatePointDistance(
                              Point2d startPoint,
                              Point3d endPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(endPoint.x - startPoint.x);
        double diffY = Math.Abs(endPoint.y - startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                              Point2d startPoint,
                              Point2d endPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(endPoint.x - startPoint.x);
        double diffY = Math.Abs(endPoint.y - startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                              Point3d startPoint,
                              Point3d endPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(endPoint.x - startPoint.x);
        double diffY = Math.Abs(endPoint.y - startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                             Vector3d startPoint,
                             Vector3d endPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(endPoint.x - startPoint.x);
        double diffY = Math.Abs(endPoint.y - startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                              Point2d startPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(startPoint.x);
        double diffY = Math.Abs(startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                              Point3d startPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(startPoint.x);
        double diffY = Math.Abs(startPoint.y);

        return distance(diffX, diffY);
    }
    public static double CalculatePointDistance(
                             Vector3d startPoint)
    {
        //Calculate the length of the adjacent and opposite
        double diffX = Math.Abs(startPoint.x);
        double diffY = Math.Abs(startPoint.y);

        return distance(diffX, diffY);
    }
    //Given two points lp1 & lp2 that determine a line, what is the distance between single point sp and that line?
    //if ax + by + c = 0 is the line equation, distance is
    //abs(ax + by + c)/sqrt(a^2 + b^2)
    //It returns values +/-.  + value means, the point is to the right side of the line, looking down the line from p1 to p2
    // - value means, to the left side of that line

    public static double PointToLineDistance(Point2d linePoint1, Point2d linePoint2, Point3d singlePoint)
    {
        return PointToLineDistance(linePoint1, linePoint2, new Point2d(singlePoint.x, singlePoint.y));
    }

    public static double PointToLineDistance(Point2d linePoint1, Point2d linePoint2, Point2d singlePoint)
    {

        if (linePoint1.x == linePoint2.x && linePoint1.y == linePoint2.y) return CalculatePointDistance(singlePoint, linePoint1); //Two points the same, not a line, but we can calculate the point distance
                                                                                                                                  //if (lp1.x == lp2.x) return Math.Sign( lp2.y-lp1.y) * (sp.x - lp1.x);                                                                                                                
        double a = linePoint2.y - linePoint1.y;
        double b = -(linePoint2.x - linePoint1.x);
        double c = (-b * linePoint1.y) - a * linePoint1.x;

        return (a * singlePoint.x + b * singlePoint.y + c) / distance(a, b);  //This will be + or - depending on the orientation of the sp and lp1/lp2.  YOu can use the +/- to determine which side of the line it's on relative to vector lp1 -> lp2
    }
    /**
      * Calculates the point of interception for one object starting at point
      * <code>a</code> with speed vector <code>v</code> and another object
      * starting at point <code>b</code> with a speed of <code>s</code>.
      * 
      * @see <a
      *      href="http://jaran.de/goodbits/2011/07/17/calculating-an-intercept-course-to-a-target-with-constant-direction-and-velocity-in-a-2-dimensional-plane/">Calculating
      *      an intercept course to a target with constant direction and velocity
      *      (in a 2-dimensional plane)</a>
      * 
      * @param a
      *            start vector of the object to be intercepted
      * @param v
      *            speed vector of the object to be intercepted
      * @param b
      *            start vector of the intercepting object
      * @param s
      *            speed of the intercepting object
      * @return Point3d where x,y is vvector of interception & z is time; or <code>null</code> if object cannot be
      *         intercepted or calculation fails
      * 
      * @author Jens Seiler
      * http://jaran.de/goodbits/2011/07/17/calculating-an-intercept-course-to-a-target-with-constant-direction-and-velocity-in-a-2-dimensional-plane/   
      */
    public static Point3d calculateInterceptionPoint(Point3d a, Point3d v, Point3d b, double s)
    {
        double ox = a.x - b.x;
        double oy = a.y - b.y;

        double h1 = v.x * v.x + v.y * v.y - s * s;
        double h2 = ox * v.x + oy * v.y;
        double t;
        if (h1 == 0)
        { // problem collapses into a simple linear equation 
            t = -(ox * ox + oy * oy) / (2 * h2);
        }
        else
        { // solve the quadratic equation
            double minusPHalf = -h2 / h1;

            double discriminant = minusPHalf * minusPHalf - (ox * ox + oy * oy) / h1; // term in brackets is h3
            if (discriminant < 0)
            { // no (real) solution then...
                return new Point3d(0, 0, 0); ; ;
            }

            double root = Math.Sqrt(discriminant);

            double t1 = minusPHalf + root;
            double t2 = minusPHalf - root;

            double tMin = Math.Min(t1, t2);
            double tMax = Math.Max(t1, t2);

            t = tMin > 0 ? tMin : tMax; // get the smaller of the two times, unless it's negative
            if (t < 0)
            { // we don't want a solution in the past
                return new Point3d(0, 0, 0); ;
            }
        }

        // calculate the point of interception using the found intercept time and return it
        return new Point3d(a.x + t * v.x, a.y + t * v.y, t);
    }


    //methods below from http://forum.1cpublishing.eu/showthread.php?t=32402&page=27  5./JG27.Farber 
    #region Calculations
    public static int Meters2Angels(double altitude)
    {
        double altAngels = (altitude / 0.3048) / 1000;

        if (altAngels > 1)
            altAngels = Math.Round(altAngels, MidpointRounding.AwayFromZero);
        else
            altAngels = 1;

        return (int)altAngels;
    }
    public static int Feet2Angels(double altitude)
    {
        double altAngels = (altitude) / 1000;

        if (altAngels > 1)
            altAngels = Math.Round(altAngels, MidpointRounding.AwayFromZero);
        else
            altAngels = 1;

        return (int)altAngels;
    }

    public static int ToMiles(double distance)
    {
        double distanceMiles = 0;
        distanceMiles = Math.Round(((distance / 1609.3426)), 0, MidpointRounding.AwayFromZero);   // distance in Miles

        return (int)distanceMiles;
    }

    public static double AltitudeAGL_m(AiActor actor)
    {
        return AltitudeAGL_m(actor.Pos());

    }

    public static double AltitudeAGL_m(Point3d p)
    {
        //double height_m = maddox.core.WMesh.HeightMapMeshGetHeight(p.x, p.y);


        //TF_Extensions.TF_GamePlay.Effect smoke = TF_Extensions.TF_GamePlay.Effect.SmokeSmall;
        //TF_Extensions.TF_GamePlay.gpCreateEffect(gameplay, smoke, p.x, p.y, p.z, 1200);
        //double height_m = TF_Extensions.TF_GamePlay.gpLandHeightASL(gameplay, p.x, p.y);
        //double height_m = maddox.core.WMesh.HeightMapMeshGetHeight(p.x, p.y);
        //double height_m = maddox.core.WLandscape.cHQ_forestHeightHere((float)p.x, (float)p.y);
        double T = maddox.core.WLandscape.getWorldMapT(p.x, p.y);
        Console.WriteLine("T = " + T.ToString());
        double H = twcLandscape.H(p.x, p.y);
        Console.WriteLine("H = " + H.ToString());
        //        double height_m = XLAND.W_TLandscape.HQ(p.x, p.y);
        double height_m = LandElevation_m(p);

        //double height_m = 0;
        return (p.z - height_m);
    }
    public static double LandElevation_m(Point3d p)
    {

        double height_m = twcLandscape.HQ(p.x, p.y);
        if (height_m < 0) height_m = 0;  //Landscape returns negative height values when over water.

        return height_m;
    }


    public static Point3d Il2Point3dToLongLat(Point3d pos)
    {
        //This is an approximate calc. 
        //Courtesy mevans, https://theairtacticalassaultgroup.com/forum/showthread.php?t=26483
        /*pos.x = (int)pos.x - 146643;
        pos.x = pos.x / 63763.30751;
        pos.x = pos.x - 0.095287;
        */
        /* pos.y = (int)pos.y - 250937;
        pos.y = pos.y / 112533.651;
        pos.y = pos.y + 51.303649;
        */

        //Cubic Regression Curve Fit for four points on various corners of the map done 
        //via https://www.mycurvefit.com/ 
        //Should be accurate to about the 6th decimal place of the lat/long at those four points,
        //however is inaccurate to 10-20km in some points more in the middle of the map, not sure why.
        pos.x = -2.017013 + 0.00001256447 * pos.x + 5.532674e-12 * pos.x * pos.x - 6.478475e-18 * pos.x * pos.x * pos.x;
        pos.y = 49.01039 + 0.00000923699 * pos.y - 2.674155e-12 * pos.y * pos.y + 7.598837e-18 * pos.y * pos.y * pos.y;

        //mycurvefit.com came up with these possible curve fitting formulas based on those 4 points,
        //perhaps one of the others will work better:
        //#1:
        //lat =0.00000907759*y+49.0913
        //lon = 0.00001390456 * x - 2.097487
        //
        //#2:
        //lat = 49.01703 + 0.000008851254*y+7.476433*10^-13*y^2
        //lon = -2.041605 + 0.00001312839 * x + 1.959212e-12 * x ^ 2

        //#3: (implemented above)
        //lat = 49.01039 + 0.00000923699*y - 2.674155e-12*y^2 + 7.598837e-18*y^3
        //lon = -2.017013 + 0.00001256447 * x + 5.532674e-12 * x ^ 2 - 6.478475e-18 * x ^ 3
        return pos;
    }


    public static string DegreesToWindRose(double degrees)
    {
        String[] directions = { "North", "North East", "East", "South East", "South", "South West", "West", "North West", "North" };
        return directions[(int)Math.Round((((double)degrees % 360) / 45))];
    }

    // to get the correct bearing its nessesary to make a litte enter the matrix operation.
    // the Vector2d.direction() (same as atan2) has 0? at the x-axis and goes counter clockwise, but we need 0? at the y-axis
    // and clockwise direction
    // so to convert it we need 
    // |0 1| |x|   |0*x + 1*y|    |y|
    // |   | | | = |         | =  | |   // ok not very surprising ;)
    // |1 0| |y|   |1*x + 0*y|    |x|

    public static double CalculateBearingDegree(Vector3d vector)
    {
        Vector2d matVector = new Vector2d(vector.y, vector.x);
        // the value of direction is in rad so we need *180/Pi to get the value in degrees.  We subtract from pi/2 to convert to compass directions

        double bearing = (matVector.direction()) * 180.0 / Math.PI;
        return (bearing > 0.0 ? bearing : (360.0 + bearing));
    }


    public static double CalculateBearingDegree(Vector2d vector)
    {
        Vector2d newVector = new Vector2d(vector.y, vector.x);
        // the value of direction is in rad so we need *180/Pi to get the value in degrees.  We subtract from pi/2 to convert to compass directions
        double bearing = (newVector.direction()) * 180.0 / Math.PI;
        return (bearing > 0.0 ? bearing : (360.0 + bearing));
    }


    public static double CalculateBearingFromOrigin(Point2d targetLocation, Point2d originLocation)
    {

        double deltaX = targetLocation.x - originLocation.x;
        double deltaY = targetLocation.y - originLocation.y;

        double bearing = Math.Atan2(deltaX, deltaY);
        bearing = bearing * (180.0 / Math.PI);

        return (bearing > 0.0 ? bearing : (360.0 + bearing));
    }


    public static double CalculateBearingFromOrigin(Point3d targetLocation, Point3d originLocation)
    {

        double deltaX = targetLocation.x - originLocation.x;
        double deltaY = targetLocation.y - originLocation.y;


        double bearing = Math.Atan2(deltaX, deltaY);
        bearing = bearing * (180.0 / Math.PI);

        return (bearing > 0.0 ? bearing : (360.0 + bearing));
    }


    public static int GetDegreesIn10Step(double degrees)
    {
        degrees = Math.Round((degrees / 10), MidpointRounding.AwayFromZero) * 10;

        if ((int)degrees == 360)
            degrees = 0.0;

        return (int)degrees;
    }

    public static int RoundInterval(double number, int interval = 10)
    {
        number = Math.Round((number / interval), MidpointRounding.AwayFromZero) * interval;


        return (int)number;
    }

    public static string correctedSectorNameDoubleKeypad(AMission msn, Point3d p)
    {

        string s = correctedSectorName(msn, p) + "." + doubleKeypad(p);
        return s;

    }

    public static string correctedSectorNameKeypad(AMission msn, Point3d p)
    {

        string s = correctedSectorName(msn, p) + "." + singleKeypad(p);
        return s;

    }

    //This make a  larger, somewhat random block of sectors, with the initial point in it somewhere. 
    //MaxSectorWidth 4x10000 actually gives sector blocks 5 wide sometimes (0.5 to 4.5, say -- takes in sectors 0,1,2,3,4)
    //So, we subract 1.
    public static string makeBigSector(AMission msn, Point3d p, int maxSectorWidth = 4)
    {
        Point3d p1 = new Point3d(p.x - clc_random.Next((maxSectorWidth - 1) * 10000), p.y - clc_random.Next((maxSectorWidth - 1) * 10000), p.z);
        if (p1.x < 10000) p1.x = 10000;
        if (p1.y < 10000) p1.y = 10000;
        if (p1.x > 359000) p1.x = 359000; //so, sometimes we get sector BJ? ???  if the max is 360000.  So cutting it down to 359K just for safety
        if (p1.y > 359000) p1.y = 359000; //same, 310K the limit, cut to 309 for safety.
        Point3d p2 = new Point3d(p.x + clc_random.Next((maxSectorWidth - 1) * 10000), p.y + clc_random.Next((maxSectorWidth - 1) * 10000), p.z);

        //BattleArea 10000 10000 360000 310000 10000 is TWC standard
        if (p1.x < 10000) p1.x = 10000;
        if (p1.y < 10000) p1.y = 10000;
        if (p2.x > 359000) p2.x = 359000; //see above, not 360K or 310K
        if (p2.y > 359000) p2.y = 359000;

        return correctedSectorName(msn, p1) + "-" + correctedSectorName(msn, p2);

    }

    //OK, so in order for the sector # to match up with the TWC map, and
    //to work with our "double keypad" routines listed here,
    //And (most important!) in order to make the sectors match up with EASY SIMPLE
    //squares of side 10000m in the in-game coordinate system, you must use this battle area
    //in the .mis file:
    //
    //BattleArea 10000 10000 360000 310000 10000
    //
    //Key here is the 10000,10000 which makes the origin of the battle area line up with the origin of the 
    //in-game coordinate system.
    //
    //If you wanted to change this & make the battle area smaller or something, you could just increase
    //the #s in increments of 100000.
    //The 360000 310000 is important only in that it EXACTLY matches the size of the map available in CLOD 
    //in FMB etc.  So 0 0 360000 310000 10000 exactly matches the full size of the Channel Map in CloD,
    //uses the full extent of the map, and makes the sector calculations exactly match in 10,000x10,000 meter 
    //increments.

    //UPDATE: 0 0 360000 360000 10000 for TOBRUK.  2020/08. 

    //This is also the way the TWC online radar map works, so if you do it that way the in-game map & offline 
    //radar map will match.

    public static string correctedSectorName(AMission msn, Point3d p)
    {

        string sector = msn.GamePlay.gpSectorName(p.x, p.y);
        sector = sector.Replace(",", ""); // remove the comma
        return sector;

    }

    public static string doubleKeypad(Point3d p)
    {
        int keyp = keypad(p, 10000);
        int keyp2 = keypad(p, 10000 / 3);
        return keyp.ToString() + "." + keyp2.ToString();
    }

    public static string singleKeypad(Point3d p)
    {
        int keyp = keypad(p, 10000);
        //int keyp2 = keypad(latlng, 10000 / 3);
        return keyp.ToString();
    }

    //keypad number for area, numbered 1-9 from bottom left to top right
    //of square size
    //Called with size = 10000 for normal CloD keypad, size = 10000/3 for mini-keypad
    //
    public static int keypad(Point3d p, double size)
    {
        int lat_rem = (int)Math.Floor(3 * (p.y % size) / size);
        int lng_rem = (int)Math.Floor(3 * (p.x % size) / size);
        return lat_rem * 3 + lng_rem + 1;
    }
    //Giant keypad covering the entire map.  Lower left is 1, upper right is 9
    //Note that (especially in TOBRUK) if a player is OFF THE MAP a bit they will be some negative 1 or 14 other weirdo numbers
    //So we're restricting it to 3X3 plus 0 is any negative overflow and 10 is any positive overflow
    public static int giantkeypad(Point3d p)
    {
        //These are the max x,y values on the whole map
        double sizex = 360000;
        double sizey = 360000;
        int lat_rem = (int)Math.Floor(3 * (p.y % sizey) / sizey);
        int lng_rem = (int)Math.Floor(3 * (p.x % sizex) / sizex);
        int ret = lat_rem * 3 + lng_rem + 1;
        if (ret > 10) ret = 10;
        if (ret < 0) ret = 0;
        return ret;
    }

    public static int NoOfAircraft(int number)
    {
        int firstDecimal = 0;
        int higherDecimal = 0;

        higherDecimal = Math.DivRem(number, 10, out firstDecimal);

        if (firstDecimal > 3 && firstDecimal <= 8)
            firstDecimal = 5;
        else if (firstDecimal > 8)
            higherDecimal += 1;

        if (higherDecimal > 0)
            return (int)higherDecimal * 10;
        else
        {
            if (firstDecimal > 0 && firstDecimal <= 3) //If # is 1,2,3 then 50% of the time we get mixed up & get it wrong.  This is bec. radar can't always distinguish between 1,2,3 etc contacts.  "the height of the vertical displacement indicated formation size" - in other words it was a ROUGH estimate of the strength of the radar return, which they then turned into a guesstimate of how many a/c were in the formation.
            {
                firstDecimal = 2;
            }
            return (int)firstDecimal;
        }
    }

    #endregion

    public static IEnumerable<string> SplitToLines(string stringToSplit, int maxLineLength)
    {
        if (stringToSplit.Length <= maxLineLength) { yield return stringToSplit; yield break; }
        string[] words = stringToSplit.Split(' ');
        StringBuilder line = new StringBuilder();
        foreach (string word in words)
        {
            if (word.Length + line.Length <= maxLineLength)
            {
                line.Append(word + " ");
            }
            else
            {
                if (line.Length > 0)
                {
                    yield return line.ToString().Trim();
                    line.Clear();
                }
                string overflow = word;
                while (overflow.Length > maxLineLength)
                {
                    yield return overflow.Substring(0, maxLineLength);
                    overflow = overflow.Substring(maxLineLength);
                }
                line.Append(overflow + " ");
            }
        }
        yield return line.ToString().Trim();
    }

    //Salmo @ http://theairtacticalassaultgroup.com/forum/archive/index.php/t-4785.html
    public static string GetAircraftType(AiAircraft aircraft)
    { // returns the type of the specified aircraft
        string result = null;
        if (aircraft != null)
        {
            string type = aircraft.InternalTypeName(); // eg type = "bob:Aircraft.Bf-109E-3"
            string[] part = type.Trim().Split('.');
            result = part[1]; // get the part after the "." in the type string
        }
        return result;
    }

    public static bool isHeavyBomber(AiAircraft aircraft)
    {
        if (aircraft == null) return false;
        string acType = GetAircraftType(aircraft);
        return isHeavyBomber(acType);
    }
    public static bool isHeavyBomber(AiAirGroup airGroup)
    {
        AiAircraft aircraft = null;
        if (airGroup != null && airGroup.GetItems().Length > 0 && (airGroup.GetItems()[0] as AiAircraft) != null) aircraft = airGroup.GetItems()[0] as AiAircraft;
        return isHeavyBomber(aircraft);

    }
    public static bool isHeavyBomber(string acType)
    {
        if (acType == "") return false;
        bool ret = false;
        if (acType.Contains("Ju-88") || acType.Contains("He-111") || acType.Contains("BR-20") || acType.Contains("BlenheimMkI") || acType.Contains("Do-17") || acType.Contains("Wellington")
          || acType.Contains("Do-215B")
          || acType.Contains("Sunderland") || acType.Contains("Walrus") || acType.Contains("HurricaneMkI_FB")) ret = true; //Contains("BlenheimMkI" includes BI, BIV, BIV Late, etc.
        if (acType.Contains("BlenheimMkIVF") || acType.Contains("BlenheimMkIVNF") || acType.Contains("BlenheimMkIF") || acType.Contains("BlenheimMkINF")) ret = false;
        return ret;
    }
    public static bool isDiveBomber(AiAircraft aircraft)
    {
        if (aircraft == null) return false;
        string acType = GetAircraftType(aircraft);
        return isDiveBomber(acType);
    }
    public static bool isDiveBomber(AiAirGroup airGroup)
    {
        AiAircraft aircraft = null;
        if (airGroup != null && airGroup.GetItems().Length > 0 && (airGroup.GetItems()[0] as AiAircraft) != null) aircraft = airGroup.GetItems()[0] as AiAircraft;
        return isDiveBomber(aircraft);

    }
    public static bool isDiveBomber(string acType)
    {
        if (acType == "") return false;
        bool ret = false;
        if (acType.Contains("Ju-87")) ret = true; //only JU-87 now, but maybe more later?   HurriFB definitely won't dive-bomb
        return ret;
    }

    /// <summary>
    /// Returns a MD5 hash as a string
    /// </summary>
    /// <param name="TextToHash">String to be hashed.</param>
    /// <returns>Hash as string.</returns>
    /// Matches with javascript MD5 output
    public static string GetMD5Hash(string input)
    {

        //Calculate MD5 hash. This requires that the string is splitted into a byte[].
        MD5 md5Hash = new MD5CryptoServiceProvider();
        // Convert the input string to a byte array and compute the hash.
        byte[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(input));

        // Create a new Stringbuilder to collect the bytes
        // and create a string.
        StringBuilder sBuilder = new StringBuilder();

        // Loop through each byte of the hashed data 
        // and format each one as a hexadecimal string.
        for (int i = 0; i < data.Length; i++)
        {
            sBuilder.Append(data[i].ToString("x2"));
        }

        // Return the hexadecimal string.
        return sBuilder.ToString();
    }
    public static Player PlayerFromName(AMission msn, string name)
    {   // Purpose: Returns Player player given string name of player

        //multiplayer
        if (msn.GamePlay.gpRemotePlayers() != null) foreach (Player player in msn.GamePlay.gpRemotePlayers())
            {
                if (player.Name() == name) return player;
            }
        //singleplayer
        else if (msn.GamePlay.gpPlayer() != null)
        {
            if (msn.GamePlay.gpPlayer().Name() == name) return msn.GamePlay.gpPlayer();
        }
        return null;
    }
    public static int gpNumberOfPlayers(this IGamePlay GamePlay)
    {   // Purpose: Returns the number of human players in the game.
        // Use: GamePlay.NumberOfPlayers(); 
        int result = 0;

        //multiplayer
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            return GamePlay.gpRemotePlayers().ToList().Count;
        }
        //singleplayer
        else if (GamePlay.gpPlayer() != null)
        {
            result = 1;
        }
        return result;
    }

    public static int gpNumberOfPlayers(this IGamePlay GamePlay, int army)
    {   // Purpose: Returns the number of human players in the game in the 
        //          specified army.
        // Use: GamePlay.NumberOfPlayers(army); 
        int result = 0;
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            List<Player> players = new List<Player>(GamePlay.gpRemotePlayers());
            for (int i = 0; i < players.Count; i++)
            {
                if (players[i].Army() == army) result += 1;
            }
        }
        // on Dedi the server:
        else if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army) return 1;
            result = 0;
        }
        return result;
    }

    public static int gpNumberOfPlayersActive(this IGamePlay GamePlay, int army)
    {   // Purpose: Returns the number of human players in the game in the 
        //          specified army, who are in planes and in the air.
        // Use: GamePlay.NumberOfPlayersActive(GamePlay, army); 
        int result = 0;
        if (GamePlay.gpRemotePlayers() != null || GamePlay.gpRemotePlayers().Length > 0)
        {
            List<Player> players = new List<Player>(GamePlay.gpRemotePlayers());
            for (int i = 0; i < players.Count; i++)
            {
                if (players[i].Army() == army)
                {
                    if (players[i].Place() == null) continue;
                    if (players[i].Place() as AiAircraft == null) continue;
                    AiAircraft aircraft = players[i].Place() as AiAircraft;
                    double altAGL_m = aircraft.getParameter(part.ParameterTypes.Z_AltitudeAGL, 0);
                    if (altAGL_m > 5) result += 1;  //only count players in plane & off the ground/in flight
                }
            }
        }
        // on Dedi the server:
        else if (GamePlay.gpPlayer() != null)
        {
            if (GamePlay.gpPlayer().Army() == army) return 1;
            result = 0;
        }
        return result;
    }

    //returns distance to nearest friendly airport to actor, in meters. Count all friendly airports, alive or not.
    public static double distanceToNearestAirport(this IGamePlay GamePlay, AiActor actor)
    {
        double d2 = 10000000000000000; //we compare distanceSQUARED so this must be the square of some super-large distance in meters && we'll return anything closer than this.  Also if we don't find anything we return the sqrt of this number, which we would like to be a large number to show there is nothing nearby.  If say d2 = 1000000 then sqrt (d2) = 1000 meters which probably not too helpful.
        if (GamePlay == null) return d2;
        double d2Min = d2;
        if (actor == null) return d2Min;
        Point3d pd = actor.Pos();
        int n = GamePlay.gpAirports().Length;
        //AiActor[] aMinSaves = new AiActor[n + 1];
        //int j = 0;
        //twcLogServer(null, "Checking distance to nearest airport", new object[] { });
        for (int i = 0; i < n; i++)
        {
            AiActor a = (AiActor)GamePlay.gpAirports()[i];
            if (a == null) continue;
            //if (actor.Army() != a.Army()) continue; //only count friendly airports
            //if (actor.Army() != (a.Pos().x, a.Pos().y)
            //OK, so the a.Army() thing doesn't seem to be working, so we are going to try just checking whether or not it is on the territory of the Army the actor belongs to.  For some reason, airports always (or almost always?) list the army = 0.

            //twcLogServer(null, "Checking airport " + a.Name() + " " + GamePlay.gpFrontArmy(a.Pos().x, a.Pos().y) + " " + a.Pos().x.ToString ("N0") + " " + a.Pos().y.ToString ("N0") , new object[] { });

            if (GamePlay.gpFrontArmy(a.Pos().x, a.Pos().y) != actor.Army()) continue;


            //if (!a.IsAlive()) continue;


            Point3d pp;
            pp = a.Pos();
            pd.z = pp.z;
            d2 = pd.distanceSquared(ref pp);
            if (d2 < d2Min)
            {
                d2Min = d2;
                //twcLogServer(null, "Checking airport / added to short list" + a.Name() + " army: " + a.Army().ToString(), new object[] { });
            }

        }
        //twcLogServer(null, "Distance:" + Math.Sqrt(d2Min).ToString(), new object[] { });
        return Math.Sqrt(d2Min);
    }

    //nearest airport to a point
    //army=0 is neutral, meaning found airports of any army
    //otherwise, find only airports matching that army
    public static AiAirport nearestAirport(this IGamePlay GamePlay, Point3d location, int army = 0)
    {
        AiAirport NearestAirfield = null;
        if (GamePlay == null) return null;
        AiAirport[] airports = GamePlay.gpAirports();
        Point3d StartPos = location;

        if (airports != null)
        {
            foreach (AiAirport airport in airports)
            {
                AiActor a = airport as AiActor;
                if (army != 0 && GamePlay.gpFrontArmy(a.Pos().x, a.Pos().y) != army) continue;
                if (NearestAirfield != null)
                {
                    if (NearestAirfield.Pos().distanceSquared(ref StartPos) > airport.Pos().distanceSquared(ref StartPos))
                        NearestAirfield = airport;
                }
                else NearestAirfield = airport;
            }
        }
        return NearestAirfield;
    }

    //Looks for a match for the name given "*NAMEGIVEN*" and returns the list of all things matching it
    //returns only "live" actors - ie,  nothing if they are dead
    //Type can be "" to find ALL or "vehicle" or "artillery" or perhaps in the future some other types.
    //CASE INSENSITIVE!!!!!

    //Kill the player/aircraft/whatever after a specified amount of time
    public static bool KillActor(ABattle battle, AMission mission, AiActor actor, int waitTime = 0)
    {
        if (actor != null)
        {
            mission.Timeout(waitTime, () =>
            {
                //Console.WriteLine("KillActor: " + actor.Name() );
                //Battle.OnActorDead(0, player.Name(), actor, OnBattleStarted.GetDamageInitiators(actor); 
                battle.OnEventGame(GameEventId.ActorDead, actor, battle.GetDamageInitiators(actor), 0);
            });

            return true;

            //Battle.OnEventGame(GameEventId.ActorDead, actor, Battle.GetDamageInitiators(actor), 0); //or similar might do the same thing.  If instead of null AIDamageInitiator is included, that would be better . . . 
        }
        //Console.WriteLine("KillActor: Actor was NULL");
        return false;
    }

    public static List<AiActor> GetActorsByNameMatch(this IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> actors, string name = "", int matcharmy = 0, string type = "", bool onlyArtilleryAndVehicles= false)
    {
        try {
            List<AiActor> l = new List<AiActor>();

            foreach (AiActor actor in actors.Values)
            {
                //Could filter by air, ground etc but not for now . . . .
                //if ((AiGroundActor)actor == null) continue;
                //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                if (actor == null) continue;
                if (!actor.Name().ToLower().Contains(name.ToLower())) continue;
                if ((actor as AiGroundActor) != null && (actor as AiGroundActor).Health() < 0.0001) continue; //only count them if they are alive & in some decent state of health
                if ((actor as AiAircraft) != null && (actor as AiAircraft).IsKilled()) continue; //only count them if they are alive & in some decent state of health
                if (matcharmy > 0 && actor.Army() != matcharmy) continue;
                bool art = isActorArtillery(actor);
                bool veh = isActorVehicle(actor);
                if (onlyArtilleryAndVehicles && !art && !veh) continue;  //not sure why I thought this would be a good idea?  Maybe for some useages where only artillery & vehicles are needed?
                if (type.ToLower() == "vehicle" && !veh) continue;
                if (type.ToLower() == "artillery" && !art) continue;
                //if (CalculatePointDistance(location, actor.Pos()) > radius_m) continue;

                //Console.WriteLine("Found groundactor " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString()+ " " + actor.Army());
                l.Add(actor);
            }

            return l;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Calcs.GetActorsByNameMatch ERROR: " + ex.ToString());
            return new List<AiActor>();
        }
    }

    public static int KillActorsByNameMatch(ABattle battle, IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> actors, string name = "", int matcharmy = 0, string type = "")
    {
        List<AiActor> l = GetActorsByNameMatch(GamePlay, mission, actors, name, matcharmy, type, onlyArtilleryAndVehicles: true);
        return KillActorsOnList(battle, mission, l);

    }

    //gets all ground actors within given radius and kills them
    //returns number killed
    //good for testing objectives etc
    public static int KillGroundActorsNear(ABattle battle, IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> groundActors, Point3d location, double radius_m, int matcharmy = 0, string type = "")
    {
        List<AiActor> l = GetGroundActorsNear(GamePlay, mission, groundActors, location, radius_m, matcharmy, type, onlyArtilleryAndVehicles: true);

        return KillActorsOnList(battle, mission, l);
    }

    //Kills all actors on the list
    //returns the number killed
    public static int KillActorsOnList(ABattle battle, AMission mission, List<AiActor> l)
    {
        int count = 0;
        foreach (AiActor a in l)
        {
            try
            {
                if (a == null) continue;
                KillActor(battle, mission, a, 2); //2 sec delay gets around possible removal of objects in the list while cycling through it
                count++;
            }
            catch (Exception ex)
            {
                Console.WriteLine("Calcs.KillActorsOnList ERROR: " + ex.ToString());
            }
        }
        return count;
    }

    public static AiActor GetGroundActorNear(this IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> groundActors, Point3d location, double radius_m, int matcharmy = 0, string type = "", bool onlyArtilleryAndVehicles = false)
    {
        List<AiActor> l = GetGroundActorsNear(GamePlay, mission, groundActors, location, radius_m, matcharmy, type, onlyArtilleryAndVehicles: onlyArtilleryAndVehicles);

        if (l.Count == 0) return null;
        int index = clc_random.Next(l.Count);
        return l[index];
    }
    //OK, this so this one actually works.

    //  You can use type is "Artillery" "Vehicle" or "" to get both.
    public static List<AiActor> GetGroundActorsNear(this IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> groundActors, Point3d location, double radius_m, int matcharmy = 0, string type = "", bool onlyArtilleryAndVehicles = false)
    {
        // For %reasons% this doesn't typically work right if AiGroundGroupType.Artillery
        // So we just use this alternate counting method instead, in that case:
        //if (type == AiGroundGroupType.Artillery) return CountGroundArtillery(GamePlay, location, radius_m, matcharmy);

        List<AiActor> l = new List<AiActor>();



        foreach (AiActor actor in groundActors.Values)
        {
            if ((actor as AiGroundActor) == null) continue;
            //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
            //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
            if ((actor as AiGroundActor).Health() < 0.0001) continue; //only count them if they are alive & in some decent state of health
            if (matcharmy > 0 && (actor as AiGroundActor).Army() != matcharmy) continue;
            bool art = isActorArtillery(actor);
            bool veh = isActorVehicle(actor);
            if (onlyArtilleryAndVehicles && !art && !veh) continue;
            if (type.ToLower() == "vehicle" && !veh) continue;
            if (type.ToLower() == "artillery" && !art) continue;
            if (CalculatePointDistance(location, actor.Pos()) > radius_m) continue;

            //Console.WriteLine("Found groundactor " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString()+ " " + actor.Army());
            l.Add(actor);
        }

        return l;
    }

    //type == aircraft, groundactor, or blank for any kind of actor
    public static List<AiActor> GetActorsNear(this IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> aircraftDict, Point3d location, double radius_m, int matcharmy = 0, string type = "")
    {


        List<AiActor> l = new List<AiActor>();

        type = type.ToLower();

        foreach (AiActor actor in aircraftDict.Values)
        {
            if (type == "groundactor" && (actor as AiGroundActor) == null) continue;
            if (type == "aircraft" && (actor as AiAircraft) == null) continue;
            //Console.WriteLine("act " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
            //Console.WriteLine("act " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());            
            if (matcharmy > 0 && actor.Army() != matcharmy) continue;
            bool art = isActorArtillery(actor);
            bool veh = isActorVehicle(actor);
            if (type.ToLower() == "vehicle" && !veh) continue;
            if (type.ToLower() == "artillery" && !art) continue;
            if (CalculatePointDistance(location, actor.Pos()) > radius_m) continue;

            //Console.WriteLine("Found actor " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString()+ " " + actor.Army());
            l.Add(actor);
        }

        return l;
    }

    //counts how many ground actors of a given army are within a given radius
    //matches army if given, or both armies if army = 0
    //matches groundgrouptype given (AiGroundGroupType.Vehicle by default) or any ground group if type = null
    //possible types (2020/08) are:  AiGroundGroupType.Artillery .Ship .Town .Vehicle .Train (maddox.game.world.AiGroundGroupType)
    //

    //  You can use type is "Artillery" "Vehicle" or "" to get both.
    public static int CountGroundActors(this IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> groundActors, Point3d location, double radius_m, int matcharmy = 0, string type = "", bool onlyArtilleryAndVehicles = false)
    {
        // For %reasons% this doesn't typically work right if AiGroundGroupType.Artillery
        // So we just use this alternate counting method instead, in that case:
        //if (type == AiGroundGroupType.Artillery) return CountGroundArtillery(GamePlay, location, radius_m, matcharmy);
        
        int count = 0;
        
        //So this \/ \/ \/ \/ is the OLD way but it turns out that it MISSES TONS OF STUFF because NOT ALL GROUND ACTORS are in GROUND GROUPS!!!!!!!!!!
        //So the NEW better working way is BELOW THAT.  Still maybe not perfect.
        /*
        if (GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
        {
            foreach (int army in GamePlay.gpArmies())
            {
                if (matcharmy != 0 && matcharmy != army) continue;

                if (GamePlay.gpGroundGroups(army) != null && GamePlay.gpGroundGroups(army).Length > 0)
                {
                    foreach (AiGroundGroup groundGroup in GamePlay.gpGroundGroups(army))
                    {
                        if (type != null && groundGroup.GroupType() != type) continue;
                        Point3d grouppos = new Point3d(-100000, -100000, -100000);
                        //If group pos isn't even close to the airport we just skip it
                        //But when we're close to the target position we actually count, exact pos of each individual actor
                        groundGroup.GetPos(out grouppos);
                        //Console.WriteLine("Groundgroup " + groundGroup.ID() + " at " + grouppos.ToString() + " | " + location.ToString() + " | " + Calcs.CalculatePointDistance(location, grouppos).ToString() + " R " + radius.ToString());
                        if (Calcs.CalculatePointDistance(location, grouppos) > 5 * radius_m) continue;
                        if (groundGroup.GetItems() != null && groundGroup.GetItems().Length > 0)
                        {
                            foreach (AiActor actor in groundGroup.GetItems())
                            {
                                //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                                if ((AiGroundActor)actor == null) continue;
                                if ((actor as AiGroundActor).Health() < 0.0001) continue; //only count them if they are alive & in some decent state of health
                                if (CalculatePointDistance(location, actor.Pos()) > radius_m) continue;
                                count++;
                            }

                        }
                    }
                }
            }
        } */

        foreach (AiActor actor in groundActors.Values)
        {
            try
            {
                if (actor == null || actor as AiGroundActor == null) continue;
                //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                //Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                if ((actor as AiGroundActor).Health() < 0.0001) continue; //only count them if they are alive & in some decent state of health
                if (!GamePlay.gpActorIsValid(actor)) continue; //maybe not necessary/harmful??!
                if (matcharmy > 0 && (actor as AiGroundActor).Army() != matcharmy) continue;
                bool art = isActorArtillery(actor);
                bool veh = isActorVehicle(actor);
                if (onlyArtilleryAndVehicles && !art && !veh) continue;
                if (type.ToLower() == "vehicle" && !veh) continue;
                if (type.ToLower() == "artillery" && !art) continue;
                if (CalculatePointDistance(location, actor.Pos()) > radius_m) continue;

                //Console.WriteLine("Found groundactor " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString()+ " " + actor.Army());
                count++;
            }
            catch (Exception ex) { Console.WriteLine("CountGroundActors inner loop ERROR: " + ex.ToString()); }
        }

        return count;
    }
    public static AiGroundActorType[] agatArtillery = { AiGroundActorType.AAGun, AiGroundActorType.Artillery };

    public static bool isActorArtillery(AiActor actor) {
        //return false;

        AiGroup aig = actor.Group();
        if ((aig as AiGroundGroup) != null && (aig as AiGroundGroup).GroupType() == AiGroundGroupType.Artillery) return true;
        AiGroundActor gactor = actor as AiGroundActor;
        if (gactor == null) return false;
        if (agatArtillery.Contains(gactor.Type())) return true;
        return false;
    }

    public static AiGroundActorType[] agatVehicle = { AiGroundActorType.Amphibian, AiGroundActorType.Bus, AiGroundActorType.Car, AiGroundActorType.LightTruck, AiGroundActorType.Motorcycle, AiGroundActorType.SPG, AiGroundActorType.Tank, AiGroundActorType.Tractor, AiGroundActorType.Trailer, AiGroundActorType.Truck };

    public static bool isActorVehicle(AiActor actor)
    {
        //return false;

        AiGroup aig = actor.Group();
        if ((aig as AiGroundGroup) != null && (aig as AiGroundGroup).GroupType() == AiGroundGroupType.Vehicle) return true;
        AiGroundActor gactor = actor as AiGroundActor;
        if (gactor == null) return false;
        if (agatVehicle.Contains(gactor.Type())) return true;
        return false;
    }

    //counts how many ground actors of a given army are within a given radius
    //matches army if given, or both armies if army = 0
    //matches groundgrouptype given (AiGroundGroupType.Vehicle by default) or any ground group if type = null
    //possible types (2020/08) are:  AiGroundGroupType.Artillery .Ship .Town .Vehicle .Train (maddox.game.world.AiGroundGroupType)

    //UPDATE>  This counts only "static" artillery, not "actors" that actually, you know, shoot and stuff.  So, not too useful.
    public static int CountGroundArtillery(this IGamePlay GamePlay, Point3d location, double radius_m, int matcharmy = 0)
    {
        int count = 0;
        string matchstring = "gb";
        if (matcharmy == 2) matchstring = "de";
        List<GroundStationary> gs = GamePlay.gpGroundStationarys(location.x, location.y, radius_m).ToList();
        foreach (GroundStationary g in gs)
        {
            Console.WriteLine("Groundstat " + g.Name + " " + g.country + " " + g.Title + " " + g.Type.ToString());
            if (matcharmy > 0 && g.country != matchstring) continue;
            if (g.Type == AiGroundActorType.AAGun || g.Type == AiGroundActorType.Artillery) count++;
        }
        return count;
    }

    //returns the nearest groundgroup in matcharmy (or either army, if matcharmy==0) to the point OR null if nothing is withing radius_m
    //Randomness can be a number  0-100 and is the % chance of returning a random answer instead of the closest one
    public static AiGroundGroup nearestGroundGroup(this IGamePlay GamePlay, Point3d location, double radius_m, int matcharmy = 0, AiGroundGroupType type = AiGroundGroupType.Vehicle, int randomness = 0)
    {
        int count = 0;
        double distance = radius_m;
        int numInGroup = 0;

        AiGroundGroup foundgg = null;

        if (GamePlay != null && GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
        {
            try
            {
                foreach (int army in GamePlay.gpArmies())
                {
                    if (matcharmy != 0 && matcharmy != army) continue;

                    if (GamePlay.gpGroundGroups(army) != null && GamePlay.gpGroundGroups(army).Length > 0)
                    {
                        AiGroundGroup[] aggs = GamePlay.gpGroundGroups(army);
                        Calcs.Randomize(aggs);
                        //foreach (AiGroundGroup groundGroup in GamePlay.gpGroundGroups(army))
                        foreach (AiGroundGroup groundGroup in aggs)
                        {
                            if (groundGroup == null) continue;
                            if (!GamePlay.gpActorIsValid(groundGroup)) continue;
                            if (type != null && groundGroup.GroupType() != type) continue;
                            Point3d grouppos = new Point3d(-100000, -100000, -100000);
                            //If group pos isn't even close to the airport we just skip it
                            //But when we're close to the target position we actually count, exact pos of each individual actor
                            groundGroup.GetPos(out grouppos);
                            //Console.WriteLine("Groundgroup " + groundGroup.ID() + " at " + grouppos.ToString() + " | " + location.ToString() + " | " + Calcs.CalculatePointDistance(location, grouppos).ToString() + " R " + radius.ToString());

                            double temp_distance = Calcs.CalculatePointDistance(location, grouppos);
                            int temp_numInGroup = groundGroup.GetItems().Length;

                            if (temp_distance > radius_m) continue;

                            //Always add the first item encountered
                            if (count == 0 && temp_numInGroup > 0) { foundgg = groundGroup; distance = temp_distance; numInGroup = temp_numInGroup; count++; continue; }

                            //Take the closest to the center IF it has more than 2 live members
                            if ((temp_distance < distance && temp_numInGroup > 2) || clc_random.Next(0, 100) < randomness) { foundgg = groundGroup; distance = temp_distance; numInGroup = temp_numInGroup; count++; }
                        }
                    }
                }
            } catch (Exception ex) { Console.WriteLine("nearestGroundGroup ERROR: " + ex.ToString()); }
        }

        return foundgg;
    }

    //nearest airport to an actor
    public static AiAirport nearestAirport(this IGamePlay GamePlay, AiActor actor, int army = 0)
    {
        if (actor == null) return null;
        Point3d pd = actor.Pos();
        return nearestAirport(GamePlay, pd, army);
    }
    //find distance to nearest (friendly) birthplace, counting birthplaces (ie, spawnpoints) ONLY
    //army=1,2 find matching army, army=0, find either army.
    public static double distanceToNearestBirthplace(IGamePlay GamePlay, Point3d location, int army = 0)
    {
        //AiBirthPlace NearestBirthPlace = null;        
        Point3d StartPos = location;
        double bestDist_m = 1000000000000;

        foreach (AiBirthPlace bp in GamePlay.gpBirthPlaces())
        {
            if (army > 0 && bp.Army() != army) continue;
            Point3d bp_pos = bp.Pos();
            double dist = CalculatePointDistance(bp_pos, location);
            if (dist < bestDist_m) bestDist_m = dist;//Removes the spawnpoint associated with that airport (ie, if located within the field radius of the airport)
        }
        return bestDist_m;
    }


    public static void Shuffle<T>(this IList<T> list)
    {
        for (var i = 0; i < list.Count; i++)
            list.Swap(i, clc_random.Next(i, list.Count));
    }

    public static void Swap<T>(this IList<T> list, int i, int j)
    {
        var temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }

    public static async Task<bool> WriteAllTextAsyncWithBackups(string data, string fileDir_base, string fileName_base, string suffix, string ext, string backupDirStub, bool wait = false, ManualResetEvent resetEvent = null)
    {

        DateTime dt = DateTime.UtcNow;
        string date = dt.ToString("u");
        TimeSpan start = new TimeSpan(0, 0, 0); //Midnight o'clock
        TimeSpan end = new TimeSpan(12, 0, 0); //12 o'clock noon
        TimeSpan now = DateTime.UtcNow.TimeOfDay;

        string backupDirFile = fileDir_base + backupDirStub + fileName_base + suffix + "-" + dt.ToString("yyyy-MM-dd");
        if (start < now && now < end) backupDirFile += "-AM" + ext; //two backups a day, morn & eve
        else backupDirFile += "-PM" + ext;

        string filename_main = fileDir_base + fileName_base + suffix + ext;
        string backupTxtFile2 = fileDir_base + fileName_base + suffix + "_old2" + ext;
        string backupTxtFile1 = fileDir_base + fileName_base + suffix + "_old" + ext;
        string tempNewTxtFile = fileDir_base + fileName_base + suffix + "_tmp" + ext;


        //Console.WriteLine("WriteAllTextAsyncWithBackups: " + tempNewTxtFile + ": " + fileDir_base + " " + fileName_base + " " + suffix);

        try
        {
            //first, write the new file as a temp file
            try
            {
                System.IO.File.Delete(tempNewTxtFile);
            }
            catch (Exception ex) { }

            try
            {
                await WriteAllTextAsync(tempNewTxtFile, data);
            }
            catch (Exception ex) {
                Console.WriteLine("WriteAllTextAsyncWithBackups ERROR writing-ABORTING SAVE!! " + fileName_base + suffix + "_tmp" + ext + ": " + ex.Message);

                if (resetEvent != null) resetEvent.Set();
                return false;
            }

            //Now if that succeeded, we can proceed with backups etc. -  but only if it succeeded. No point in backing up if we don't have anything to backup

            if (System.IO.File.Exists(tempNewTxtFile)) {

                //First, copy the  new .tmp file to the backup directory (date plus A/B - morn & evening)
                try
                {
                    System.IO.File.Delete(backupDirFile);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR deleting " + backupDirFile + ": " + ex.Message); }

                try
                {
                    System.IO.File.Copy(tempNewTxtFile, backupDirFile);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR moving to backup " + fileName_base + suffix + "_tmp" + ext + ": " + ex.Message); }

                //Now move 1st backup to 2nd backup
                try
                {
                    System.IO.File.Delete(backupTxtFile2);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR deleting " + fileName_base + suffix + "_old2" + ext + ": " + ex.Message); }

                try
                {
                    System.IO.File.Move(backupTxtFile1, backupTxtFile2);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR moving to " + fileName_base + suffix + "_old2" + ext + ": " + ex.Message); }


                //Now move current main file to 1st backup
                try
                {
                    System.IO.File.Delete(backupTxtFile1);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR deleting " + fileName_base + suffix + "_old" + ext + ": " + ex.Message); }

                try
                {
                    System.IO.File.Copy(filename_main, backupTxtFile1);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR copying to " + fileName_base + suffix + "_old" + ext + ": " + ex.Message); }



                //Now move tmpNew main file to main file
                try
                {
                    System.IO.File.Delete(filename_main);
                }
                catch (Exception ex) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR deleting " + fileName_base + suffix + ext + ": " + ex.Message); }

                try
                {
                    System.IO.File.Move(tempNewTxtFile, filename_main);
                } catch (Exception ex)
                {
                    //If the rename of the .tmp to main fails this is DISASTROUS so we will try to
                    //save a copy of the current data file at least.  It will be namnd
                    //xxxx.EXT-3030301 with date/time appended to end
                    //Random ran = new Random();
                    //string r = ran.Next(1000000, 9999999).ToString();   
                    string r = dt.ToString("yyyy-MM-dd-HHmmss");

                    try
                    {
                        System.IO.File.Move(tempNewTxtFile, filename_main + "EMERGENCY_SAVE" + "-" + r);
                    }
                    catch (Exception ex1) { Console.WriteLine("WriteAllTextAsyncWithBackups ERROR on emergency save " + fileName_base + suffix + ext + ": " + ex1.ToString()); }
                }
            } else
            {
                Console.WriteLine("WriteAllTextAsync ERROR - file write FAILED: " + fileName_base + suffix + "_tmp" + ext);
            }

            //once all this is done we can release the hold, if present
            if (resetEvent != null) resetEvent.Set();
            return false;

        }
        catch (Exception ex)
        {
            Console.WriteLine("WriteAllTextAsync ERROR writing " + fileName_base + suffix + "_tmp" + ext + ": " + ex.Message);

            if (resetEvent != null) resetEvent.Set();
            return false;

        }
    }

    public static async Task<bool> WriteAllTextAsync(string filelocation, string data, bool wait = false, ManualResetEvent resetEvent = null)
    {
        try
        {
            using (var sw = new StreamWriter(filelocation))
            {
                /*
                int count = 0;
                if (wait)
                {
                    //try it like 10X if not successful
                    *
                    while (count < 10)
                    {
                        Task<bool> task = Calcs.WriteAllTextAsync(filepath, xmlString);
                        bool res = await task;
                        if (res) break;
                        Console.WriteLine("MO_WriteMissionObject: Attempt #" + count.ToString() + " to write " + name + " not successful");
                        Thread.Sleep(1);
                        count++;
                    }*
                    Task task = sw.WriteAsync(data);
                    await task;

                }
                else */
                await sw.WriteAsync(data);
            }
            if (resetEvent != null) resetEvent.Set(); //signals the waiting method that called this, to exit
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine("WriteAllTextAsync ERROR writing " + filelocation + ": " + ex.ToString());

            if (resetEvent != null) resetEvent.Set();
            return false;

        }
    }

    //army 1=red, 2=blue, 0=both
    //Removes items as indicates; spreads the deletes over 30 seconds.
    public static void removeArtilleryAAGroundVehicles(IGamePlay GamePlay, AMission mission, Dictionary<string, AiActor> groundActors, double x_m, double y_m, double radius_m, int matcharmy = 0)
    {
        Task.Run(() =>
        {

            try
            {
                Console.WriteLine("Removing artillery, AA, and ground vehicles at " + x_m.ToString() + ", " + y_m.ToString() + " radius: " + radius_m.ToString());

                string matchstring = "";
                if (matcharmy == 1) matchstring = "gb";
                if (matcharmy == 2) matchstring = "de";

                int countStat = 0;
                int countAct = 0;

                try
                {
                    //Stationaries - so not sure if we need to remove these; they are not actors ?!?
                    List<GroundStationary> gs = GamePlay.gpGroundStationarys(x_m, y_m, radius_m).ToList();
                    if (gs != null) foreach (GroundStationary g in gs)
                        {
                            try
                            {
                                if (g == null || (g as GroundStationary) == null) continue;
                                Console.WriteLine("Groundstat within radius: " + g.Name + " " + g.country + " " + g.Title + " " + g.Type.ToString());
                                if (matcharmy > 0 && g.country != matchstring) continue;
                                if (g.Type == AiGroundActorType.AAGun || g.Type == AiGroundActorType.Artillery)
                                {
                                    mission.Timeout(clc_random.Next(0, 76), () =>
                                    {

                                        if (g != null)
                                        {
                                            Console.WriteLine("Groundstat DESTROYING " + g.Name + " " + g.country + " " + g.Title + " " + g.Type.ToString());
                                            g.Destroy();
                                        }
                                    }); //COULD check to make sure they are the same type we placed, here.
                                        //Timeout makes the group disappear gradually over time but ALSO avoids the issue with deleting items in the list while looping i
                                    countStat++;
                                }

                            }
                            catch (Exception ex) { Console.WriteLine("RemoveAllGroundStationariesActors: STATIONARIES INNER LOOP ERROR! " + ex.ToString()); }
                        }

                    /*
                    //Ground Actors
                    if (GamePlay.gpArmies() != null && GamePlay.gpArmies().Length > 0)
                    {
                        foreach (int army in GamePlay.gpArmies())
                        {
                            if (matcharmy != 0 && matcharmy != army) continue;

                            if (GamePlay.gpGroundGroups(army) != null && GamePlay.gpGroundGroups(army).Length > 0)
                            {
                                foreach (AiGroundGroup groundGroup in GamePlay.gpGroundGroups(army))
                                {

                                    //if (groundGroup.GroupType() != AiGroundGroupType.Artillery && groundGroup.GroupType() != AiGroundGroupType.Vehicle) continue;
                                    Point3d grouppos = new Point3d(-100000, -100000, -100000);
                                    //If group pos isn't even close to the airport we just skip it
                                    //But when we're close to the target position we actually count, exact pos of each individual actor
                                    groundGroup.GetPos(out grouppos);
                                    Console.WriteLine("Groundgroup " + groundGroup.ID() + " " + groundGroup.GroupType().ToString() + " at " + grouppos.ToString() + " | " + Calcs.CalculatePointDistance(new Point2d(x_m, y_m), grouppos).ToString() + " R " + radius_m.ToString());
                                    //Console.WriteLine("Groundgroup " + groundGroup.ID() + " at " + grouppos.ToString() + " | " + location.ToString() + " | " + Calcs.CalculatePointDistance(location, grouppos).ToString() + " R " + radius.ToString());
                                    //if (Calcs.CalculatePointDistance(new Point2d(x_m, y_m), grouppos) > 5 * radius_m) continue;
                                    if (groundGroup.GetItems() != null && groundGroup.GetItems().Length > 0)
                                    {

                                        foreach (AiActor actor in groundGroup.GetItems())
                                        {
                                            Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                                            if ((AiGroundActor)actor == null) continue;                                    
                                            if (CalculatePointDistance(new Point2d(x_m, y_m), actor.Pos()) > radius_m) continue;
                                            //mission.Timeout(clc_random.Next(20, 600), () => {
                                            mission.Timeout(clc_random.Next(5, 10), () => {
                                                string firetype = "BuildingFireSmall";
                                                if (clc_random.NextDouble() < 0.6333) firetype = "Smoke1";
                                                if (clc_random.NextDouble() < 0.3333) Calcs.loadSmokeOrFire(GamePlay, mission, actor.Pos().x, actor.Pos().y, 0, firetype);
                                                (actor as AiCart).Destroy();

                                            });
                                            countAct++;
                                        }

                                    }
                                }
                            } */
                }
                catch (Exception ex) { Console.WriteLine("RemoveAllGroundStationariesActors: STATIONARIES 1 ERROR! " + ex.ToString()); }


                try
                {
                    foreach (AiActor actor in groundActors.Values)
                    {
                        if (actor == null || (AiGroundActor)actor == null) continue;

                        if (matcharmy > 0 && (actor as AiGroundActor).Army() != matcharmy) continue;
                        if (CalculatePointDistance(new Point2d(x_m, y_m), actor.Pos()) > radius_m) continue;
                        Console.WriteLine("Groundact " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                        mission.Timeout(clc_random.Next(1, 30), () =>
                        {
                            string firetype = "BuildingFireSmall";
                        //if (clc_random.NextDouble() < 0.02333) firetype = "BuildingFireBig";
                        //if (clc_random.NextDouble() < 0.05333) Calcs.loadSmokeOrFire(GamePlay, mission, actor.Pos().x, actor.Pos().y, 0, firetype); //too much smoke already

                        if (actor != null)
                            {
                                Console.WriteLine("Groundact DESTROYING " + actor.Name() + " at " + actor.Pos().ToString() + " health " + (actor as AiGroundActor).Health().ToString());
                                (actor as AiCart).Destroy();
                            }

                        });
                        countAct++;
                    }
                }
                catch (Exception ex) { Console.WriteLine("RemoveAllGroundStationariesActors: ACTORS ERROR! " + ex.ToString()); }

                Console.WriteLine("removeArtilleryAAGroundVehicles at {0:n0}, {1:n} radius {2:n}. Removed {3} stationaries, {4} groundactors", new object[] { x_m, y_m, radius_m, countStat, countAct });

            }
            catch (Exception ex) { Console.WriteLine("RemoveAllGroundStationariesActors: ERROR! " + ex.ToString()); }


        });

    }
    public static bool anyEnemyOrNeutralStationaries(IGamePlay GamePlay, double x, double y, double radius, int myArmy)
    {
        bool ret = false;
        string myCountry = "gb";
        if (myArmy == 2) myCountry = "de";

        foreach (GroundStationary sta in GamePlay.gpGroundStationarys(x, y, radius))
        {
            if (sta == null) continue;
            if (sta.country != myCountry) return true;
            Console.WriteLine("Checking: " + sta.Name + " - " + sta.country);

        }
        return ret;
    }

    private static int lSOFcount = 0;

    //returnFile just returns the file, not loading it, so you can assemble several into one load
    public static ISectionFile loadSmokeOrFire(maddox.game.IGamePlay GamePlay, AMission mission, double x, double y, double z, string type = "BuildingFireSmall", double duration_s = 300, ISectionFile f = null, bool resetCount = false)
    {
        /* Sample: Static556 Smoke.Environment.Smoke1 nn 63718.50 187780.80 110.00 /height 16.24 
         possible types: Smoke1 Smoke2 BuildingFireSmall BuildingFireBig BigSitySmoke_0 BigSitySmoke_1

        Not sure if height is above sea level or above ground level.

        NOTE THAT as of CloD 4.57 you can create these objects but you can't get their handle back via groundstationarys to delete/remove/destroy them later.
        These are the only groundstationaries I know about that have this problem.

        Example of how to get groundstationaries within a distance of a given point--except not that it will NOT list any smoke or fire groundstationaries!
[code]
GroundStationary[] gs = GamePlay.gpGroundStationarys(250000, 252000, 1000); //Find all groundstationaries within 1000 meters of map coordinate (250000,252000)
[/code]
 */
        //if on water, NO craters and only occasional smoke
        if ((type.ToLower().Contains("crater") || type.ToLower().Contains("fire") ||
                (type.ToLower().Contains("smoke")  && clc_random.Next(10)>0 )
                )
            && GamePlay.gpLandType(x, y) == maddox.game.LandTypes.WATER) return f;
        if (resetCount) lSOFcount = 0;
        bool returnFile = true;
        //AMission mission = GamePlay as AMission;
        if (f == null) { f = GamePlay.gpCreateSectionFile(); returnFile = false; }
        string sect = "Stationary";
        string key = "Static" + lSOFcount.ToString("F0");
        string value = "Smoke.Environment." + type + " nn " + x.ToString("0.00") + " " + y.ToString("0.00") + " " + (duration_s / 60).ToString("0.0") + " /height " + z.ToString("0.00");
        f.add(sect, key, value);
        lSOFcount++;

        if (!returnFile) GamePlay.gpPostMissionLoad(f);

        return f;


    }

    /*************************************************
    *
    * Handle smoke, fire, crater ISection files for area bombing, civilian bombing, airport bombing
    * Specifically, craters & smoke for airport bombing
    * 
    ********************************************************/

    public static void loadCratersAndSmoke(IGamePlay GamePlay, Mission msn, double x, double y, double z, string type = "", double duration_s = 300, string path = "", string type2 = "")
    {
        //for testing - disable all craters, smoke, and fire from airfield, civilian, other bombings & targets

        /*
        NOTE THAT as of CloD 4.57 you can create these objects but you can't get their handle back via groundstationarys to delete/remove/destroy them later.
        These are the only groundstationaries I know about that have this problem.

        Example of how to get groundstationaries within a distance of a given point--except not that it will NOT list any smoke or fire groundstationaries!
        [code]
        GroundStationary[] gs = GamePlay.gpGroundStationarys(250000, 252000, 1000); //Find all groundstationaries within 1000 meters of map coordinate (250000,252000)
        [/code]
        */


        //duration_s is how long the item will last before being destroyed (ie, disappearing) BUT (IMPORTANT!) it only works for the bomb craters, NOT for the smoke effects.
        // Choices for string type are: Smoke1, Smoke2, BuildingFireSmall, BuildingFireBig, BigSitySmoke_0, BigSitySmoke_1, 
        // BombCrater_firmSoil_mediumkg, BombCrater_firmSoil_smallkg, BombCrater_firmSoil_largekg
        // BombCrater_firmSoil_EXlargekg doesn't actually exist but will place TWO BombCrater_firmSoil_largekg craters near each other
        /* Samples: 
         * Static555 Smoke.Environment.Smoke1 nn 63748.22 187791.27 110.00 /height 16.24
    Static556 Smoke.Environment.Smoke1 nn 63718.50 187780.80 110.00 /height 16.24
    Static557 Smoke.Environment.Smoke2 nn 63688.12 187764.03 110.00 /height 16.24
    Static534 Smoke.Environment.BuildingFireSmall nn 63432.15 187668.28 110.00 /height 15.08
    Static542 Smoke.Environment.BuildingFireBig nn 63703.02 187760.81 110.00 /height 15.08
    Static580 Smoke.Environment.BigSitySmoke_0 nn 63561.45 187794.80 110.00 /height 17.01
    Static580 Smoke.Environment.BigSitySmoke_1 nn 63561.45 187794.80 110.00 /height 17.01
    Static0 Stationary.Environment.BombCrater_firmSoil_mediumkg nn 251217.50 257427.39 -520.00 
    Static2 Stationary.Environment.BombCrater_firmSoil_largekg nn 251211.73 257398.98 -520.00 
    Static1 Stationary.Environment.BombCrater_firmSoil_smallkg nn 251256.22 257410.66 -520.00

        Not sure if height is above sea level or above ground level.
    */

        //if on water, NO craters and only occasional smoke
        if ((type.ToLower().Contains("crater") || type2.ToLower().Contains("fire"))
            && GamePlay.gpLandType(x, y) == maddox.game.LandTypes.WATER) return;

        msn.Timeout(duration_s, () =>
        {
            //Console.WriteLine("Deleting stationary smokes . . . ");
            //This should work for bomb craters but HAS NO EFFECT for smoke effects
            //GamePlay.gpLogServer(null, "Deleting stationary bomb effects . . . ", new object[] { });
            Point2d P = new Point2d(x, y);
            //GamePlay.gpRemoveGroundStationarys(P, 10); //this is part of TF_extensions and doesn't work; it just fails silently when the timeout is called & entire timeout fails to run
            foreach (GroundStationary sta in GamePlay.gpGroundStationarys(x, y, 2))
            {
                if (sta == null) continue;
                Console.WriteLine("Deleting " + sta.Name + " " + sta.Title);
                if (sta.Name.Contains("smoke") || sta.Title.Contains("fire") || sta.Title.Contains("crater"))
                {
                    Console.WriteLine("Deleting stationary bomb effect " + sta.Name + " - end of life");
                    sta.Destroy();
                }
            }


        });

        //AMission mission = GamePlay as AMission;
        ISectionFile f = GamePlay.gpCreateSectionFile();
        string sect = "Stationary";
        string keybase = "Static";
        int count = 0;

        List<string> types = new List<string> { };
        if (type.Length > 0) types.Add(type);
        if (type2.Length > 0) types.Add(type2);

        foreach (string t in types)
        {

            string ttemp = t;
            string val1 = "Smoke";
            if (t.Contains("BombCrater")) val1 = "Stationary";
            int lines = 1;
            if (t == "BombCrater_firmSoil_EXlargekg")
            {
                ttemp = "BombCrater_firmSoil_largekg";
                lines = 2;
            }

            count++;
            string key = keybase + count.ToString();
            string value = val1 + ".Environment." + ttemp + " nn " + x.ToString("0.00") + " " + y.ToString("0.00") + " " + clc_random.Next(0, 181).ToString("0.0") + " /height " + z.ToString("0.00");
            f.add(sect, key, value);

            if (lines == 2)
            {

                count++;
                key = keybase + count.ToString();
                value = val1 + ".Environment." + ttemp + " nn " + (x + 9).ToString("0.00") + " " + (y - 9).ToString("0.00") + " " + clc_random.Next(0, 181).ToString("0.0") + " /height " + z.ToString("0.00");
                f.add(sect, key, value);

                count++;
                key = keybase + count.ToString();
                value = val1 + ".Environment." + ttemp + " nn " + (x - 9).ToString("0.00") + " " + (y + 9).ToString("0.00") + " "  + clc_random.Next(0, 181).ToString("0.0") + " /height " + z.ToString("0.00");
                f.add(sect, key, value);
            }
        }

        //GamePlay.gpLogServer(null, "Writing Sectionfile to " + path + "smoke-ISectionFile.txt", new object[] { }); //testing
        if (TWCComms.Communicator.Instance.WARP_CHECK) Console.WriteLine("SXX9 " + DateTime.UtcNow.ToString("T")); //testing disk output for warps
                                                                                                                   //f.save(path + "smoke-ISectionFile.txt"); //testing
                                                                                                                   //load the file after a random wait (to avoid jamming them all in together on mass bomb drop
        msn.Timeout(clc_random.NextDouble() * 45, () => {
            GamePlay.gpPostMissionLoad(f);
            //f.save(CLOD_PATH + FILE_PATH + "/sectionfiles" + "/craters_smoke"+clc_random.Next(10,99).ToString()); //testing
        });


        //TODO: The part to delete smokes after a while isn't working; it never finds or stops any of the smokes.   It does delete craters, however.     
        //This is because of CloD limitations.  It won't find/give you back the object for the smoke effects. Some others too ?? like humans??

    }

    public static void loadStatic(maddox.game.IGamePlay GamePlay, AMission mission, double x, double y, double z, string type = "Stationary.Opel_Blitz_cargo", double heading = 0, string side = "nn")
    {
        /*  side = nn , gb, or de
         * Examples: https://theairtacticalassaultgroup.com/forum/showthread.php?t=8493
         *   Static4 Stationary.Environment.Table_empty_UK-GER_1 nn 14334.77 15015.75 661.10 
                Static2 Stationary.Scammell_Pioneer_R100 gb 14357.38 15036.04 661.10 
                Static7 Stationary.Airfield.Sign_Table_UK1 nn 14295.63 15054.30 661.10 
                Static5 Stationary.Environment.Table_w_chess_UK-GER_1 nn 14308.39 15048.51 661.10 
                Static6 Stationary.Environment.Table_w_dinner_UK-GER_1 nn 14306.36 15060.39 661.10 
                Static3 Stationary.BMW_R71_w_MG_34 de 14325.78 15042.71 661.10  //motorcycle
                Static1 Stationary.Opel_Blitz_cargo de 14321.43 15065.61 661.10
                Static0 Stationary.Horch_830_B1 de 14350.42 15056.62 661.10  
                Static65 Stationary.Humans.Kdo_Hi_Ger35_passenger_4 de 14345.22 15051.82 661.10 2
                Static120 Stationary.Humans.Soldier_Krupp_L2H43_Driver_1 de 14342.67 15055.75 661.10 3 
                Static48 Stationary.Humans.Soldier_MG_TA_Passenger_1 de 14341.79 15056.98 661.10 4      
                Static66 Stationary.Humans.Ladder_passenger_ger_1 de 14344.66 15053.11 661.10 5
                Static50 Stationary.Humans.150_cm_Flakscheinwerfer_gunner1 de 14343.99 15055.41 661.10 6 
                Static123 Stationary.Humans.Soldier_Krupp_L2H43_pak_Driver_1 de 14344.14 15054.25 661.10 7 
                Static119 Stationary.Humans.Soldier_Sdkfz105_Gunner de 14346.02 15052.77 661.10 8 
                Static71 Stationary.Humans.Portable_Siren_ger_passenger de 14347.25 15052.80 661.10 9  
                */

        ISectionFile f = GamePlay.gpCreateSectionFile();
        string sect = "Stationary";
        string key = "Static1";
        string value = type + " " + side + " " + x.ToString("0.00") + " " + y.ToString("0.00") + " " + heading.ToString("0.0") + " /height " + z.ToString("0.00");
        //Console.WriteLine("Load Static: " + value);
        f.add(sect, key, value);

        GamePlay.gpPostMissionLoad(f);
        //f.save(CLOD_PATH + FILE_PATH + "/sectionfiles/" + "loadStatic" + random.Next(0, 9)); //testing

    }

    private static int staticCount = 0;

    //TODO: Make a dictionary key = sectionfile name or similar & & increment the static count independently for each different key.
    //Right now the reset of staticCount to 0 is messed up because lots of things execute asyncronously and thus the counter is reset randomly.
    //RadiusHide is the parameter radius_hide in the .mis file, which I THINK makes artillery etc hide/be inactive until someone is that close to it.
    public static ISectionFile makeStatic(ISectionFile f, maddox.game.IGamePlay GamePlay, AMission mission, double x, double y, double z, string type = "Stationary.Opel_Blitz_cargo", double heading = 0, string side = "nn", int radiusHide = 0, int? chiefNum = null, bool resetCount = false, bool desertskin=true)
    {
        /*  side = nn , gb, or de
         * Examples: https://theairtacticalassaultgroup.com/forum/showthread.php?t=8493
         *   Static4 Stationary.Environment.Table_empty_UK-GER_1 nn 14334.77 15015.75 661.10 
                Static2 Stationary.Scammell_Pioneer_R100 gb 14357.38 15036.04 661.10 
                Static7 Stationary.Airfield.Sign_Table_UK1 nn 14295.63 15054.30 661.10 
                Static5 Stationary.Environment.Table_w_chess_UK-GER_1 nn 14308.39 15048.51 661.10 
                Static6 Stationary.Environment.Table_w_dinner_UK-GER_1 nn 14306.36 15060.39 661.10 
                Static3 Stationary.BMW_R71_w_MG_34 de 14325.78 15042.71 661.10  //motorcycle
                Static1 Stationary.Opel_Blitz_cargo de 14321.43 15065.61 661.10
                Static0 Stationary.Horch_830_B1 de 14350.42 15056.62 661.10  
                Static65 Stationary.Humans.Kdo_Hi_Ger35_passenger_4 de 14345.22 15051.82 661.10 2
                Static120 Stationary.Humans.Soldier_Krupp_L2H43_Driver_1 de 14342.67 15055.75 661.10 3 
                Static48 Stationary.Humans.Soldier_MG_TA_Passenger_1 de 14341.79 15056.98 661.10 4      
                Static66 Stationary.Humans.Ladder_passenger_ger_1 de 14344.66 15053.11 661.10 5
                Static50 Stationary.Humans.150_cm_Flakscheinwerfer_gunner1 de 14343.99 15055.41 661.10 6 
                Static123 Stationary.Humans.Soldier_Krupp_L2H43_pak_Driver_1 de 14344.14 15054.25 661.10 7 
                Static119 Stationary.Humans.Soldier_Sdkfz105_Gunner de 14346.02 15052.77 661.10 8 
                Static71 Stationary.Humans.Portable_Siren_ger_passenger de 14347.25 15052.80 661.10 9  

                */

        /*
         * Desert Wings additional things added for desert skins:
         * 
         * /skin0 materialsDesert1/pax_skin0 materialsDesert1_RAF/skin1 materialsDesert1/pax_skin1 materialsDesert1_RAF
         * 
         * /skin0 materialsDesert1/pax_skin0 materialsDesert1_RAF/skin1 materialsDesert1/pax_skin1 materialsDesert1_RAF/skin2 materialsDesert1/pax_skin2 materialsDesert1_RAF
         * 
         * /skin0 materialsDesert1/pax_skin0 materialsDesert1_RAF/skin1 materialsDesert1/pax_skin1 materialsDesert1_RAF/skin2 materialsDesert1/pax_skin2 materialsDesert1_RAF
         * 
         * /skin materialsDesert1/pax_skin materialsDesert1_LW
         * 
         * This seems to be teh most basic/universal:
         * 
         * /skin materialsDesert1
         * 
         * */

        if (resetCount)
        {
            staticCount = 0;
            Console.WriteLine("makeStatic: reset staticCount to 0, {0} ", type);
        }



        string sect = "Stationary";
        string key = "Static" + staticCount.ToString("F0");       
        
        string value = type + " " + side + " " + x.ToString("0.00") + " " + y.ToString("0.00") + " " + heading.ToString("0.0") + " /height " + z.ToString("0.00") + "/radius_hide " + radiusHide.ToString("F0");
        if (chiefNum.HasValue) value += "/target AIChief_" + chiefNum.Value.ToString("F0");
        if (desertskin)
        {
            /*
            string armyAdd = "RAF";
            if (side == "de") armyAdd = "LW";
            else if (side == "nn")
            {
                int ground = GamePlay.gpFrontArmy(x, y);
                if (ground == 1) armyAdd = "RAF";
                if (ground == 2) armyAdd = "LW";
            }

            //So usually there is only /skin which SHOULD be the same as /skin0.  Sometimes there is also /skin1 and then once in a while also /skin2.  And maybe even /skin3.  But
            //we're hoping that /skin1 /skin2 etc will just be ignored if not relevant
            //value += "/skin0 materialsDesert1/pax_skin0 materialsDesert1_" + armyAdd + "/skin1 materialsDesert1/pax_skin1 materialsDesert1_" + armyAdd + "/skin2 materialsDesert1/pax_skin2 materialsDesert1_" + armyAdd;
            */

            value += "/skin materialsDesert1";
        }
        //Console.WriteLine("Load Static: {0} {1}", key, type);
        f.add(sect, key, value);

        staticCount++;

        return f;

    }

    public static ISectionFile makeAIChief(ISectionFile f, maddox.game.IGamePlay GamePlay, AMission mission, double x, double y, double z, double radius, double chiefNum = 0, double heading = 0, bool resetCount = false)
    {
        /*  side = nn , gb, or de
         * Examples: https://theairtacticalassaultgroup.com/forum/archive/index.php/t-5830.html
         *[AIChiefs]
                    AIChief_0 0 12383 17457/r 500
                    (coordinates and the name of his can be set by creator)

                    then by hand only, alas, the relevant anti-aircraft guns tied to Chief, "/target AIChief_0 ", like this:

                    [Stationary]
                    Static0 Artillery.3_inch_20_CWT_QF_Mk_I gb 12329.35 17412.88 0.00 /timeout 0/radius_hide 0 /target AIChief_0
                    Static5 Artillery.3_7_inch_QF_Mk_I gb 12308.17 17452.48 0.00 /timeout 0/radius_hide 0 /target AIChief_0
                */

        if (resetCount) staticCount = 0;

        string sect = "AIChiefs";
        string key = "AIChief_" + chiefNum.ToString("F0");
        
        string value = " 0 " + x.ToString("0.00") + " " + y.ToString("0.00") + "/r " + radius.ToString("F2");  //Not sure what the  " 0 " does        

        f.add(sect, key, value);

        staticCount++;
        //Console.WriteLine("Load AIChief : " + f.ToString());
        //Console.WriteLine("Load Static: {0} {1}", key, "AIChief - artillery");
        return f;

    }
    public static void listStatics(maddox.game.IGamePlay GamePlay, List<string> types_to_remove) //types is a SUBSTRING MATCH and CASE INSENSITIVE
    {
        int count = 0;
        int count2 = 0;
        List<GroundStationary> ggList = new List<GroundStationary>(GamePlay.gpGroundStationarys().ToList());
        foreach (GroundStationary gg in ggList) 
        {
            //var match = types_to_remove.FirstOrDefault(stringToCheck => stringToCheck.Contains(gg.Category));

            if (gg == null) continue;
            /*bool match = false;
            foreach (string s in types_to_remove)
            {
                count2++;
                if (gg.Title.ToLower().Contains(s.ToLower()))
                {
                    match = true;
                    break;
                }
            }
            */
            //if (!types_to_remove.Contains(gg.Category)) continue;                
            //if (!match) continue;
            try
            {
                Console.WriteLine("listStatics: Name: {0} category: {1} title: {2} type: {3} ", gg.Name, gg.Category, gg.Title, gg.Type.ToString());
            }
            catch (Exception ex)
            {
                if (gg != null) Console.WriteLine("listStatics: Couldn't do something with name {0}", gg.Name);
                else { Console.WriteLine("listStatics: couldn't do something ERROR"); }
            }
            count++;
        }
        Console.WriteLine("listedStatics: Listed {0} items of {1} ... ", count, count2);
    }
    //gpGroundStationarys()
    public static void removeStatics(maddox.game.IGamePlay GamePlay, Mission msn, double x, double y, double radius_m, List<string> types_to_remove, int percentToRemove = 100) //types is a SUBSTRING MATCH and CASE INSENSITIVE
    {
        Task.Run(() =>
        {
            try
            {
                int count = 0;
                List<GroundStationary> ggList = new List<GroundStationary>(GamePlay.gpGroundStationarys(x, y, radius_m).ToList());
                foreach (GroundStationary gg in ggList) //all stationaries w/i given radiusr meters of this object
                {
                    //var match = types_to_remove.FirstOrDefault(stringToCheck => stringToCheck.Contains(gg.Category));
                    try
                    {
                        //Console.WriteLine("removeStatics: Checking airfield item name: {0} category: {1} title: {2} type: {3} ", gg.Name, gg.Category, gg.Title, gg.Type.ToString());
                    }
                    catch (Exception ex)
                    {
                        if (gg != null) Console.WriteLine("removeStatics: Couldn't do something with name {0}", gg.Name);
                        else { Console.WriteLine("removeStatics: couldn't do something ERROR"); }
                    }
                    if (gg == null) continue;
                    bool match = false;
                    foreach (string s in types_to_remove)
                    {
                        if (gg.Title.ToLower().Contains(s.ToLower()))
                        {
                            match = true;
                            break;
                        }
                    }
                    //if (!types_to_remove.Contains(gg.Category)) continue;                
                    if (!match) continue;
                    if (clc_random.Next(100) > percentToRemove) continue; //remove only a certain percent, if requested
                    msn.Timeout(clc_random.Next(5, 300), () => { gg.Destroy(); });  //somewhat cheap way to avoid deleting items in ggList while looping through it, but also spreads the removal of stationaries over 5 mins or so instead of just zapping them all at once, which usually looks fake.
                    count++;
                }
                Console.WriteLine("removeStatics: Removed {0} items matching {1} ... ", count, types_to_remove[0]);
            }
            catch (Exception ex) { Console.WriteLine("removeStatics ERROR: " + ex.ToString()); }

        });
    }


    /*
     * 
     * 
     * 
     *   
  Aircraft.Ju-88A-1
  Aircraft.Bf-110C-4B
  Aircraft.Bf-110C-4
  Aircraft.Bf-110C-4Late
  Aircraft.Bf-109E-4B_Late
  Aircraft.Bf-109E-3B
  Aircraft.G50
  Aircraft.Bf-109E-1
  Aircraft.Bf-109E-1B
  Aircraft.He-111P-2
  Aircraft.He-111H-2
  Aircraft.Bf-109E-3
  Aircraft.BR-20M
  Aircraft.Ju-87B-2
  Aircraft.Bf-109E-4

  Aircraft.BlenheimMkIV_Late
  Aircraft.BlenheimMkIVNF_Late
  Aircraft.BeaufighterMkIF
  Aircraft.BeaufighterMkINF
  Aircraft.SpitfireMkI
  Aircraft.BlenheimMkIV
  Aircraft.SpitfireMkIa
  Aircraft.SpitfireMkIa_100oct
  Aircraft.BlenheimMkIVF
  Aircraft.HurricaneMkI_100oct
  Aircraft.BlenheimMkIVNF
  Aircraft.BlenheimMkIVF_Late
  Aircraft.SpitfireMkI_100oct
  Aircraft.HurricaneMkI_100oct-NF
  Aircraft.HurricaneMkI_dH5-20_100oct
  Aircraft.HurricaneMkI_dH5-20
  Aircraft.HurricaneMkI_100oct
  Aircraft.HurricaneMkI_FB
     * */

    /* CLOD 4.5 VERSION****************************************
        //All aircraft of each army/
        //True/false is whether they will be loaded in the "basic" birthplace.
        public static Dictionary<int, Dictionary<string, bool>> FullAircraftList = new Dictionary<int, Dictionary<string, bool>>
        {
            { 1, new Dictionary<string,bool>() {
                {"bob:Aircraft.BlenheimMkIV_Late",true},
                {"bob:Aircraft.HurricaneMkI_100oct",true},
                {"bob:Aircraft.BlenheimMkIV", true},
                {"bob:Aircraft.SpitfireMkIa_100oct",true},
                { "bob:Aircraft.BeaufighterMkIF", true},
                {"bob:Aircraft.BeaufighterMkINF", false},        
                {"bob:Aircraft.BlenheimMkIVF",false},
                {"bob:Aircraft.BlenheimMkIVF_Late",false},
                {"bob:Aircraft.BlenheimMkIVNF",false},
                {"bob:Aircraft.BlenheimMkIVNF_Late",false},        
                {"bob:Aircraft.WellingtonMkIc",false},
                //{"bob:Aircraft.DH82A-1",10},  aircraft remmed out or not on list have no restrictions so if you dont want any //of these available use amount 0 like below
                {"bob:Aircraft.DH82A-2",false},
                {"bob:Aircraft.HurricaneMkI",false},        
                {"bob:Aircraft.HurricaneMkI_100oct-NF",false},
                {"bob:Aircraft.HurricaneMkI_dH5-20",false},
                {"bob:Aircraft.HurricaneMkI_dH5-20_100oct",false},
                {"bob:Aircraft.HurricaneMkI_FB",true},
                {"bob:Aircraft.SpitfireMkI",false},
                {"bob:Aircraft.SpitfireMkIa",false},        
                {"bob:Aircraft.SpitfireMkI_100oct",false},
                {"bob:Aircraft.SpitfireMkIIa",false}
            } },
            { 2, new Dictionary <string,bool>(){
                {"bob:Aircraft.Ju-88A-1",true},
                { "bob:Aircraft.Bf-109E-3",true},
                {"bob:Aircraft.Ju-87B-2",true},
                {"bob:Aircraft.G50",true},
                {"bob:Aircraft.Bf-109E-1",true},
                {"bob:Aircraft.Bf-109E-1B",true},
                {"bob:Aircraft.Bf-109E-3B",true},
                {"bob:Aircraft.Bf-109E-4",false},
                {"bob:Aircraft.Bf-109E-4_Late",false},
                {"bob:Aircraft.Bf-110C-2",true},
                {"bob:Aircraft.Bf-110C-4",true},
                {"bob:Aircraft.Bf-110C-4-NJG",false},
                {"bob:Aircraft.Bf-110C-4B" ,false},
                {"bob:Aircraft.Bf-110C-4Late",false},
                {"bob:Aircraft.Bf-110C-4N",false},
                {"bob:Aircraft.Bf-110C-6",false},  //These crash straight into the ground upon spawn FOR SOME UNKNOWN REASON so just eliminating their use altogether here.
                {"bob:Aircraft.Bf-110C-7",false},
                {"bob:Aircraft.BR-20M",true},	
                //{"bob:Aircraft.DH82A-1",10},  aircraft not on list aren't allowed as escorts, so disallow by either setting to FALSE or just remming out their line
                {"bob:Aircraft.DH82A-2",false},

                {"bob:Aircraft.He-111H-2",true},
                {"bob:Aircraft.He-111P-2",false},
                {"bob:Aircraft.Do-17Z-2",false},
                {"bob:Aircraft.Bf-109E-4B",false},
                {"bob:Aircraft.Bf-109E-4B_Late",false},
                {"bob:Aircraft.Bf-109E-4N",false},
                {"bob:Aircraft.Bf-109E-4N_Late",false},
            }
            }

        };
    ******************************************************/

    //All aircraft of each army/
    //True/false is whether they will be loaded in the "basic" birthplace.
    public static Dictionary<int, Dictionary<string, bool>> FullAircraftList = new Dictionary<int, Dictionary<string, bool>>
    {
        { 1, new Dictionary<string,bool>() {
            {"bob:Aircraft.BeaufighterMkIF", false},
            {"bob:Aircraft.BeaufighterMkINF", false},
            {"bob:Aircraft.BlenheimMkIV", false},
            {"bob:Aircraft.BlenheimMkIV_Late", false},
            {"bob:Aircraft.BlenheimMkIVF", false},
            {"bob:Aircraft.BlenheimMkIVF_Late", false},
            {"bob:Aircraft.BlenheimMkIVNF", false},
            {"bob:Aircraft.BlenheimMkIVNF_Late", false},
            {"bob:Aircraft.DH82A", false},
            {"bob:Aircraft.DH82A_1940", false},
            {"bob:Aircraft.DH82A-1", false},
            {"bob:Aircraft.DH82A-2", false},
            {"bob:Aircraft.GladiatorMkII", false},
            {"bob:Aircraft.HurricaneMkI", false},
            {"bob:Aircraft.HurricaneMkI_100oct", false},
            {"bob:Aircraft.HurricaneMkI_100oct-NF", false},
            {"bob:Aircraft.HurricaneMkI_dH5-20", false},
            {"bob:Aircraft.HurricaneMkI_dH5-20_100oct", false},
            {"bob:Aircraft.HurricaneMkI_FB", false},
            {"bob:Aircraft.SpitfireMkI", false},
            {"bob:Aircraft.SpitfireMkI_100oct", false},
            {"bob:Aircraft.SpitfireMkI_Heartbreaker", false},
            {"bob:Aircraft.SpitfireMkIa", false},
            {"bob:Aircraft.SpitfireMkIa_100oct", false},
            {"bob:Aircraft.SpitfireMkIIa", false},
            {"bob:Aircraft.WellingtonMkIc", false},
            {"tobruk:Aircraft.BeaufighterMkIC", false},
            {"tobruk:Aircraft.BeaufighterMkIC_Trop", true},
            {"tobruk:Aircraft.BeaufighterMkIF_Late", false},
            {"tobruk:Aircraft.BeaufighterMkIF_Late_Trop", true},
            {"tobruk:Aircraft.BeaufighterMkINF_Late", false},
            {"tobruk:Aircraft.BeaufighterMkINF_Late_Trop", true},
            {"tobruk:Aircraft.BlenheimMkIV_Late_Trop", true},
            {"tobruk:Aircraft.BlenheimMkIV_Trop", true},
            {"tobruk:Aircraft.BlenheimMkIVF_Late_Trop", true},
            {"tobruk:Aircraft.BlenheimMkIVNF_Late_Trop", true},
            {"tobruk:Aircraft.D520_Serie1", false},
            {"tobruk:Aircraft.D520_Serie1_Trop", true},
            {"tobruk:Aircraft.DH82A_Trop", true},
            {"tobruk:Aircraft.GladiatorMkII_trop", true},
            {"tobruk:Aircraft.HurricaneMkI_FB-Trop", true},
            {"tobruk:Aircraft.HurricaneMkIIa", false},
            {"tobruk:Aircraft.HurricaneMkIIaTrop", true},
            {"tobruk:Aircraft.HurricaneMkIIb", false},
            {"tobruk:Aircraft.HurricaneMkIIb-Late", false},
            {"tobruk:Aircraft.HurricaneMkIIbTrop", true},
            {"tobruk:Aircraft.HurricaneMkIIbTrop-Late", true},
            {"tobruk:Aircraft.HurricaneMkIIc", false},
            {"tobruk:Aircraft.HurricaneMkIIc-Late", false},
            {"tobruk:Aircraft.HurricaneMkIIc-Trop", true},
            {"tobruk:Aircraft.HurricaneMkIIc-Trop-Late", true},
            {"tobruk:Aircraft.HurricaneMkIId", false},
            {"tobruk:Aircraft.HurricaneMkIId-Trop", true},
            {"tobruk:Aircraft.KittyhawkMkIA", false},
            {"tobruk:Aircraft.KittyhawkMkIA-Trop", true},
            {"tobruk:Aircraft.MartletMkIII", false},
            {"tobruk:Aircraft.MartletMkIII_Trop", true},
            {"tobruk:Aircraft.SpitfireMkIIb", false},
            {"tobruk:Aircraft.SpitfireMkVa", false},
            {"tobruk:Aircraft.SpitfireMkVb", false},
            {"tobruk:Aircraft.SpitfireMkVb-HF", false},
            {"tobruk:Aircraft.SpitfireMkVb-HF-Late", false},
            {"tobruk:Aircraft.SpitfireMkVb-HF-Trop", false},
            {"tobruk:Aircraft.SpitfireMkVbLate", false},
            {"tobruk:Aircraft.SpitfireMkVbTrop", false},
            {"tobruk:Aircraft.TomahawkMkII", false},
            {"tobruk:Aircraft.TomahawkMkII-Late", false},
            {"tobruk:Aircraft.TomahawkMkII-Late-Trop", false},
            {"tobruk:Aircraft.TomahawkMkII-Trop", true},
            {"tobruk:Aircraft.WellingtonMkIa_trop", false},  //They are causing launcher lock-ups for now/ 2020-09
            {"tobruk:Aircraft.WellingtonMkIc_Late", false},
            {"tobruk:Aircraft.WellingtonMkIc_Late_trop", true},
            {"tobruk:Aircraft.WellingtonMkIc_t", false},
            {"tobruk:Aircraft.WellingtonMkIc_Torpedo", false},
            {"tobruk:Aircraft.WellingtonMkIc_Torpedo_Trop", true},
            {"tobruk:Aircraft.WellingtonMkIc_trop", true},
      
            
        } },
        { 2, new Dictionary <string,bool>(){
            {"bob:Aircraft.Bf-108B-2",false},
            {"bob:Aircraft.Bf-109E-1",false},
            {"bob:Aircraft.Bf-109E-1B",false},
            {"bob:Aircraft.Bf-109E-3",false},
            {"bob:Aircraft.Bf-109E-3B",false},
            {"bob:Aircraft.Bf-109E-4",false},
            {"bob:Aircraft.Bf-109E-4_Late",false},
            {"bob:Aircraft.Bf-109E-4B",false},
            {"bob:Aircraft.Bf-109E-4B_Late",false},
            {"bob:Aircraft.Bf-109E-4N",false},
            {"bob:Aircraft.Bf-109E-4N_Late",false},
            {"bob:Aircraft.Bf-110C-2",false},
            {"bob:Aircraft.Bf-110C-4",false},
            {"bob:Aircraft.Bf-110C-4B",false},
            {"bob:Aircraft.Bf-110C-4Late",false},
            {"bob:Aircraft.Bf-110C-4N",false},
            {"bob:Aircraft.Bf-110C-4-NJG",false},
            {"bob:Aircraft.Bf-110C-6",false},
            {"bob:Aircraft.Bf-110C-7",false},
            {"bob:Aircraft.BR-20M",false},
            {"bob:Aircraft.CR42",false},
            {"bob:Aircraft.DH82A",false},
            {"bob:Aircraft.DH82A_1940",false},
            {"bob:Aircraft.DH82A-1",false},
            {"bob:Aircraft.DH82A-2",false},
            {"bob:Aircraft.G50",false},
            {"bob:Aircraft.He-111H-2",false},
            {"bob:Aircraft.He-111P-2",false},
            {"bob:Aircraft.Ju-87B-2",false},
            {"bob:Aircraft.Ju-88A-1",false},
            {"tobruk:Aircraft.Bf-108B-2_Trop",true},
            {"tobruk:Aircraft.Bf-109E-7",false},
            {"tobruk:Aircraft.Bf-109E-7_Trop",true},
            {"tobruk:Aircraft.Bf-109E-7N",false},
            {"tobruk:Aircraft.Bf-109E-7N_Trop",true},
            {"tobruk:Aircraft.Bf-109E-7Z",false},
            {"tobruk:Aircraft.Bf-109F-1",false},
            {"tobruk:Aircraft.Bf-109F-2",false},
            {"tobruk:Aircraft.Bf-109F-2_Late",false},
            {"tobruk:Aircraft.Bf-109F-2_Trop",true},
            {"tobruk:Aircraft.Bf-109F-4",false},
            {"tobruk:Aircraft.Bf-109F-4_Derated",false},
            {"tobruk:Aircraft.Bf-109F-4_trop",true},
            {"tobruk:Aircraft.Bf-109F-4_trop_Derated",true},
            {"tobruk:Aircraft.Bf-109F-4Z",false},
            {"tobruk:Aircraft.Bf-109F-4Z_trop",true},
            {"tobruk:Aircraft.Bf-110C-4B_Trop",true},
            {"tobruk:Aircraft.Bf-110C-4N-NJG_Trop",true},
            {"tobruk:Aircraft.Bf-110C-6_Trop",true},
            {"tobruk:Aircraft.Bf-110C-7_Trop",true},
            {"tobruk:Aircraft.BR-20M_Trop",true},
            {"tobruk:Aircraft.CR42_Trop",true},
            {"tobruk:Aircraft.D520_Serie1",false},
            {"tobruk:Aircraft.D520_Serie1_Trop",true},
            {"tobruk:Aircraft.DH82A_Trop",true},
            {"tobruk:Aircraft.G50_Trop",true},
            {"tobruk:Aircraft.He-111H-2_Trop",true},
            {"tobruk:Aircraft.He-111H-6",false},
            {"tobruk:Aircraft.He-111H-6_Trop",true},
            {"tobruk:Aircraft.Ju-87B-2_Trop",true},
            {"tobruk:Aircraft.Ju-88A-5",false},
            {"tobruk:Aircraft.Ju-88A-5_Trop",true},
            {"tobruk:Aircraft.Ju-88A-5Late",false},
            {"tobruk:Aircraft.Ju-88A-5Late_Trop",true},
            {"tobruk:Aircraft.Ju-88C-1",false},
            {"tobruk:Aircraft.Ju-88C-2",false},
            {"tobruk:Aircraft.Ju-88C-2_Trop",true},
            {"tobruk:Aircraft.Ju-88C-4",false},
            {"tobruk:Aircraft.Ju-88C-4_Trop",true},
            {"tobruk:Aircraft.Ju-88C-4Late",false},
            {"tobruk:Aircraft.Ju-88C-4Late_Trop",true},
            {"tobruk:Aircraft.Macchi-C202-SeriesIII",false},
            {"tobruk:Aircraft.Macchi-C202-SeriesIII-AltoQuota",true},
            {"tobruk:Aircraft.Macchi-C202-SeriesVII",false},
            {"tobruk:Aircraft.Macchi-C202-SeriesVII-AltoQuota",true},
        }
        }

    };

    //By Kodiak, our hero
    //http://forum.1cpublishing.eu/showpost.php?p=438212&postcount=40
    //
    public static ISectionFile CreateBirthPlace(ISectionFile f, string name,double x, double y, double z, int army, int maxplanes = 1, bool setonpark = true, bool isparachute = true, string _country = "", string _hierarchy = "", string _regiment = "")
    {

        //ISectionFile f = GamePlay.gpCreateSectionFile();
        string sect;
        string key;
        string value;

        sect = "BirthPlace";

        key = "BirthPlace" + clc_random.Next(1000, 9999).ToString("F0");

        if (name != null & name.Length > 0) key = name.Trim();

        int maxLen = 24;
        if (name.Length < 25) maxLen = name.Length; //cant send substring a value > the actual Length of the string. Boo.

        if (name.Length >= 25) name = name.Substring(0, maxLen); //The name seems to be restricted to 25 chars at most?  Or something?

        int setOnPark = 0;

        if (setonpark)
            setOnPark = 1;

        int isParachute = 0;

        if (isparachute)
            isParachute = 1;


        string country = ".";

        if (_country != null && _country.Length > 0)
            country = _country;


        string hierarchy = ".";

        if (_hierarchy != null && _hierarchy.Length > 0)
            hierarchy = _hierarchy;

        string regiment = ".";

        if (_regiment != null && _regiment.Length > 0)
            regiment = _regiment;


        //And so apparently the x,y,z coordinates here cannot have any decimal points. 
        //Despite the fact the they are OK in EVERY other similar place.  Arrggghhh.
        value = army.ToString(CultureInfo.InvariantCulture) + " " + x.ToString("F0") + " "
            + y.ToString("F0") + " " + z.ToString("F0") + " "
            + maxplanes.ToString("F0") + " " + setOnPark.ToString("F0") + " "
            + isParachute.ToString("F0") + " " + country + " " + hierarchy + " " + regiment;

        Console.WriteLine("Creating Birthplace: " + value);

        f.add(sect, key, value);

        sect = "BirthPlace0";
        Dictionary<string, bool> planeSet = FullAircraftList[army];
        if (planeSet.Count > 0)
            foreach (string plane in planeSet.Keys)
            {
                if (!planeSet[plane]) continue;
                key = plane;
                value = "";
                f.add(sect, key, value);
            }

        return f;
    }

    public static ISectionFile addFlights (string section, ISectionFile f, int numToAdd, int maxInFlight, int maxFlights)
    {
        int count = 0;
        string k, v;
        Console.WriteLine("Fl: {0} {1} {2}", section, numToAdd, maxInFlight, maxFlights);
        for (int i = 0; i<maxFlights; i++)
        {
            string flight = "";
            for (int j = 1; j <= maxInFlight; j++) //flights count 0,1,2 but aircraft within the flight a 1,2,3
            {
                flight += i.ToString() + j.ToString() + " ";
                count++;
                if (count >= numToAdd) break;
            }

            k = "Flight" + i.ToString(); v = flight; f.add(section, k, v);
            Console.WriteLine("Fl: {0} {1} {2}", section, k, v);

            if (count >= numToAdd) break;
        }
        return f;
    }

    //Make a Bomber that targets ground_attack_target (groundactor, stationary like vehicle convoy, artillery/aa, or stationary item) at most points: p1 p2 gat p4 
    //    (idea is gat is the point you think it will be at but it starts hunting before/after for the same groundactor_target)
    //but also (sometimes) point attack at a later point in the flight in case it misses the ground 
    //    (idea is, if it misses the _target it will still drop on say a nearby airport)
    //    However for Tobruk Bumrushes we found EVERY formation dropping on airport just was too much (so much smoke/craters) so we cut the % to airportbombchance
    //    and the rest instead keep hunting for the _target for gap p5 and back to gap p4 gat p2 before exiting

    // nextflightchance is the % chance to choose a 2nd & then 3rd flight, thus adding more to the formation.  This is overriden for some plane types that need more aircraft in the flight be be effective
    // Making this higher will add more flights more often, thus on average more aircraft.

    //Notes on bomber weapons needed etc based on flight tests
                //Weapons 1 1 1 1 1 1 4 //JU88 best
                //Weapons 1 1 1 1 1 1 2//he111 h2 with 8x250 bombs which is way better then 32X50
                //Weapons 1 1 1 1 1 1 4 //32x50bombs, worse
                //Weapons 1 1 1 1  //BR20
                //Weapons 1 1 1 4 //110-4B
                //Weapons 1 1 2 1 //jU87

                //Weapons 1 1 1 //Wellington 1A 9X500
                //  //Wellington 1C is same, but only drops one bomb in 9X500 so not using
                //Weapons 1 1 1 1 1 1 //Sunderland
                //1 1 5 0 2 //All Blenheim types
                //Weapons 1 1 1 //Beaufighter 1C - needs more planes VIC note best formation, they crash, lineabreast astern, echelon better
                //Weapons 1 3  //Hurricane 2C - needs more planes, lower altitude ~800m
                //Weapons 1 2//Hurricane  1FB- needs more planes, lower altitude ~800m  .  Only drops half ordnance, so not using.

    public static ISectionFile BuildBomber(IGamePlay GamePlay, Mission mission, int bomberArmy, double vel_kmh, double alt_m, Point3d p1, Point3d p2, Point3d gat, Point3d p4, Point3d gap, Point3d p6, Point3d lan, string gat_targ = "1_Chief 1", string gap_targ = "", string attack_type="LEVEL", double airportBombChance = 0.15, int numInFlight = 2)
    {
        try
        {
            //double nextFlightChance = 0.5; //Chance  of choosing a 2nd, 3rd flight

            ISectionFile f = GamePlay.gpCreateSectionFile();

            string aircraft = Calcs.randSTR(new string[] { "tobruk:Aircraft.Ju-88A-5Late_Trop", "tobruk:Aircraft.Ju-88A-5_Trop", "tobruk:Aircraft.Ju-88A-5",  "tobruk:Aircraft.Ju-88A-5",  "tobruk:Aircraft.Ju-88A-5",  "tobruk:Aircraft.Ju-88A-5", "tobruk:Aircraft.Ju-87B-2_Trop", "tobruk:Aircraft.Ju-87B-2_Trop","bob:Aircraft.Ju-87B-2","bob:Aircraft.Ju-87B-2", "tobruk:Aircraft.Bf-110C-4B_Trop", "bob:Aircraft.Bf-110C-4B", "bob:Aircraft.Bf-110C-4B", "tobruk:Aircraft.BR-20M_Trop","tobruk:Aircraft.BR-20M_Trop","tobruk:Aircraft.BR-20M_Trop","tobruk:Aircraft.BR-20M_Trop", "bob:Aircraft.BR-20M", "bob:Aircraft.He-111H-2"
        });
            //string formation = "FINGERFOUR";
            string formation = Calcs.randSTR(new string[] { "FINGERFOUR", "FINGERFOUR", "VIC3", "LINEABREAST", "VIC3", "LINEABREAST", "LINEASTERN", "ECHELONRIGHT", "ECHELONLEFT", "ECHELONRIGHT", "ECHELONLEFT" }); //VIC only works for blue; VIC3 works for both, per 4.57 trials
            string weapons = "1 1 1 1 1 1 4";
            string groupname = "tobruk:Tobruk_LW_JG3_II." + clc_random.Next(1, 15).ToString("00");
            List<string> detonatorL = new List<string>() {"Bomb.SC-500_GradeIII_K 0 -1 0.08", "Bomb.SD-250 0 -1 0.08", "Bomb.SC-250_Type1_J 2 -1 0.08", "Bomb.SD-500_A 0 -1 0.08", "Bomb.SC-50_GradeII_J 1 -1 0.08"    };

            if (bomberArmy == 1)
            {
                aircraft = Calcs.randSTR(new string[] { "tobruk:Aircraft.BlenheimMkIV_Trop", "tobruk:Aircraft.BlenheimMkIV_Late_Trop", "bob:Aircraft.BlenheimMkIV_Late", "tobruk:Aircraft.BlenheimMkI_Trop", "tobruk:Aircraft.BeaufighterMkIC_Trop", "tobruk:Aircraft.SunderlandMkI_Trop", "tobruk:Aircraft.BeaufighterMkIC_Trop", "tobruk:Aircraft.BeaufighterMkIC", "tobruk:Aircraft.HurricaneMkIIc-Trop-Late", "tobruk:Aircraft.HurricaneMkIIc-Trop", "tobruk:Aircraft.WellingtonMkIa_trop", "tobruk:Aircraft.WellingtonMkIa_trop", "tobruk:Aircraft.WellingtonMkIc_Late_trop", "tobruk:Aircraft.WellingtonMkIc_Late_trop" }); //,  REMOVING welllingtons because launcher lock-up problem caused 2020/09.  2020/09/17, putting them back.

                //"tobruk:Aircraft.WellingtonMkIa" doesn't exist!  Only "tobruk:Aircraft.WellingtonMkIa_trop"  or "bob:Aircraft.WellingtonMkIc".  But 2020/09/01, the MkIc wellingtons are bugged & wont' release bombs properly.  Ia seems OK.  Haven't tried bob:Ic

                //Welly 1A works great, 9X250 best. But 1C drops one bomb ONLY.  Don't use until fixed.
                formation = Calcs.randSTR(new string[] { "VIC3", "LINEABREAST", "VIC3", "LINEABREAST", "LINEASTERN", "ECHELONRIGHT", "ECHELONLEFT","ECHELONRIGHT", "ECHELONLEFT" }); //VIC only works for blue; VIC3 works for both, per 4.57 trials
                weapons = "1 1 5 0 2";
                detonatorL = new List<string>() { "Bomb.Bomb_GP_40lb_MkIII 0 30 0.025", "Bomb.Bomb_GP_250lb_MkIV 0 30 0.025", "Bomb.Bomb_GP_500lb_MkIV 0 30 0.025" };
                groupname = "BoB_RAF_B_7Sqn." + clc_random.Next(1, 15).ToString("00");
            }
            Console.WriteLine("Bumrush Attack group: " + aircraft);

            if (aircraft.Contains("Ju-87"))
            {

                weapons = "1 1 2 1";
                detonatorL = new List<string>() { "Bomb.SC-500_GradeIII_J 0 -1 0.08", "Bomb.SC-50_GradeII_J_DivePreferred 0 -1 0.08", "Bomb.SC-250_Type1_J 2 -1 0", "Bomb.SD-250_JB 0 -1 0.08", "Bomb.SD-500_E 0 -1 0.08", "Bomb.SC-250_Type2_J 0 -1 0.08" };
                attack_type = "DIVE";
                if (p2.z < 2000) p2.z = 2000;
                if (gat.z < 2000) gat.z = 2000;
                numInFlight += clc_random.Next(Convert.ToInt32(numInFlight / 2.0)+1); //might add some extras
                if (numInFlight < 3) numInFlight = 3; //need @ least 3 to be effective here.  Maybe  4, realistically?
                //if (gap.z < 2000) gap.z = 2000; //We'll try dive bomb on gat & just regular on gap
                //BUG: The STUKA (only???!??) if it has TWO landing waypoints, will IMMEDIATELY drop all bombs, upon spawning in.  So, that is crazy.  But only put ONE landing waypoint.

            }
            if (aircraft.Contains("Ju-88"))
            {
                weapons = "1 1 1 1 1 1 4";
            }
            else if (aircraft.Contains("BR-20"))
            {
                weapons = "1 1 1 1";
                detonatorL = new List<string>() { "Bomb.Bomb_GP_40lb_MkIII 0 30 0.025", "Bomb.Bomb_GP_250lb_MkIV 0 30 0.025", "Bomb.Bomb_GP_500lb_MkIV 0 30 0.025" };
            }
            else if (aircraft.Contains("Bf-110"))
            {
                weapons = "1 1 1 4";
                //nextFlightChance = 0.4;
            }
            else if (aircraft.Contains("He-111"))
            {
                weapons = "1 1 1 1 1 1 2";
                //nextFlightChance = 0.3;
            }
            else if (aircraft.Contains("BlenheimMkIV_Late"))
            {
                weapons = "1 1 5 1 2";
            }
            else if (aircraft.Contains("Blenheim"))
            {
                weapons = "1 1 5 0 2";
            }
            else if (aircraft.Contains("WellingtonMkIc"))
            {
                //2020-09, Wellington 1c only drops one bomb!  But with 11511 it's a 1000 pounder, a doozy.  So a pretty good plane.
                weapons = "1 1 5 1 1"; //2020/09 wellingtons certain loadout causes lockup of launcher.  So we are just disabling all wellington bomb loadouts for now ( plus all wellingtons period)
                detonatorL = new List<string>() { "Bomb.Bomb_GP_1000lb_MkI 3 0 0.025" };
            }
            else if (aircraft.Contains("Wellington"))
            {
                //2020-09, Wellington 1A/1A-trop works well, drops 9X500lb in a salvo
                weapons = "1 1 1"; //2020/09 wellingtons certain loadout causes lockup of launcher.  So we are just disabling all wellington bomb loadouts for now ( plus all wellingtons period)
                detonatorL = new List<string>() { "Bomb.Bomb_GP_1000lb_MkI 3 0 0.025", "Bomb.Bomb_GP_250lb_MkIV 3 0 0.12", "Bomb.Bomb_GP_500lb_MkIV 3 0 0.12" };
            }
            else if (aircraft.Contains("Sunderland"))
            {
                weapons = "1 1 1 1 1 1";
                numInFlight = numInFlight/2 + clc_random.Next(Convert.ToInt32(numInFlight / 2.0)+1); //might reduce #s a bit
            }
            else if (aircraft.Contains("Beaufighter"))
            {
                weapons = "1 1 1";
                numInFlight += clc_random.Next(Convert.ToInt32(numInFlight / 2.0)+1); //might add some extras
                if (formation.Contains("VIC")) formation = Calcs.randSTR(new string[] { "LINEABREAST", "LINEASTERN", "ECHELONRIGHT", "ECHELONLEFT" }); //VIC only works for blue; VIC3 works for both, per 4.57 trials
                numInFlight += clc_random.Next(Convert.ToInt32(3.00 * numInFlight / 2.0) + 1); //might add some extras
                if (numInFlight < 3) numInFlight = 3; //need @ least 3 to be effective here
            }
            else if (aircraft.Contains("Aircraft.HurricaneMkIIc"))
            {
                weapons = "1 1 1 1 1 1 2";
                //nextFlightChance = 0.8;
                numInFlight += clc_random.Next(Convert.ToInt32(3.00 * numInFlight / 2.0)+1); //might add some extras
                if (alt_m > 800) alt_m = clc_random.Next(400, 800);
                if (numInFlight < 4) numInFlight = 4; //need @ least 4 to be effective here.  Maybe 5 realistically
            }

            string s = "";
            string k = "";
            string v = "";

            s = "AirGroups";
            k = groupname; v = ""; f.add(s, k, v);
            s = groupname;

            f = addFlights(s, f, numInFlight, 3, 3);

            /*
            k = "Flight0"; v = Calcs.randSTR(new string[] { "1", "1", "1", "1 2", "1 2", "1 2", "1 2", "1 2 3", "1 2 3" }); f.add(s, k, v);

            string adder = "1 2 3";
            bool secondFl = false;
            if (nextFlightChance >= 0.8)
            {
                adder = "1 2 3 4";
                secondFl = true;
                if (formation.Contains("LINEASTERN")) formation = "LINEABREAST";
            }
            bool avoidThirdFl = false;
            if (clc_random.NextDouble() < nextFlightChance * nextFlightMult || secondFl)
            {
                f.add(s, k, adder); //OK, we're saying adding a new flight always implies the first one is **full**
                k = "Flight1"; v = Calcs.randSTR(new string[] { "11", "11", "11 12", "11 12", "11 12", "11 12", "11 12", "11 12 13", "11 12 13" }); f.add(s, k, v);
                if (nextFlightChance >= 0.95) { f.add(s, k, "1 2 3 4"); avoidThirdFl = true; }
            }
            
            if (clc_random.NextDouble() < nextFlightChance * nextFlightMult && !avoidThirdFl)            {
                f.add(s, k, "11 12 13"); //OK, we're saying adding a new 3rd flight always implies the second one is **full**
                k = "Flight2"; v = Calcs.randSTR(new string[] { "", "", "", "", "21", "21", "", "21 22", "21 22" }); f.add(s, k, v);
            }
            */

            k = "Class"; v = aircraft; f.add(s, k, v);
            k = "Formation"; v = formation; f.add(s, k, v);
            k = "CallSign"; v = clc_random.Next(1, 33).ToString(); f.add(s, k, v); //looks like maybe there are only 35 official callsigns and up through TF 5.005 choosing the last of those will cause an regular error.
            k = "Fuel"; v = "40"; f.add(s, k, v);
            k = "Weapons"; v = weapons; f.add(s, k, v);
            foreach (string d in detonatorL)
            {
                k = "Detonator"; v = d; f.add(s, k, v);
            }
            k = "Skill"; v = string.Format("{0:N2} {1:N2} {2:N2} {3:N2} {4:N2} {5:N2} {6:N2} {7:N2}", new object[] {clc_random.Next(25,75)/100.0, clc_random.Next(25, 75) / 100.0, clc_random.Next(25, 75) / 100.0,
             clc_random.Next(95,101)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0});// "0.32 0.32 1 0.58 0.32 1 0.32 0.32"; f.add(s, k, v);
            k = "Aging"; v = clc_random.Next(5, 90).ToString(); f.add(s, k, v);

            s = groupname + "_Way";
            k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p1.x, p1.y, p1.z, vel_kmh }); f.add(s, k, v);

            double gatGapDistance_m = Calcs.CalculatePointDistance(gat, gap);
            if (gatGapDistance_m > 600)
            {

                if (aircraft.Contains("Ju-87")) { k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p2.x, p2.y, p2.z, vel_kmh }); f.add(s, k, v); }
                else { k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { p2.x, p2.y, p2.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v); }
                //k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p2.x, p2.y, p2.z, vel_kmh}); f.add(s, k, v);
                k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gat.x, gat.y, gat.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                //k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} /GAttackType {5}", new object[] { p4.x, p4.y, p4.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);

                if (aircraft.Contains("Ju-87")) { k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { gat.x + 100, gat.y + 100, 100, vel_kmh }); f.add(s, k, v); }
                k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p4.x, p4.y, p4.z, vel_kmh}); f.add(s, k, v);
                if (clc_random.NextDouble() < airportBombChance || gap_targ.Length>0)
                {
                    //Sometimes we just drop them on the airport OR the alternate ground target/actor
                    if (gap_targ.Length == 0) { k = "GATTACK_POINT"; v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, gap.z, vel_kmh }); f.add(s, k, v); }
                    else { k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gap.x, gap.y, gap.z, vel_kmh, gap_targ, attack_type }); f.add(s, k, v); }
                    k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p6.x, p6.y, p6.z, vel_kmh }); f.add(s, k, v);
                }
                else
                {
                    double angle = clc_random.NextDouble() * 2 * Math.PI;
                    double distance = clc_random.Next(500, 1500);
                    Point3d nearPointAdded = new Point3d(Math.Cos(angle) * distance, Math.Sin(angle) * distance, 0); //A point 1000-3200 meters from the center of the airport and at any random angle

                    //Sometimes (mostly) we circle back & try to hit the group again.
                    k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gat.x, gat.y, gat.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                    if (aircraft.Contains("Ju-87")) { k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { gat.x + 100, gat.y + 100, 100, vel_kmh }); f.add(s, k, v); }
                    k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { p2.x, p2.y, p2.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                    //k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p2.x, p2.y, p2.z, vel_kmh }); f.add(s, k, v);
                    k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gat.x, gat.y, gat.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                    if (aircraft.Contains("Ju-87")) { k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { gat.x + 100, gat.y + 100, 100, vel_kmh }); f.add(s, k, v); }
                    //k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} /GAttackType {5}", new object[] { p4.x, p4.y, p4.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                    k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p4.x, p4.y, p4.z, vel_kmh }); f.add(s, k, v);
                    //Sometimes we just drop them on the airport OR the alternate ground target/actor
                    if (gap_targ.Length == 0) { k = "GATTACK_POINT"; v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, gap.z, vel_kmh }); f.add(s, k, v); }
                    else { k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gap.x, gap.y, gap.z, vel_kmh, gap_targ, attack_type }); f.add(s, k, v); }
                    k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p6.x, p6.y, p6.z, vel_kmh }); f.add(s, k, v);
                }
            } 
            else //Case where the target is pretty much on the airport center.  In that case, the points are too close together to make a good flight plan with these points.
                 //Instead we just fly straight to the airport center & drop there, where the targets area.  The continue straight for 3km (makes for the best drop), then proceed off map
            {
                double p1GapDistance_m = Calcs.CalculatePointDistance(p1, gap);
                if (p1GapDistance_m < 1) p1GapDistance_m = 1;
                //New point is in the same direction as the vector from p1 to gap. So it continues the flight in this same direction for 3000 meters, then continues to landing point.
                Point3d newPoint = new Point3d((gap.x - p1.x) / p1GapDistance_m * 3000 + gap.x, (gap.y - p1.y) / p1GapDistance_m * 3000 + gap.y, gap.z);

                //Half the time to a target attack, half the time point ON the location of the TARGET.
                //Experiments in CLoD show, it is hard to say which works better.  Sometimes one, sometimes the other.
                if (clc_random.Next(2) == 0)
                {
                    k = "GATTACK_POINT"; v = String.Format("{0} {1} {2} {3}", new object[] { gat.x, gat.y, gat.z, vel_kmh }); f.add(s, k, v);
                } else
                {
                    k = "GATTACK_TARG"; v = String.Format("{0} {1} {2} {3} {4} 0 /GAttackType {5}", new object[] { gat.x, gat.y, gat.z, vel_kmh, gat_targ, attack_type }); f.add(s, k, v);
                }
                k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { newPoint.x, newPoint.y, newPoint.z, vel_kmh }); f.add(s, k, v);
                k = "NORMFLY"; v = String.Format("{0} {1} {2} {3}", new object[] { p6.x, p6.y, p6.z, vel_kmh }); f.add(s, k, v);                        
            }

            //New point 1/4 of the way from p6 to lan
            //If there is a friendly airport  nearby there, make it land there
            double minX = 6666 - 10000; //+/- 10000 because we want to send them beyond the "exit map" margin, not  just to it
            double minY = 6666 - 10000;
            double maxX = 362000 + 10000;
            double maxY = 362000 + 10000;

            Point3d l = lan;
            if (l.x > maxX) l.x = maxX;
            if (l.x > minX) l.x = minX;
            if (l.y > maxY) l.y = maxY;
            if (l.y > minY) l.y = minY;

            double mu = clc_random.NextDouble() * 5 + 2;

            Point3d apLook = new Point3d (mu*(p6.x + l.x)/2, mu*(p6.y + l.y)/8, lan.z);
            AiAirport ap = mission.covermission.Stb_nearestAirport(apLook, bomberArmy, isSeaplane: false);

            if (ap != null && CalculatePointDistance(ap.Pos(), p6) > 10000)
            {
                k = "LANDING"; v = String.Format("{0} {1} {2} {3}", new object[] { ap.Pos().x, ap.Pos().y, lan.z, vel_kmh }); f.add(s, k, v);
            }
            else
            {

                k = "LANDING"; v = String.Format("{0} {1} {2} {3}", new object[] { l.x, l.y, l.z, vel_kmh }); f.add(s, k, v);
            }
            //BUG: The STUKA (only???!??) if it has TWO landing waypoints, will IMMEDIATELY drop all bombs.  So, that is crazy.  But only put ONE landing waypoint.

            return f;
        }
        catch (Exception ex) { 
            Console.WriteLine("Calcs Build Bomber ERROR: " + ex.ToString()); 
            return GamePlay.gpCreateSectionFile();
       }
    }

    public static ISectionFile BuildFighter(IGamePlay GamePlay, Mission mission, int planeArmy, double vel_kmh, double alt_m, Point3d p1, Point3d p2, Point3d gat, Point3d p4, Point3d gap, Point3d p6, Point3d lan, string gat_targ = "1_Chief 1", string gap_targ = "", int numInFlight = 2)
    {
        try
        {
            //double nextFlightChance = 0.5; //Chance  of choosing a 2nd, 3rd flight

            ISectionFile f = GamePlay.gpCreateSectionFile();

            string aircraft = Calcs.randSTR(new string[] { "tobruk:Aircraft.Bf-109E-7N_Trop", "tobruk:Aircraft.Bf-109E-7_Trop", "tobruk:Aircraft.Bf-109F-2_Trop", "tobruk:Aircraft.Bf-110C-4N-NJG_Trop",
                "tobruk:Aircraft.BR-20M_Trop", "tobruk:Aircraft.G50_Trop", "tobruk:Aircraft.Macchi-C202-SeriesIII-AltoQuota", "tobruk:Aircraft.Macchi-C202-SeriesVII-AltoQuota"
                });
            //string formation = "FINGERFOUR";
            string formation = Calcs.randSTR(new string[] { "FINGERFOUR", "FINGERFOUR", "VIC3", "LINEABREAST", "VIC3", "LINEABREAST", "LINEASTERN", "ECHELONRIGHT", "ECHELONLEFT", "ECHELONRIGHT", "ECHELONLEFT" }); //VIC only works for blue; VIC3 works for both, per 4.57 trials
            
            //so this is a bomber group ID but it's also used in other routines, MoveBomb etc to let  it know this is a Tobruk bumrush group & so to leave it alone & not re-write its waypoints etc
            string groupname = "tobruk:Tobruk_LW_JG3_II." + clc_random.Next(1, 15).ToString("00");

            string weapons = "";
            List<string> detonatorL = new List<string>() { };


            if (planeArmy == 1)
            {
                aircraft = Calcs.randSTR(new string[] { "tobruk:Aircraft.BeaufighterMkIF_Late_Trop", "tobruk:Aircraft.BeaufighterMkINF_Late_Trop", "tobruk:Aircraft.BlenheimMkIVNF_Late_Trop", "tobruk:Aircraft.HurricaneMkIIbTrop", "tobruk:Aircraft.HurricaneMkIIc-Trop", "tobruk:Aircraft.HurricaneMkIId-Trop", "tobruk:Aircraft.MartletMkIII_Trop", "tobruk:Aircraft.TomahawkMkII-Late-Trop", "tobruk:Aircraft.HurricaneMkIIaTrop", "tobruk:Aircraft.BeaufighterMkIF_Late_Trop", "tobruk:Aircraft.HurricaneMkIIaTrop" 
                }); //,  REMOVING welllingtons because launcher lock-up problem caused 2020/09.  2020/09/17, putting them back.

                //"tobruk:Aircraft.WellingtonMkIa" doesn't exist!  Only "tobruk:Aircraft.WellingtonMkIa_trop"  or "bob:Aircraft.WellingtonMkIc".  But 2020/09/01, the MkIc wellingtons are bugged & wont' release bombs properly.  Ia seems OK.  Haven't tried bob:Ic

                //Welly 1A works great, 9X250 best. But 1C drops one bomb ONLY.  Don't use until fixed.
                formation = Calcs.randSTR(new string[] { "VIC3", "LINEABREAST", "VIC3", "LINEABREAST", "LINEASTERN", "ECHELONRIGHT", "ECHELONLEFT", "ECHELONRIGHT", "ECHELONLEFT" }); //VIC only works for blue; VIC3 works for both, per 4.57 trials

                //so this is a bomber group ID but it's also used in other routines, MoveBomb etc to let  it know this is a Tobruk bumrush group & so to leave it alone & not re-write its waypoints etc
                groupname = "BoB_RAF_B_7Sqn." + clc_random.Next(1, 15).ToString("00");

            }
            Console.WriteLine("Bumrush Attack FIGHTER group: " + aircraft);          

            string s = "";
            string k = "";
            string v = "";

            s = "AirGroups";
            k = groupname; v = ""; f.add(s, k, v);
            s = groupname;

            f = addFlights(s, f, numInFlight, 3, 3);

          

            k = "Class"; v = aircraft; f.add(s, k, v);
            k = "Formation"; v = formation; f.add(s, k, v);
            k = "CallSign"; v = clc_random.Next(1, 35).ToString(); f.add(s, k, v); //looks like maybe there are only 35 official callsigns and up through TF 5.005 choosing the last of those will cause an regular error.
            k = "Fuel"; v = "40"; f.add(s, k, v);
            /* 
            k = "Weapons"; v = weapons; f.add(s, k, v);
            foreach (string d in detonatorL)
            {
                k = "Detonator"; v = d; f.add(s, k, v);
            }
            */
            k = "Skill"; v = string.Format("{0:N2} {1:N2} {2:N2} {3:N2} {4:N2} {5:N2} {6:N2} {7:N2}", new object[] {clc_random.Next(25,75)/100.0, clc_random.Next(25, 75) / 100.0, clc_random.Next(25, 76) / 100.0,
             clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0,clc_random.Next(25,75)/100.0});// "0.32 0.32 1 0.58 0.32 1 0.32 0.32"; f.add(s, k, v);
            k = "Aging"; v = clc_random.Next(5, 90).ToString(); f.add(s, k, v);


            //So task HUNTING seems to attack any bomber or fighter it sees.  I think we miostlyi want ot attack fighters here as the goal is to stop fighters from taking out target after t arget
            //But it could be bombers , too, sometimes and I'm not sure what a 110 or Beaufighter is classified as exactly.
            //Better would be to look for enemy breather pilots targeting things in the area but that is a bit too complicated probably. (Bit of scripting required.)
            string[] tsks = new string[] { "HUNTING", "HUNTING", "HUNTING", "AATTACK_FIGHTERS", "AATTACK_FIGHTERS", "AATTACK_FIGHTERS", "AATTACK_FIGHTERS", "AATTACK_FIGHTERS", "AATTACK_FIGHTERS" }; 

            s = groupname + "_Way";
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { p1.x, p1.y, alt_m, vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, alt_m + clc_random.Next(-300, 300), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { p2.x, p2.y, alt_m, vel_kmh}); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, alt_m + clc_random.Next(-300, 300), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { gat.x + 100, gat.y + 100, alt_m + clc_random.Next(-100,100), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, alt_m + clc_random.Next(-300, 300), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { p4.x, p4.y, alt_m + clc_random.Next(-150, 150), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { gap.x, gap.y, alt_m + clc_random.Next(-300, 300), vel_kmh }); f.add(s, k, v);
            k = Calcs.randSTR(tsks); v = String.Format("{0} {1} {2} {3}", new object[] { p6.x, p6.y, p6.z, vel_kmh }); f.add(s, k, v);
            

            //New point 1/4 of the way from p6 to lan
            //If there is a friendly airport  nearby there, make it land there
            Point3d apLook = new Point3d((3 * p6.x + lan.x) / 4, (3 * p6.y + lan.y) / 4, lan.z);
            AiAirport ap = mission.covermission.Stb_nearestAirport(apLook, planeArmy, isSeaplane: false);
            if (ap != null && CalculatePointDistance(ap.Pos(), p6) > 10000)
            {
                k = "LANDING"; v = String.Format("{0} {1} {2} {3}", new object[] { ap.Pos().x, ap.Pos().y, lan.z, vel_kmh }); f.add(s, k, v);
            }
            else
            {

                k = "LANDING"; v = String.Format("{0} {1} {2} {3}", new object[] { lan.x, lan.y, lan.z, vel_kmh }); f.add(s, k, v);
            }
            //BUG: The STUKA (only???!??) if it has TWO landing waypoints, will IMMEDIATELY drop all bombs.  So, that is crazy.  But only put ONE landing waypoint.

            return f;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Calcs Build Fighter ERROR: " + ex.ToString());
            return GamePlay.gpCreateSectionFile();
        }
    }

    /*
    /// <summary>
    /// Removes all event handlers subscribed to the specified routed event from the specified element.
    /// </summary>
    /// <param name="element">The UI element on which the routed event is defined.</param>
    /// <param name="routedEvent">The routed event for which to remove the event handlers.</param>
    public static void RemoveRoutedEventHandlers(Delegate element, Event routedEvent)
    {
        // Get the EventHandlersStore instance which holds event handlers for the specified element.
        // The EventHandlersStore class is declared as internal.
        var eventHandlersStoreProperty = typeof(UIElement).GetProperty(
            "EventHandlersStore", BindingFlags.Instance | BindingFlags.NonPublic);
        object eventHandlersStore = eventHandlersStoreProperty.GetValue(element, null);

        // If no event handlers are subscribed, eventHandlersStore will be null.
        // Credit: https://stackoverflow.com/a/16392387/1149773
        if (eventHandlersStore == null)
            return;

        // Invoke the GetRoutedEventHandlers method on the EventHandlersStore instance 
        // for getting an array of the subscribed event handlers.
        var getRoutedEventHandlers = eventHandlersStore.GetType().GetMethod(
            "GetRoutedEventHandlers", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        var routedEventHandlers = (RoutedEventHandlerInfo[])getRoutedEventHandlers.Invoke(
            eventHandlersStore, new object[] { routedEvent });

        // Iteratively remove all routed event handlers from the element.
        foreach (var routedEventHandler in routedEventHandlers)
            element.RemoveHandler(routedEvent, routedEventHandler.Handler);
    }
    //https://stackoverflow.com/questions/91778/how-to-remove-all-event-handlers-from-an-event
    public static void RemoveAllDelegatesFromEvent(Event E) //Delegate d, EventArgs A) //, FormClosingEventArgs e)
    {
        foreach (Delegate d in E.GetInvocationList())
        {
            E -= (FindClickedHandler)d;
        }
    }
    */
    //looks like this.Something = null; //erases all event handlers.  Urgh.

    public static void RemoveDelegates(Object b)
    {
        //FieldInfo f1 = typeof(Control).GetField("EventClick",
        //    BindingFlags.Static | BindingFlags.NonPublic);
        //object obj = f1.GetValue(b);
        PropertyInfo pi = b.GetType().GetProperty("Events",
            BindingFlags.NonPublic | BindingFlags.Instance);
        EventHandlerList list = (EventHandlerList)pi.GetValue(b, null);
        //list.RemoveHandler(obj, list[obj]);
    }

    public static IEnumerable<string> GetEventKeysList(Component issuer)
    {

        System.Reflection.PropertyInfo eventsProp = typeof(Component).GetProperty("Events", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
        return
            from key in issuer.GetType().GetFields(BindingFlags.Static |
            BindingFlags.NonPublic | BindingFlags.FlattenHierarchy)
            where key.Name.StartsWith("Event")
            select key.Name;
    }
    public static string randSTR(string[] strings)
    {
        //Random clc_random = new Random();
        return strings[clc_random.Next(strings.Length)];
    }
    public static string randSTR(List<string> strings)
    {
        //Random clc_random = new Random();
        return strings[clc_random.Next(strings.Count)];
    }

    public static void Randomize<T>(T[] items)
    {
        Random rand = new Random();

        // For each spot in the array, pick
        // a random item to swap into that spot.
        for (int i = 0; i < items.Length - 1; i++)
        {
            int j = rand.Next(i, items.Length);
            T temp = items[i];
            items[i] = items[j];
            items[j] = temp;
        }
    }
    //So, sometimes we want a simple repeatable seed value for 
    //random that will give the same set of random numbers each time
    //a routine runs with the same underlying values, but a different set
    //if different values.  So you can compile some objects associated with the routine
    //that are different each time around but the same if it repeats, and this will give a
    //simple repeatable different int in return.  Obviously . . . not cryptographically secure or anything.
    public static int seedObj(object[] objs)
    {
        string amalg = "";
        foreach (object o in objs) amalg += o.ToString();
        byte[] bytes = Encoding.ASCII.GetBytes(amalg);
        ulong seed = 3;
        foreach (byte b in bytes) seed += (ulong)b;
        seed = seed % int.MaxValue; //probably paranoid, but using ulong to avoid overflows & then modding by int's maxvalue & returning by int, which is what we need.
        return Convert.ToInt32(seed);
    }
} //end class Calcs


public class ReverseComparer2 : IComparer<string>
    {
        public int Compare(string x, string y)
        {
            // Compare y and x in reverse order.
            return y.CompareTo(x);
        }
    }

    public class ReverseComparer3<T> : IComparer<T> where T : IComparable<T>
    {
        public int Compare(T x, T y)
        {
            return y.CompareTo(x);
        }
    }

    public sealed class ReverseComparer<T> : IComparer<T>
    {
        private readonly IComparer<T> inner;
        public ReverseComparer() : this(null) { }
        public ReverseComparer(IComparer<T> inner)
        {
            this.inner = inner ?? Comparer<T>.Default;
        }
        int IComparer<T>.Compare(T x, T y) { return inner.Compare(y, x); }
    }

/*
public static IEnumerable<T> Randomize<T>(this IEnumerable<T> source)
{
    Random rnd = new Random();
    return source.OrderBy<T, int>((item) => rnd.Next());
}
*/
namespace Ini
{
    /// <summary>
    /// Create a New INI file to store or load data
    /// https://www.codeproject.com/Articles/1966/An-INI-file-handling-class-using-C
    /// </summary>
    public class IniFile
    {
        public string path;
        //public Mission mission;
        public int iniErrorCount;

        [DllImport("kernel32")]
        private static extern long WritePrivateProfileString(string section, string key, string val, string filePath);
        [DllImport("kernel32")]
        private static extern int GetPrivateProfileString(string section, string key, string def, StringBuilder retVal, int size, string filePath);

        /// <summary>
        /// INIFile Constructor.
        /// </summary>
        /// <param name="INIPath"></param>
        //public IniFile(string INIPath, Mission msn)
        public IniFile(string INIPath)
        {
            path = INIPath;
            //mission = msn;
            iniErrorCount = 0;

        }
        public void IniDeleteSection(string Section)
        {
            WritePrivateProfileString(Section, null, null, this.path);
        }

        /// <summary>
        /// Write Data to the INI File
        /// </summary>
        /// <param name="Section"></param>
        /// Section name
        /// <param name="Key"></param>
        /// Key Name
        /// <param name="Value"></param>
        /// Value Name
        public void IniWriteValue(string Section, string Key, string Value)
        {
            WritePrivateProfileString(Section, Key, "\"" + Value + "\"", this.path);
        }

        public void IniWriteList(string Section, string Key, List<string> Value)
        {
            int count = 0;
            WritePrivateProfileString(Section, "Count", Value.Count.ToString(), this.path);
            //Console.WriteLine("INIW: Count" + Value.Count.ToString());
            foreach (string s in Value)
            {
                WritePrivateProfileString(Section, Key + "[" + count.ToString() + "]", "\"" + s + "\"", this.path);
                count++;
                //Console.WriteLine("INIW: Count" + Section + " " + Key + "[" + count.ToString() + "]" + " " + s);
            }
        }
        public List<string> IniReadList(string Section, string Key)
        {
            List<string> l = new List<string>() { };

            int total = IniReadValue(Section, "Count", (int)0);

            if (total == 0) return l;
            for (int x = 0; x < total; x++)
            {

                l.Add(IniReadValue(Section, Key + "[" + x.ToString() + "]", ""));
            }

            return l;
        }



        /// <summary>
        /// Read Data Value From the Ini File
        /// </summary>
        /// <param name="Section"></param>
        /// <param name="Key"></param>
        /// <param name="Path"></param>
        /// <returns></returns>
        //overloaded for string, int, double, bool.  Could do others like single, float, whatever.  String[] int[] double[] etc.
        public string IniReadValue(string Section, string Key, string def)
        {
            StringBuilder temp = new StringBuilder(1024);
            int i = GetPrivateProfileString(Section, Key, "", temp, 1024, this.path);
            if (temp.Length > 0) return temp.ToString();
            {
                IniReadError(Section, Key);
                return def;
            }
        }
        public int IniReadValue(string Section, string Key, int def)
        {
            StringBuilder temp = new StringBuilder(1024);
            int i = GetPrivateProfileString(Section, Key, "", temp, 1024, this.path);
            int a;
            if (temp.Length > 0 && int.TryParse(temp.ToString(), out a)) return a;
            {
                IniReadError(Section, Key);
                return def;
            }
        }
        public double IniReadValue(string Section, string Key, double def)
        {
            StringBuilder temp = new StringBuilder(1024);
            int i = GetPrivateProfileString(Section, Key, "", temp, 1024, this.path);
            double a;
            if (temp.Length > 0 && double.TryParse(temp.ToString(), out a)) return a;
            {
                IniReadError(Section, Key);
                return def;
            }
        }
        public bool IniReadValue(string Section, string Key, bool def)
        {
            StringBuilder temp = new StringBuilder(1024);
            int i = GetPrivateProfileString(Section, Key, "", temp, 1024, this.path);
            if (temp.ToString().Trim() == "1") temp = new StringBuilder("True", 4); //allow 0 & 1 to be used, or True/true/False/false
            if (temp.ToString().Trim() == "0") temp = new StringBuilder("False", 5);
            bool a;
            if (temp.Length > 0 && bool.TryParse(temp.ToString(), out a)) return a;
            else
            {
                IniReadError(Section, Key);
                return def;
            }
        }
        private void IniReadError(String Section, String Key)
        {
            iniErrorCount++;
            Console.WriteLine("-main.cs: ERROR reading .ini file: Key {0} in Section {1} was not found.", Key, Section);

        }
    }
}

//Circular array which operates as a limited size queue OR stack
//Based on https://www.codeproject.com/Articles/31652/A-Generic-Circular-Array
public class CircularArray<T>
{
    private readonly T[] _baseArray;
    private readonly T[] _facadeArray;
    private int _head;
    private bool _isFilled;

    public CircularArray(int length)
    {
        _baseArray = new T[length];
        _facadeArray = new T[length];
    }

    //Array in queue order (first queued = first of array)
    public T[] Array
    {
        get
        {
            try
            {
                int pos = _head;
                for (int i = 0; i < _baseArray.Length; i++)
                {
                    Math.DivRem(pos, _baseArray.Length, out pos);
                    _facadeArray[i] = _baseArray[pos];
                    pos++;
                }
                return _facadeArray;
            }
            catch (Exception ex)
            {

                Console.WriteLine("CircularArray ERROR: " + ex.ToString());
                return _facadeArray;

            }
        }
    }

    //Array in stack order (last queued = first of array)
    public T[] ArrayStack
    {
        get
        {
            try
            {
                int pos = _head - 1 + 2 * _baseArray.Length;  //by adding 2*_baseArray.Length we can count downwards by _baseArray.Length with no worries about going below 0 for our index.  We have to go 2* bec _head might be zero meaning our starting point might be -1
                for (int i = 0; i < _baseArray.Length; i++)
                {
                    Math.DivRem(pos, _baseArray.Length, out pos);
                    //Console.WriteLine("ArrayStack: " + i.ToString() + " " + pos.ToString());

                    _facadeArray[i] = _baseArray[pos];
                    pos--;
                    pos = pos < 0 ? pos + _baseArray.Length : pos;
                }
                return _facadeArray;
            }
            catch (Exception ex)
            {
                
                    Console.WriteLine("ArrayStack ERROR: " + ex.ToString());
                    return _facadeArray;
                
            }
        }
    }

    public T[] BaseArray
    {
        get { return _baseArray; }
    }

    public bool IsFilled
    {
        get { return _isFilled; }
    }

    public void Push(T value)
    {
        try
        {
            if (!_isFilled && _head == _baseArray.Length - 1)
                _isFilled = true;

            Math.DivRem(_head, _baseArray.Length, out _head);
            _baseArray[_head] = value;
            _head++;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Push ERROR: " + ex.ToString());
        }

    }

    //Gets end of queue (ie, the first value entered) if 0 or 2nd, 3rd, etc value entered if index 1, 2, 3 etc
    //10/2018 - this seems incorrect. This gets the last value pushed onto the array if 0, 2nd to last if 1, etc.
    public T Get(int indexBackFromHead)
    {
        try { 
        int pos = _head - indexBackFromHead - 1;
        pos = pos < 0 ? pos + _baseArray.Length : pos;
        Math.DivRem(pos, _baseArray.Length, out pos);
        return _baseArray[pos];
        }
        catch (Exception ex)
        {
            Console.WriteLine("Get ERROR: " + ex.ToString());
            return _baseArray[0];
        }
    }

    //Gets top of the stack (ie, the last value entered) if 0 or 2nd to last, 3rd to last, etc if index 1, 2, 3 etc 
    ////10/2018 - this seems incorrect. This gets the tail of the array, ie the first value pushed onto the array (that still remains), ie the oldest value in the array, if 0, 2nd to last if 1, etc.
    public T GetStack(int indexForwardFromHead)
    {
        try { 
        int pos = _head + indexForwardFromHead;
        pos = pos < 0 ? pos + _baseArray.Length : pos;
        Math.DivRem(pos, _baseArray.Length, out pos);
        return _baseArray[pos];
        }
        catch (Exception ex)
        {
            Console.WriteLine("GetStack ERROR: " + ex.ToString());
            return _baseArray[0];
        }
    }
}

/*
namespace cevent
{
    //--------------------------------------------------------------------------------
    static public class cEventHelper
    {
        static Dictionary<Type, List<FieldInfo>> dicEventFieldInfos = new Dictionary<Type, List<FieldInfo>>();

        static BindingFlags AllBindings
        {
            get { return BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static; }
        }

        //--------------------------------------------------------------------------------
        static List<FieldInfo> GetTypeEventFields(Type t)
        {
            if (dicEventFieldInfos.ContainsKey(t))
                return dicEventFieldInfos[t];

            List<FieldInfo> lst = new List<FieldInfo>();
            BuildEventFields(t, lst);
            dicEventFieldInfos.Add(t, lst);
            return lst;
        }

        //--------------------------------------------------------------------------------
        static void BuildEventFields(Type t, List<FieldInfo> lst)
        {
            // Type.GetEvent(s) gets all Events for the type AND it's ancestors
            // Type.GetField(s) gets only Fields for the exact type.
            //  (BindingFlags.FlattenHierarchy only works on PROTECTED & PUBLIC
            //   doesn't work because Fieds are PRIVATE)

            // NEW version of this routine uses .GetEvents and then uses .DeclaringType
            // to get the correct ancestor type so that we can get the FieldInfo.
            foreach (EventInfo ei in t.GetEvents(AllBindings))
            {
                Type dt = ei.DeclaringType;
                FieldInfo fi = dt.GetField(ei.Name, AllBindings);
                if (fi != null)
                    lst.Add(fi);
            }

            // OLD version of the code - called itself recursively to get all fields
            // for 't' and ancestors and then tested each one to see if it's an EVENT
            // Much less efficient than the new code
            /*
                  foreach (FieldInfo fi in t.GetFields(AllBindings))
                  {
                    EventInfo ei = t.GetEvent(fi.Name, AllBindings);
                    if (ei != null)
                    {
                      lst.Add(fi);
                      Console.WriteLine(ei.Name);
                    }
                  }
                  if (t.BaseType != null)
                    BuildEventFields(t.BaseType, lst); * ///
        }

        //--------------------------------------------------------------------------------
        static EventHandlerList GetStaticEventHandlerList(Type t, object obj)
        {
            MethodInfo mi = t.GetMethod("get_Events", AllBindings);
            return (EventHandlerList)mi.Invoke(obj, new object[] { });
        }

        //--------------------------------------------------------------------------------
        public static void RemoveAllEventHandlers(object obj) { RemoveEventHandler(obj, ""); }

        //--------------------------------------------------------------------------------
        public static void RemoveEventHandler(object obj, string EventName)
        {
            if (obj == null)
                return;

            Type t = obj.GetType();
            List<FieldInfo> event_fields = GetTypeEventFields(t);
            EventHandlerList static_event_handlers = null;

            foreach (FieldInfo fi in event_fields)
            {
                if (EventName != "" && string.Compare(EventName, fi.Name, true) != 0)
                    continue;

                // After hours and hours of research and trial and error, it turns out that
                // STATIC Events have to be treated differently from INSTANCE Events...
                if (fi.IsStatic)
                {
                    // STATIC EVENT
                    if (static_event_handlers == null)
                        static_event_handlers = GetStaticEventHandlerList(t, obj);

                    object idx = fi.GetValue(obj);
                    Delegate eh = static_event_handlers[idx];
                    if (eh == null)
                        continue;

                    Delegate[] dels = eh.GetInvocationList();
                    if (dels == null)
                        continue;

                    EventInfo ei = t.GetEvent(fi.Name, AllBindings);
                    foreach (Delegate del in dels)
                        ei.RemoveEventHandler(obj, del);
                }
                else
                {
                    // INSTANCE EVENT
                    EventInfo ei = t.GetEvent(fi.Name, AllBindings);
                    if (ei != null)
                    {
                        object val = fi.GetValue(obj);
                        Delegate mdel = (val as Delegate);
                        if (mdel != null)
                        {
                            foreach (Delegate del in mdel.GetInvocationList())
                                ei.RemoveEventHandler(obj, del);
                        }
                    }
                }
            }
        }

        //--------------------------------------------------------------------------------
    }
}
*/

class twcLandscape : maddox.core.WLandscape
{
    //DON'T USE THIS DIRECTLY!@@@
    //Instead use Calcs.LandElevation_m(Pos); //corrects for negative elevation values over water
    public static double HQ(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cHQ((float)x, (float)y);
        //Console.WriteLine("Height HQ" + height.ToString());
        return height;
    }
    public static double H(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cH((float)x, (float)y);
        //Console.WriteLine("Height H" + height.ToString());
        return height;
    }
    public static double Hmax(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cHmax((float)x, (float)y);
        //Console.WriteLine("cHmax" + height.ToString());
        return height;
    }
    public static double Hmin(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cHmin((float)x, (float)y);
        //Console.WriteLine("cHmin" + height.ToString());
        return height;
    }
    public static double HQ_air(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cHQ_Air((float)x, (float)y);
        //Console.WriteLine("Height HQ_air" + height.ToString());
        return height;
    }
    public static double HQ_forestHeightHere(double x, double y)
    {
        //wcLandscape twcL = new twcLandscape();
        double height = twcLandscape.cHQ_forestHeightHere((float)x, (float)y);
        //Console.WriteLine("Height HQ_forestHeightHere" + height.ToString());
        return height;
    }
}
